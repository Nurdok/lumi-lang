# MR2 compiler - written in MR1

native func print(user String text)

native type File
native func file-open-read(user String name): owner File file
native func file-open-write(user String name): owner File file
native func file-close(owner File this)
native func file-getc(user File this): copy Char ch
native func file-putc(user File this, copy Char ch)
native func file-write(user File this, user String line)

native func string-clear(user String this)
native func string-length(user String this): copy Int length
native func string-equal(user String this, user String other): copy Bool equal
native func string-get(user String this, copy Int index): copy Char ch
native func string-append(user String this, copy Char ch)
native func string-copy(user String this, user String source)
native func string-concat(user String this, user String ext)
native func string-find(user String this, user String pattern): copy Int index
native func string-replace(user String this, copy Char old-ch, copy Char new-ch)
native func string-has(user String this, copy Char ch): copy Bool found
native func int-to-string(copy Int value): var String str

native func array-length(user Array{} arr): copy Int length

native func sys-exit(copy Int status)
native func sys-system(user String command): copy Int status
native func sys-getenv(user String name): copy Bool exists, var String value


native type Generic

# Function Map
class Key-value
  owner String key
  var Func value

func kv-add(user Array{Key-value} map, copy Int index, user String key, copy Func value)
  var Key-value kv
  [] Key-value kv := map[index]
  var Int length(0)
  string-length(user key): copy length
  new String{length} new-key
  string-copy(user new-key, user key)
  kv.key := new-key
  kv.value := value
  return

func kv-find(user Array{Key-value} map, user String key): copy Func value, copy Bool found
  var Int length
  array-length(user map): copy length
  for n in length
    var Key-value kv
    [] Key-value kv := map[n]
    var Bool flag
    if string-equal(user key, user kv.key): copy flag
      out found := true
      out value := kv.value
      return
    
  
  out found := false
  return

# Syntax Tree
class St
  owner St next-brother
  owner St firSt-son
  user St laSt-son
  user St father
  var Func writer
  owner Generic value

func St-new(copy Func writer, owner Generic value, user St father): owner St res
  new St self
  self.next-brother := NULL
  self.firSt-son := NULL
  self.laSt-son := NULL
  self.father := father
  self.writer := writer
  self.value := value
  out res := self
  if father != NULL
    if father.firSt-son = NULL
      father.firSt-son := self
    
    else
      father.laSt-son.next-brother := self
    
    father.laSt-son := self
  
  return

func St-del(owner St self)
  if self = NULL
    return
  
  St-del(owner self.firSt-son)
  St-del(owner self.next-brother)
  delete self
  return

# Global data
class Global-data
  # data
  owner File infile
  owner File outfile
  user Array{Key-value} key-word-map
  # state
  user St curr
  var Int spaces
  # vars
  var Int length
  var Bool flag
  var Char end

var Global-data glob

# read helpers
func readc(): copy Char ch
  file-getc(user glob.infile): var ch
  return

func read-ignore(copy Int chars)
  for n in chars
    readc(): copy glob.end
  
  return

func read-indent(user String ends, copy Bool indent): var String text, copy Char end, copy Int out-spaces
  string-clear(user text)
  var Char ch(EOF)
  var Char q('\0')
  var Int spaces(0)
  do
    # ignore indent
    readc(): copy ch
    if indent
      do
        while ch = ' '
        spaces := spaces + 1
        readc(): copy ch
      
      indent := false
    
    while ch != EOF
    if q != '\0'
      if ch = '\\'
        string-append(user text, copy ch)
        readc(): copy ch
      
      else-if ch = q
        q := '\0'
      
    
    else
      while ch != '\n'
      while string-has(user ends, copy ch): copy glob.flag = false
      if ch = '\'' or ch = '"'
        q := ch
      
    
    string-append(user text, copy ch)
  
  out end := ch
  out out-spaces := spaces
  return

func read(user String ends): var String text, copy Char end
  var Int spaces(0)
  read-indent(user ends, copy false): var text, var end, copy spaces
  return

func new-copy(user String text): owner String out-text
  string-length(user text): copy glob.length
  new String{glob.length + 1} new-text
  string-copy(user new-text, user text)
  out out-text := new-text
  return

func read-new(user String ends): owner String out-text, copy Char end
  var String{256} text
  read(user ends): var text, var end
  new-copy(user text): var out-text
  return

# write helpers
func writec(copy Char ch)
  file-putc(user glob.outfile, copy ch)
  return

func write(user String text)
  file-write(user glob.outfile, user text)
  return

func write-csyle-char(copy Char ch, copy Char prev)
  if ch = '-' and prev != ' '
    writec(copy '_')
  
  else-if ch = '.'
    write(user "->")
  
  else-if ch = '=' and prev = ' '
    write(user "==")
  
  else-if ch != ':'
    writec(copy ch)
  
  return

func write-cstyle(user String text)
  var Char prev(' ')
  string-length(user text): copy glob.length
  for index in glob.length
    var Char ch
    string-get(user text, copy index): copy ch
    write-csyle-char(copy ch, copy prev)
    prev := ch
  
  return

# other helpers
func add-node(copy Func writer, owner Generic value)
  user St node
  St-new(copy writer, user value, user glob.curr): user node
  return

func string-split(user String text, copy Char sep): copy Int index, copy Int length
  string-length(user text): copy glob.length
  if string-has(user text, copy sep): copy glob.flag
    var String{2} sep-str
    string-append(user sep-str, copy sep)
    var Int sep-index
    string-find(user text, user sep-str): copy sep-index
    out index := sep-index
    out length := glob.length - sep-index - 1
  
  else
    out index := glob.length
    out length := 0
  
  return

func is-primitive(user String typename): copy Bool res
  var Bool flag
  if string-equal(user typename, user "Int"): copy flag
    out res := true
    return
  
  if string-equal(user typename, user "Char"): copy flag
    out res := true
    return
  
  if string-equal(user typename, user "Func"): copy flag
    out res := true
    return
  
  string-equal(user typename, user "Bool"): copy flag
  out res := flag
  return

# block helpers
func write-spaces()
  for n in glob.spaces
    write(user " ")
  
  return

func write-sons()
  user St son(glob.curr.firSt-son)
  do
    while son != NULL
    glob.curr := son
    write-spaces()
    son.writer(user son.value)
    son := son.next-brother
  
  return

func start-block()
  glob.spaces := glob.spaces + 2
  glob.curr := glob.curr.laSt-son
  return

func end-block()
  glob.curr := glob.curr.father
  glob.spaces := glob.spaces - 2
  return

func write-block-suffix(user String suffix)
  write(user " {\n")
  glob.spaces := glob.spaces + 2
  write-sons()
  glob.spaces := glob.spaces - 2
  write-spaces()
  write(user "}")
  write(user suffix)
  return

func write-block()
  write-block-suffix(user "\n")
  return

# empty
func write-empty(user Generic null)
  write(user "\n")
  return

func add-empty()
  add-node(copy write-empty, owner NULL)
  return

# title
func write-title(user String title)
  write(user "/* #title <")
  write(user title)
  write(user "> */\n")
  glob.spaces := glob.spaces + 2
  write-sons()
  glob.spaces := glob.spaces - 2
  return


func add-title(user String text)
  string-length(user text): copy glob.length
  new String{glob.length + 1} title
  string-copy(user title, user text)
  add-node(copy write-title, owner title)
  # read rest of line
  var String{256} ignore-line
  read(user ""): var ignore-line, copy glob.end
  return

# comment
func write-comment(user String comment-text)
  write(user "/* ")
  write(user comment-text)
  write(user " */\n")
  return

func parse-comment()
  user String comment
  read-new(user ""): user comment, copy glob.end
  add-node(copy write-comment, owner comment)
  return

# function helpers
class St-arg
  owner St-arg next
  owner String name
  owner String typename
  owner String type-param
  owner String access

class St-func
  owner String name
  owner St-arg params
  owner St-arg outputs

func write-args(user St-arg first, copy Bool is-out, user St-arg next)
  user St-arg arg(first)
  do
    while arg != NULL
    write-cstyle(user arg.typename)
    if string-equal(user arg.access, user "copy"): copy glob.flag = false
      write(user "*")
    
    if string-equal(user arg.access, user "var"): copy glob.flag = false and is-out
      write(user "*")
    
    write(user " ")
    write-cstyle(user arg.name)
    arg := arg.next
    if arg != NULL or next != NULL
      write(user ", ")
    
  
  return

func write-func-header(user St-func st-func)
  write(user "Returncode ")
  write-cstyle(user st-func.name)
  write(user "(")
  write-args(user st-func.params, copy false, user st-func.outputs)
  write-args(user st-func.outputs, copy true, user NULL)
  write(user ")")
  return

func parse-func-header(user String name): owner St-func st-func, copy Char end
  new St-func new-func
  if name = NULL
    read-new(user "("): user new-func.name, copy glob.end
  
  else
    new-copy(user name): owner new-func.name
  
  new-func.params := NULL
  new-func.outputs := NULL
  user St-arg last(NULL)
  do
    var String{256} access
    while read(user " )"): var access, copy glob.end = ' '
    new St-arg param
    param.next := NULL
    param.typename := NULL
    param.type-param := NULL
    new-copy(user access): owner param.access
    if name = NULL
      if read-new(user " {"): owner param.typename, copy glob.end = '{'
        read-new(user "}"): owner param.type-param, copy glob.end
        readc(): copy glob.end
      
    
    read-new(user ",)"): owner param.name, copy glob.end
    if last = NULL
      new-func.params := param
    
    else
      last.next := param
    
    last := param
    while glob.end = ','
    readc(): copy glob.end
  
  readc(): copy glob.end
  last := NULL
  do
    while glob.end != '\n'
    readc(): copy glob.end
    new St-arg param
    param.next := NULL
    read-new(user " "): owner param.access, copy glob.end
    if name = NULL
      read-new(user " "): owner param.typename, copy glob.end
    
    else
      param.typename := NULL
    
    read-new(user ", "): owner param.name, copy glob.end
    if last = NULL
      new-func.outputs := param
    
    else
      last.next := param
    
    last := param
    while glob.end = ','
  
  out st-func := new-func
  out end := glob.end
  return

# func
func write-func(user St-func st-func)
  write-func-header(user st-func)
  write-block()
  return

func parse-func()
  owner St-func st-func
  parse-func-header(user NULL): owner st-func, copy glob.end
  add-node(copy write-func, owner st-func)
  start-block()
  return

# native
func write-native-type(user String name)
  write(user "typedef void ")
  write-cstyle(user name)
  write(user ";\n")
  return

func write-native-func(user St-func st-func)
  write-func-header(user st-func)
  write(user ";\n")
  return

func parse-native()
  var String{80} kind
  read(user " "): var kind, copy glob.end
  if string-equal(user kind, user "func"): copy glob.flag
    owner St-func st-func
    parse-func-header(user NULL): owner st-func, copy glob.end
    add-node(copy write-native-func, owner st-func)
  
  else
    owner String name
    read-new(user ""): owner name, copy glob.end
    add-node(copy write-native-type, owner name)
  
  return

# main
func write-main(user St-func st-func)
  write-func(user st-func)
  write(user "\nMAIN_FUNC\n")
  return

func parse-main()
  owner St-func st-func
  parse-func-header(user NULL): owner st-func, copy glob.end
  add-node(copy write-main, owner st-func)
  start-block()
  return

# declerations
class St-dec
  owner String name
  owner String typename
  owner String array-length
  owner String string-length
  owner String init
  owner String slice-start
  owner String slice-length

func parse-dec(): owner St-dec new-st-dec
  new St-dec st-dec
  st-dec.array-length := NULL
  st-dec.string-length := NULL
  st-dec.init := NULL
  st-dec.slice-start := NULL
  st-dec.slice-length := NULL
  
  read-new(user " {"): owner st-dec.typename, copy glob.end
  if glob.end = '{'
    var Bool is-array
    if string-equal(user st-dec.typename, user "Array"): copy is-array
      if read-new(user "}:"): owner st-dec.array-length, copy glob.end = ':'
        read-new(user "}{"): owner st-dec.typename, copy glob.end
      
    
    if string-equal(user st-dec.typename, user "String"): copy glob.flag
      read-new(user "}"): owner st-dec.string-length, copy glob.end
      readc(): copy glob.end
    
    if is-array
      readc(): copy glob.end
    
  
  if read-new(user "("): owner st-dec.name, copy glob.end = '('
    if read-new(user ")["): owner st-dec.init, copy glob.end = '['
      read-new(user ":"): owner st-dec.slice-start, copy glob.end
      read-new(user "]"): owner st-dec.slice-length, copy glob.end
      readc(): copy glob.end
    
    readc(): copy glob.end
  
  out new-st-dec := st-dec
  return

# var
func write-var-primitive(user St-dec st-dec)
  write-cstyle(user st-dec.typename)
  write(user " ")
  write-cstyle(user st-dec.name)
  if st-dec.init != NULL
    write(user " = ")
    write-cstyle(user st-dec.init)
  
  write(user ";\n")
  return

func write-ref-prefix(user String typename, user String name)
  write-cstyle(user typename)
  write(user "* ")
  write-cstyle(user name)
  write(user " = &(")
  write-cstyle(user typename)
  write(user "){")
  return

func write-var-class(user St-dec st-dec)
  write-ref-prefix(user st-dec.typename, user st-dec.name)
  write(user "0};\n")
  return

func write-var-string(user St-dec st-dec)
  write-ref-prefix(user "String", user st-dec.name)
  write(user st-dec.string-length)
  write(user ", 0, (char[")
  write(user st-dec.string-length)
  write(user "]){0}};\n")
  return

func write-var-array(user St-dec st-dec)
  write-ref-prefix(user "Array", user st-dec.name)
  write(user st-dec.array-length)
  write(user ", (")
  write-cstyle(user st-dec.typename)
  write(user "[")
  write(user st-dec.array-length)
  write(user "]){0}};")
  
  if st-dec.string-length != NULL
    write(user " char _")
    write-cstyle(user st-dec.name)
    write(user "_chars[")
    write(user st-dec.string-length)
    write(user "][")
    write(user st-dec.array-length)
    write(user "]; {int n; for(n=0; n<")
    write(user st-dec.array-length)
    write(user "; ++n) ((String*)(")
    write-cstyle(user st-dec.name)
    write(user "->values))[n] = (String){")
    write(user st-dec.string-length)
    write(user ", 0, _")
    write-cstyle(user st-dec.name)
    write(user "_chars[n]};}")
  
  write(user "\n")
  return

func parse-var()
  owner St-dec st-dec
  parse-dec(): owner st-dec
  
  if st-dec.array-length != NULL
    add-node(copy write-var-array, owner st-dec)
    return
  
  if st-dec.string-length != NULL
    add-node(copy write-var-string, owner st-dec)
    return
  
  if is-primitive(user st-dec.typename): copy glob.flag
    add-node(copy write-var-primitive, owner st-dec)
    return
  
  add-node(copy write-var-class, owner st-dec)
  return

# ref
func write-ref(user St-dec st-dec)
  if st-dec.slice-start != NULL
    write(user "if ((")
    write-cstyle(user st-dec.slice-start)
    write(user ") + (")
    write-cstyle(user st-dec.slice-length)
    write(user ") > ")
    write-cstyle(user st-dec.init)
    write(user "->")
    if st-dec.array-length = NULL
      write(user "actual_")
    
    write(user "length) RAISE ")
  
  write-cstyle(user st-dec.typename)
  write(user "* ")
  write-cstyle(user st-dec.name)
  
  if st-dec.init != NULL
    write(user " = ")
    if st-dec.slice-start = NULL
      write-cstyle(user st-dec.init)
    
    else-if st-dec.array-length != NULL
      write(user "&(Array){")
      write-cstyle(user st-dec.slice-length)
      write(user ", (Byte*)(")
      write-cstyle(user st-dec.init)
      write(user "->values) + (")
      write-cstyle(user st-dec.slice-start)
      write(user ") * sizeof(")
      write-cstyle(user st-dec.array-length)
      write(user ")}")
    
    else
      write(user "&(String){")
      write-cstyle(user st-dec.slice-length)
      write(user ", ")
      write-cstyle(user st-dec.slice-length)
      write(user ", ")
      write-cstyle(user st-dec.init)
      write(user "->chars + ")
      write-cstyle(user st-dec.slice-start)
      write(copy "}")
    
  
  write(user ";\n")
  return

func parse-ref()
  owner St-dec st-dec
  parse-dec(): owner st-dec
  add-node(copy write-ref, owner st-dec)
  return

# new
func write-new(user St-dec st-dec)
  if st-dec.array-length != NULL
    write(user "Array")
  
  else
    write-cstyle(user st-dec.typename)
  
  write(user "* ")
  write-cstyle(user st-dec.name)
  write(user " = ")
  
  if st-dec.array-length != NULL
    write(user "new_array(")
    write-cstyle(user st-dec.array-length)
    write(user ", sizeof(")
    write-cstyle(user st-dec.typename)
    write(copy ")")
    if st-dec.string-length != NULL
      write(user " + (")
      write-cstyle(user st-dec.string-length)
      writec(copy ')')
    
  
  else-if st-dec.string-length != NULL
    write(user "new_string(")
    write-cstyle(user st-dec.string-length)
  
  else
    write(user "malloc(sizeof(")
    write-cstyle(user st-dec.typename)
    writec(copy ')')
    
  
  write(user "); if (")
  write-cstyle(user st-dec.name)
  write(user " == NULL) RAISE")
  
  if st-dec.array-length != NULL and st-dec.string-length != NULL
    write(user " {int n; for(n=0; n<(")
    write-cstyle(user st-dec.array-length)
    write(user "); ++n) ((String*)(")
    write-cstyle(user st-dec.name)
    write(user "->values))[n] = (String){")
    write-cstyle(user st-dec.string-length)
    write(user ", 0, (Byte*)(")
    write-cstyle(user st-dec.name)
    write(user "->values) + (")
    write-cstyle(user st-dec.array-length)
    write(user ") * sizeof(String) + (")
    write-cstyle(user st-dec.string-length)
    write(user ") * n};}")
  
  write(copy "\n")
  return

func parse-new()
  owner St-dec st-dec
  parse-dec(): owner st-dec
  add-node(copy write-new, owner st-dec)
  return

# delete
func write-delete(user String name)
  write(user "free(")
  write-cstyle(user name)
  write(user ");\n")
  return

func parse-delete()
  owner String name
  read-new(user ""): owner name, copy glob.end
  add-node(copy write-delete, owner name)
  return

# expression
class St-exp
  owner String prefix
  owner St-func call
  owner String suffix

func real-string-length(user String text): copy Int length
  var Int index(1)
  var Int real-length(1)
  var Int text-length
  string-length(user text): copy text-length
  text-length := text-length - 1
  do
    while index < text-length
    if string-get(user text, copy index): copy glob.end = '\\'
      index := index + 1
    
    real-length := real-length + 1
    index := index + 1
  
  out length := real-length
  return

func write-func-call(user St-func st-func)
  write(user "CHECK(")
  write-cstyle(user st-func.name)
  write(user "(")
  user St-arg arg(st-func.params)
  do
    while arg != NULL
    if string-get(user arg.name, user 0): copy glob.end = '"'
      real-string-length(user arg.name): copy glob.length
      var String{80} length-str
      write(user "&(String){")
      int-to-string(copy glob.length): var length-str
      write(user length-str)
      write(user ", ")
      glob.length := glob.length - 1
      int-to-string(copy glob.length): var length-str
      write(user length-str)
      write(user ", ")
      write(user arg.name)
      write(user "}")
    
    else
      write-cstyle(user arg.name)
    
    arg := arg.next
    if arg != NULL or st-func.outputs != NULL
      write(user ", ")
    
  
  arg := st-func.outputs
  do
    while arg != NULL
    if string-equal(user arg.access, user "var"): copy glob.flag = false
      write(copy "&")
    
    write-cstyle(user arg.name)
    arg := arg.next
    if arg != NULL
      write(user ", ")
    
  
  write(user "))")
  return

func write-exp-call(user St-exp st-exp)
  if st-exp.call != NULL
    write-func-call(user st-exp.call)
    write(user " ")
  
  return

func write-exp(user St-exp st-exp)
  if st-exp.call != NULL
    user St-arg last(st-exp.call.outputs)
    if last = NULL
      raise
    
    do
      while last.next != NULL
      last := last.next
    
    write-cstyle(user last.name)
    
  
  else
    write-cstyle(user st-exp.prefix)
  
  if st-exp.suffix != NULL
    write(user " ")
    write-cstyle(user st-exp.suffix)
  
  return

func parse-exp(): owner St-exp new-st-exp
  new St-exp st-exp
  st-exp.call := NULL
  st-exp.suffix := NULL
  var Char end
  if read-new(user " ("): owner st-exp.prefix, copy end = '('
    parse-func-header(user st-exp.prefix): owner st-exp.call, copy end
  
  if end = ' '
    read-new(user ""): owner st-exp.suffix, copy end
  
  out new-st-exp := st-exp
  return

# if
func write-if(user St-exp st-exp)
  write-exp-call(user st-exp)
  write(user "if (")
  write-exp(user st-exp)
  write(user ")")
  write-block()
  return

func parse-if()
  owner St-exp st-exp
  parse-exp(): owner st-exp
  add-node(copy write-if, owner st-exp)
  start-block()
  return

# else
func write-else(user Generic null)
  write(user "else")
  write-block()
  return

func parse-else()
  add-node(copy write-else, user NULL)
  start-block()
  return

# else-if
func write-else-if(user St-exp st-exp)
  write-exp-call(user st-exp)
  write(user "else if (")
  write-exp(user st-exp)
  write(user ")")
  write-block()
  return

func parse-else-if()
  owner St-exp st-exp
  parse-exp(): owner st-exp
  add-node(copy write-else-if, owner st-exp)
  start-block()
  return

# do
func write-do(user Generic null)
  write(user "while (true)")
  write-block()
  return

func parse-do()
  add-node(copy write-do, user NULL)
  start-block()
  return

# while
func write-while(user St-exp st-exp)
  write-exp-call(user st-exp)
  write(user "if (not(")
  write-exp(user st-exp)
  write(user ")) break;\n")
  return

func parse-while()
  owner St-exp st-exp
  parse-exp(): owner st-exp
  add-node(copy write-while, owner st-exp)
  return

# for
class St-for
  owner String counter
  owner St-exp limit

func write-for(user St-for st-for)
  write-exp-call(user st-for.limit)
  write(user "Int ")
  write-cstyle(user st-for.counter)
  write(user "; for (")
  write-cstyle(user st-for.counter)
  write(user " = 0; ")
  write-cstyle(user st-for.counter)
  write(user " < ")
  write-exp(user st-for.limit)
  write(user "; ++")
  write-cstyle(user st-for.counter)
  write(user ")")
  write-block()
  return

func parse-for()
  new St-for st-for
  read-new(user " "): owner st-for.counter, copy glob.end
  # ignore "in "
  read-ignore(copy 3)
  parse-exp(): owner st-for.limit
  add-node(copy write-for, owner st-for)
  start-block()
  return

# return
func write-return(user Generic null)
  write(user "return OK;\n")
  return

func parse-return()
  add-node(user write-return, user NULL)
  return

# raise
func write-raise(user Generic null)
  write(user "RAISE\n")
  return

func parse-raise()
  add-node(user write-raise, user NULL)
  return

# class
func write-class(user String name)
  write(user "typedef struct ")
  write-cstyle(user name)
  write(user " ")
  write-cstyle(user name)
  write(user "; struct ")
  write-cstyle(user name)
  write-block-suffix(user ";\n")
  return

func parse-class()
  owner String name
  read-new(user ""): owner name, copy glob.end
  add-node(copy write-class, owner name)
  start-block()
  return

# ... array
class St-array
  owner String typename
  owner String array
  owner String variable
  owner String index
  var Bool is-set

func write-array(user St-array st-array)
  write(user "if (")
  write-cstyle(user st-array.index)
  write(user " < 0 || ")
  write-cstyle(user st-array.index)
  write(user " >= ")
  write-cstyle(user st-array.array)
  write(user "->length) RAISE ")
  if not st-array.is-set
    write-cstyle(user st-array.variable)
    write(user " = ")
  
  write(user "((")
  write-cstyle(user st-array.typename)
  write(user "*)(")
  write-cstyle(user st-array.array)
  write(user "->values))")
  if is-primitive(user st-array.typename): copt glob.flag or st-array.is-set
    write(user "[")
    write-cstyle(user st-array.index)
    write(user "]")
  
  else
    write(user " + ")
    write-cstyle(user st-array.index)
  
  if st-array.is-set
    write(user " = ")
    write-cstyle(user st-array.variable)
  
  write(user ";\n")
  return

func parse-array()
  new St-array st-array
  read-new(user " "): owner st-array.typename, copy glob.end
  owner String target
  st-array.is-set := read-new(user " ["): owner target, copy glob.end = '['
  if st-array.is-set
    st-array.array := target
    read-new(user "]"): owner st-array.index, copy glob.end
    # ignore ":= "
    read-ignore(copy 3)
    read-new(user ""): owner st-array.variable, copy glob.end
  
  else
    st-array.variable := target
    # ignore ":= "
    read-ignore(copy 3)
    read-new(user "["): owner st-array.array, copy glob.end
    read-new(user "]"): owner st-array.index, copy glob.end
    readc(): copy glob.end
  
  add-node(copy write-array, owner st-array)
  return

# call
func write-call(user St-func st-func)
  write-func-call(user st-func)
  write(user ";\n")
  return

func parse-call(user String name)
  owner St-func st-func
  parse-func-header(user name): owner st-func, copy glob.end
  add-node(copy write-call, owner st-func)
  return

# assign
class St-assign
  owner String name
  owner St-exp value

func write-assign(user St-assign st-assign)
  write-exp-call(user st-assign.value)
  write-cstyle(user st-assign.name)
  write(user " = ")
  write-exp(user st-assign.value)
  write(user ";\n")
  return

func parse-assign-exp(owner String name, copy Func writer)
  new St-assign st-assign
  st-assign.name := name
  # ignore ":= "
  read-ignore(copy 3)
  parse-exp(): owner st-assign.value
  add-node(copy writer, owner st-assign)
  start-block()
  return

func parse-assign(user String name)
  owner String new-name
  new-copy(user name): owner new-name
  parse-assign-exp(owner new-name, copy write-assign)
  return


# out
func write-out(user St-assign st-assign)
  write(user "*")
  write-assign(user st-assign)
  return

func parse-out()
  owner String name
  read-new(user " "): owner name, copy glob.end
  parse-assign-exp(owner name, copy write-out)
  return

# lines
func parse-line(): copy Bool more-lines
  var String{80} key-word
  var Int spaces
  read-indent(user " (", copy true): var key-word, copy glob.end, copy spaces
  if glob.end = EOF
    out more-lines := false
    return
  
  out more-lines := true
  do
    while spaces < glob.spaces
    end-block()
  
  if string-equal(user key-word, user ""): copy glob.flag
    add-node(copy write-empty, owner NULL)
    return
  
  var Func parser
  if kv-find(user glob.key-word-map, user key-word): copy parser, copy glob.flag
    parser()
  
  else-if glob.end = '('
    parse-call(user key-word)
  
  else
    parse-assign(user key-word)
  
  return

func parse-lines()
  var Bool flag
  do
    while parse-line(): copy flag
  
  return

# global init
func create-key-word-map()
  new Array{20:Key-value} key-word-map
  kv-add(user key-word-map, copy 0, user "#", copy parse-comment)
  kv-add(user key-word-map, copy 1, user "func", copy parse-func)
  kv-add(user key-word-map, copy 2, user "native", copy parse-native)
  kv-add(user key-word-map, copy 3, user "main", copy parse-main)
  kv-add(user key-word-map, copy 4, user "var", copy parse-var)
  kv-add(user key-word-map, copy 5, user "owner", copy parse-ref)
  kv-add(user key-word-map, copy 6, user "user", copy parse-ref)
  kv-add(user key-word-map, copy 7, user "new", copy parse-new)
  kv-add(user key-word-map, copy 8, user "delete", copy parse-delete)
  kv-add(user key-word-map, copy 9, user "if", copy parse-if)
  kv-add(user key-word-map, copy 10, user "else", copy parse-else)
  kv-add(user key-word-map, copy 11, user "else-if", copy parse-else-if)
  kv-add(user key-word-map, copy 12, user "do", copy parse-do)
  kv-add(user key-word-map, copy 13, user "while", copy parse-while)
  kv-add(user key-word-map, copy 14, user "for", copy parse-for)
  kv-add(user key-word-map, copy 15, user "return", copy parse-return)
  kv-add(user key-word-map, copy 16, user "raise", copy parse-raise)
  kv-add(user key-word-map, copy 17, user "out", copy parse-out)
  kv-add(user key-word-map, copy 18, user "class", copy parse-class)
  kv-add(user key-word-map, copy 19, user "[]", copy parse-array)
  glob.key-word-map := key-word-map
  return


func init-glob-state(user St root)
  glob.curr := root
  glob.spaces := 0
  return

# main
main func(user Array{String} argv)
  print(user "MR compiler start")
  
  array-length(user argv): copy glob.length
  if glob.length != 3
    print(user "usage: mr2-compiler [input MR file] [output C file]")
    return
  
  # open files
  user String infile-name
  [] String infile-name := argv[1]
  user String outfile-name
  [] String outfile-name := argv[2]
  file-open-read(user infile-name): owner glob.infile
  file-open-write(user outfile-name): owner glob.outfile
  
  # init global data
  owner St root
  St-new(copy write-sons, user NULL, user NULL): owner root
  create-key-word-map()
  
  # parse
  print(user "parsing...")
  init-glob-state(user root)
  parse-lines()
  
  # write
  print(user "writing...")
  init-glob-state(user root)
  write(user "#include \"mr.1.h\"\n\n")
  root.writer()
  
  # close files
  file-close(owner glob.infile)
  file-close(owner glob.outfile)
  
  print(user "MR compiler end")
  return

