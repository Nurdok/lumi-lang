# MR2 compiler - written in MR1

native func print(user String text)

native type File
native func file-open-read(user String name): owner File file
native func file-open-write(user String name): owner File file
native func file-close(owner File this)
native func file-getc(user File this): copy Char ch
native func file-putc(user File this, copy Char ch)
native func file-write(user File this, user String line)

native func string-clear(user String this)
native func string-length(user String this): copy Int length
native func string-equal(user String this, user String other): copy Bool equal
native func string-get(user String this, copy Int index): copy Char ch
native func string-append(user String this, copy Char ch)
native func string-copy(user String this, user String source)
native func string-concat(user String this, user String ext)
native func string-find(user String this, user String pattern): copy Int index
native func string-replace(user String this, copy Char old-ch, copy Char new-ch)
native func string-has(user String this, copy Char ch): copy Bool found
native func int-to-string(copy Int value): var String str

native func array-length(user Array{} arr): copy Int length

native func sys-exit(copy Int status)
native func sys-system(user String command): copy Int status
native func sys-getenv(user String name): copy Bool exists, var String value


native type Generic


func new-copy(user String text): owner String out-text
  if text = NULL
    raise
  
  new String{text.actual-length + 1} new-text
  string-copy(user new-text, user text)
  out out-text := new-text
  return


# Function Map
class Func-map
  owner String key
  var Func value

func fm-add(user Array{Func-map} map, copy Int index, user String key, copy Func value)
  var Func-map fm
  [] Func-map fm := map[index]
  new-copy(user key): owner fm.key
  fm.value := value
  return

func fm-find(user Array{Func-map} map, user String key): copy Func value, copy Bool found
  for n in map.length
    var Func-map fm
    [] Func-map fm := map[n]
    var Bool flag
    if string-equal(user key, user fm.key): copy flag
      out found := true
      out value := fm.value
      return
    
  
  out found := false
  return

# Name Map
class Name-map
  owner Name-map next
  user String name
  owner Generic value

class Type-attrs
  owner String name
  owner Name-map members

class Var-attrs
  owner String name
  user Type-attrs type-attrs
  user Type-attrs subtype
  owner String access
  var Bool is-ref

func nm-init(user String name, owner Generic value): owner Name-map nm-ptr
  new Name-map nm
  nm.next := nm-ptr[0]
  nm.name := name
  nm.value := value
  out nm-ptr := nm
  return

func nm-find(user Name-map self, user String name): user Generic value
  user Name-map nm(self)
  do
    while nm != NULL
    var Bool equal
    if string-equal(user nm.name, user name): copy equal
      out value := nm.value
      return
    
    nm := nm.next
  
  out value := NULL
  return

func add-member(user String name, user Type-attrs type-attrs, user Type-attrs subtype): owner Name-map members
  new Var-attrs new-var
  new-copy(user name): owner new-var.name
  new-var.type-attrs := type-attrs
  new-var.subtype := subtype
  new-var.is-ref := false
  nm-init(user new-var.name, owner new-var): var members
  return

# Syntax Tree
class St
  owner St next-brother
  owner St first-son
  user St last-son
  user St father
  var Func writer
  owner Generic value
  owner Name-map var-map
  var Bool in-class

func st-new(copy Func writer, owner Generic value, user St father, copy Bool in-class): owner St res
  new St self
  self.next-brother := NULL
  self.first-son := NULL
  self.last-son := NULL
  self.father := father
  self.writer := writer
  self.value := value
  self.in-class := in-class
  out res := self
  if father != NULL
    if father.first-son = NULL
      father.first-son := self
    
    else
      father.last-son.next-brother := self
    
    father.last-son := self
    self.var-map := father.var-map
  
  else
    self.var-map := NULL
  
  return

func st-del(owner St self)
  if self = NULL
    return
  
  st-del(owner self.first-son)
  st-del(owner self.next-brother)
  delete self
  return

# Global data
class Global-data
  # data
  owner File infile
  owner File outfile
  user Array{Func-map} key-word-map
  owner Name-map type-map
  owner Name-map var-map
  # state
  user St curr
  var Int spaces
  user Type-attrs class-attrs
  # vars
  var Int length
  var Bool flag
  var Char end

var Global-data glob

func add-type(user String name, owner Name-map members)
  new Type-attrs new-type
  new-copy(user name): owner new-type.name
  new-type.members := members
  new Name-map nm
  nm-init(user new-type.name, user new-type): owner glob.type-map
  return

func find-type(user String name): user Type-attrs type-attr
  user Generic value
  nm-find(user glob.type-map, user name): user value
  if value = NULL
    var String{256} msg
    string-copy(user msg, user "Undefined type ")
    string-concat(user msg, user name)
    print(user msg)
    raise
  
  out type-attr := value
  return

func find-var(user Name-map nm, user String name): user Var-attrs var-attr
  user Generic value
  nm-find(user nm, user name): user value
  if value = NULL
    var String{256} msg
    string-copy(user msg, user "Undefined variable ")
    string-concat(user msg, user name)
    print(user msg)
    raise
  
  out var-attr := value
  return

# read helpers
func readc(): copy Char ch
  file-getc(user glob.infile): var ch
  return

func read-ignore(copy Int chars)
  for n in chars
    readc(): copy glob.end
  
  return

func read-indent(user String ends, copy Bool indent): var String text, copy Char end, copy Int out-spaces
  string-clear(user text)
  var Char ch(EOF)
  var Char q('\0')
  var Int spaces(0)
  do
    # ignore indent
    readc(): copy ch
    if indent
      do
        while ch = ' '
        spaces := spaces + 1
        readc(): copy ch
      
      indent := false
    
    while ch != EOF
    if q != '\0'
      if ch = '\\'
        string-append(user text, copy ch)
        readc(): copy ch
      
      else-if ch = q
        q := '\0'
      
    
    else
      while ch != '\n'
      while string-has(user ends, copy ch): copy glob.flag = false
      if ch = '\'' or ch = '"'
        q := ch
      
    
    string-append(user text, copy ch)
  
  out end := ch
  out out-spaces := spaces
  return

func read(user String ends): var String text, copy Char end
  var Int spaces(0)
  read-indent(user ends, copy false): var text, var end, copy spaces
  return

func read-new(user String ends): owner String out-text, copy Char end
  var String{256} text
  read(user ends): var text, var end
  new-copy(user text): var out-text
  return

# write helpers
func writec(copy Char ch)
  file-putc(user glob.outfile, copy ch)
  return

func write(user String text)
  file-write(user glob.outfile, user text)
  return

func write-csyle-char(copy Char ch, copy Char prev)
  if ch = '-' and prev != ' '
    writec(copy '_')
  
  else-if ch = '.'
    write(user "->")
  
  else-if ch = '=' and prev = ' '
    write(user "==")
  
  else-if ch != ':'
    writec(copy ch)
  
  return

func write-cstyle(user String text)
  if text = NULL
    raise
  
  var Char prev(' ')
  for index in text.actual-length
    var Char ch
    string-get(user text, copy index): copy ch
    write-csyle-char(copy ch, copy prev)
    prev := ch
  
  return

# other helpers
func add-node(copy Func writer, owner Generic value)
  user St node
  st-new(copy writer, user value, user glob.curr, copy false): user node
  return

func string-split(user String text, copy Char sep): copy Int index, copy Int length
  if string-has(user text, copy sep): copy glob.flag
    var String{2} sep-str
    string-append(user sep-str, copy sep)
    var Int sep-index
    string-find(user text, user sep-str): copy sep-index
    out index := sep-index
    out length := text.actual-length - sep-index - 1
  
  else
    out index := text.actual-length
    out length := 0
  
  return

func is-primitive(user String typename): copy Bool res
  var Bool flag
  if string-equal(user typename, user "Int"): copy flag
    out res := true
    return
  
  if string-equal(user typename, user "Char"): copy flag
    out res := true
    return
  
  if string-equal(user typename, user "Func"): copy flag
    out res := true
    return
  
  string-equal(user typename, user "Bool"): copy flag
  out res := flag
  return

# block helpers
func write-spaces()
  for n in glob.spaces
    write(user " ")
  
  return

func write-new-indent-line()
  write(user "\n")
  write-spaces()
  return

func write-sons()
  user St son(glob.curr.first-son)
  do
    while son != NULL
    glob.curr := son
    write-spaces()
    son.writer(user son.value)
    son := son.next-brother
  
  return

func start-block()
  glob.spaces := glob.spaces + 2
  glob.curr := glob.curr.last-son
  return

func end-block()
  glob.curr := glob.curr.father
  glob.spaces := glob.spaces - 2
  if glob.spaces = 0
    glob.class-attrs := NULL
  
  return

func write-block-suffix(user String suffix)
  write(user " {\n")
  glob.spaces := glob.spaces + 2
  write-sons()
  glob.spaces := glob.spaces - 2
  write-spaces()
  write(user "}")
  write(user suffix)
  return

func write-block()
  write-block-suffix(user "\n")
  return

# empty
func write-empty(user Generic null)
  write(user "\n")
  return

func add-empty()
  add-node(copy write-empty, owner NULL)
  return

# comment
func write-comment(user String comment-text)
  write(user "/* ")
  write(user comment-text)
  write(user " */\n")
  return

func parse-comment()
  user String comment
  read-new(user ""): user comment, copy glob.end
  add-node(copy write-comment, owner comment)
  return

# member path
class Member-path
  owner Member-path next
  owner String name

func read-mpath(user String ends): owner Member-path mem-path, copy Char end
  new Member-path new-mem-path
  user Member-path mpath(new-mem-path)
  do
    mpath.next := NULL
    while read-new(user ends): owner mpath.name, copy glob.end = '.'
    new Member-path new-mpath
    mpath.next := new-mpath
    mpath := new-mpath
  
  out mem-path := new-mem-path
  out end := glob.end
  return

func write-mpath(user Member-path mem-path, copy Bool write-last)
  user Member-path mpath(mem-path)
  user Generic value
  nm-find(user glob.curr.var-map, user mpath.name): user value
  user Var-attrs var-attrs(value)
  var Bool is-ref := var-attrs != NULL and var-attrs.is-ref
  if is-ref
    write(user "(*")
  
  write-cstyle(user mpath.name)
  if is-ref
    write(user ")")
  
  do
    mpath := mpath.next
    while mpath != NULL and (write-last or mpath.next != NULL)
    write(user "->")
    write-cstyle(user mpath.name)
  
  return

# expression and function
class St-arg
  owner St-arg next
  owner Generic value
  owner String typename
  owner String type-param
  owner String access

class St-func
  owner Member-path path
  owner St-arg params
  owner St-arg outputs

class St-exp
  owner St-exp next
  owner String operator
  owner Member-path item
  owner St-func call
  owner St-exp subexp

func real-string-length(user String text): copy Int length
  var Int index(1)
  var Int real-length(1)
  var Int text-length(text.actual-length - 1)
  do
    while index < text-length
    if string-get(user text, copy index): copy glob.end = '\\'
      index := index + 1
    
    real-length := real-length + 1
    index := index + 1
  
  out length := real-length
  return

func write-exp(user St-exp st-exp)
  if st-exp = NULL
    raise
  
  if st-exp.call != NULL
    user St-arg last(st-exp.call.outputs)
    if last = NULL
      raise
    
    do
      while last.next != NULL
      last := last.next
    
    write-mpath(user last.value, copy true)
  
  else-if st-exp.item = NULL
    if st-exp.subexp != NULL
      write(user "(")
      write-exp(user st-exp.subexp)
      write(user ")")
    
  
  else-if st-exp.subexp != NULL
    user Var-attrs var-attrs
    find-var(user glob.curr.var-map, user st-exp.item.name): user var-attrs
    user Member-path mpath(st-exp.item)
    do
      while mpath.next != NULL
      mpath := mpath.next
      find-var(user var-attrs.type-attrs.members, user mpath.name): user var-attrs
    
    if var-attrs.subtype = NULL
      print(user mpath.name)
      raise
    
    write(user "((")
    write-cstyle(user var-attrs.subtype.name)
    write(user "*)(")
    write-mpath(user st-exp.item, copy true)
    write(user "->values))")
    if is-primitive(user var-attrs.subtype.name): copt glob.flag
      write(user "[")
      write-exp(user st-exp.subexp)
      write(user "]")
    
    else
      write(user " + ")
      write-exp(user st-exp.subexp)
    
  
  else
    var Char first
    if string-get(user st-exp.item.name, user 0): copy first = '"'
      real-string-length(user st-exp.item.name): copy glob.length
      var String{80} length-str
      write(user "&(String){")
      int-to-string(copy glob.length): var length-str
      write(user length-str)
      write(user ", ")
      glob.length := glob.length - 1
      int-to-string(copy glob.length): var length-str
      write(user length-str)
      write(user ", ")
      write(user st-exp.item.name)
      write(user "}")
    
    else-if first = '\'' or first = '-' or first >= '0' and first <= '9'
      write(user st-exp.item.name)
    
    else
      write-mpath(user st-exp.item, copy true)
    
  
  if st-exp.operator != NULL
    write(user " ")
    write-cstyle(user st-exp.operator)
  
  if st-exp.next != NULL
    write(user " ")
    write-exp(user st-exp.next)
  
  return

native func write-func-call(user St-func st-func)

func write-exp-intro(user St-exp st-exp)
  if st-exp = NULL
    return
  
  write-exp-intro(user st-exp.next)
  write-exp-intro(user st-exp.subexp)
  if st-exp.call != NULL
    write-func-call(user st-exp.call)
    write-new-indent-line()
  
  else-if st-exp.subexp != NULL and st-exp.item != NULL
    write(user "if (")
    write-exp(user st-exp.subexp)
    write(user " < 0 || ")
    write-exp(user st-exp.subexp)
    write(user " >= ")
    write-mpath(user st-exp.item, copy true)
    write(user "->length) RAISE")
    write-new-indent-line()
  
  return

native func parse-func-header(owner Member-path path): owner St-func st-func, copy Char end

func parse-exp(user String exp-ends): owner St-exp new-st-exp, copy Char out-end
  new St-exp st-exp
  st-exp.next := NULL
  st-exp.operator := NULL
  st-exp.call := NULL
  st-exp.subexp := NULL
  var String{16} ends
  string-copy(user ends, user " .([")
  string-concat(user ends, user exp-ends)
  var Char end
  if read-mpath(user ends): owner st-exp.item, copy end = '('
    if st-exp.item.name.actual-length > 0
      parse-func-header(owner st-exp.item): owner st-exp.call, copy end
    
    else
      parse-exp(user ")"): owner st-exp.subexp, copy end
      readc(): copy end
      delete st-exp.item
    
    st-exp.item := NULL
  
  else-if end  = '['
    parse-exp(user "]"): owner st-exp.subexp, copy end
    readc(): copy end
  
  if end = ' '
    read-new(user " "): owner st-exp.operator, copy end
    parse-exp(user exp-ends): owner st-exp.next, copy end
  
  out new-st-exp := st-exp
  out out-end := end
  return

# function
func write-func-call(user St-func st-func)
  user St-arg arg(st-func.params)
  do
    while arg != NULL
    write-exp-intro(user arg.value)
    arg := arg.next
  
  write(user "CHECK(")
  if st-func.path.next != NULL:
    user Var-attrs var-attrs
    find-var(user glob.curr.var-map, user st-func.path.name): user var-attrs
    user Member-path mpath(st-func.path.next)
    do
      while mpath.next != NULL
      find-var(user var-attrs.type-attrs.members, user mpath.name): user var-attrs
      mpath := mpath.next
    
    write-cstyle(user var-attrs.type-attrs.name)
    write(user "_")
    write-cstyle(user mpath.name)
    write(user "(")
    write-mpath(user st-func.path, copy false)
    if st-func.params != NULL or st-func.outputs != NULL
      write(user ", ")
    
  
  else
    write-mpath(user st-func.path, copy true)
    write(user "(")
  
  arg := st-func.params
  do
    while arg != NULL
    write-exp(user arg.value)
    arg := arg.next
    if arg != NULL or st-func.outputs != NULL
      write(user ", ")
    
  
  arg := st-func.outputs
  do
    while arg != NULL
    if string-equal(user arg.access, user "var"): copy glob.flag = false
      write(copy "&")
    
    write-mpath(user arg.value, copy true)
    arg := arg.next
    if arg != NULL
      write(user ", ")
    
  
  write(user "))")
  return

func write-args(user St-arg first, copy Bool is-out, user St-arg next)
  user St-arg arg(first)
  do
    while arg != NULL
    write-cstyle(user arg.typename)
    if string-equal(user arg.access, user "copy"): copy glob.flag = false
      write(user "*")
    
    if string-equal(user arg.access, user "var"): copy glob.flag = false and is-out
      write(user "*")
    
    write(user " ")
    write-cstyle(user arg.value)
    arg := arg.next
    if arg != NULL or next != NULL
      write(user ", ")
    
  
  return

func write-func-header(user St-func st-func)
  write(user "Returncode ")
  if glob.class-attrs != NULL
    write-cstyle(user glob.class-attrs.name)
    write(user "_")
  
  write-cstyle(user st-func.path.name)
  write(user "(")
  if glob.class-attrs != NULL
    write-cstyle(user glob.class-attrs.name)
    write(user "* self")
    if st-func.params != NULL or st-func.outputs != NULL
      write(user ", ")
    
  
  write-args(user st-func.params, copy false, user st-func.outputs)
  write-args(user st-func.outputs, copy true, user NULL)
  write(user ")")
  return

func parse-func-header(owner Member-path path): owner St-func st-func, copy Char end
  new St-func new-func
  if path = NULL
    new Member-path mpath
    mpath.next := NULL
    read-new(user "("): user mpath.name, copy glob.end
    new Var-attrs new-var
    new-copy(user mpath.name): owner new-var.name
    new-func.path := mpath
    find-type(user "Func"): user new-var.type-attrs
    new-var.subtype := NULL
    new-var.is-ref := false
    nm-init(user new-var.name, owner new-var): owner glob.curr.var-map
  
  else
    new-func.path := path
  
  new-func.params := NULL
  new-func.outputs := NULL
  user St-arg last(NULL)
  do
    var String{256} access
    while read(user " )"): var access, copy glob.end = ' '
    new St-arg param
    param.next := NULL
    param.typename := NULL
    param.type-param := NULL
    new-copy(user access): owner param.access
    if path = NULL
      if read-new(user " {"): owner param.typename, copy glob.end = '{'
        read-new(user "}"): owner param.type-param, copy glob.end
        readc(): copy glob.end
      
    
    if path = NULL
      owner String name
      read-new(user ",)"): owner name, copy glob.end
      param.value := name
    
    else
      owner St-exp value 
      parse-exp(user ",)"): owner value, copy glob.end
      param.value := value
    
    if last = NULL
      new-func.params := param
    
    else
      last.next := param
    
    last := param
    while glob.end = ','
    readc(): copy glob.end
  
  readc(): copy glob.end
  last := NULL
  do
    while glob.end != '\n'
    readc(): copy glob.end
    new St-arg param
    param.next := NULL
    read-new(user " "): owner param.access, copy glob.end
    if path = NULL
      read-new(user " "): owner param.typename, copy glob.end
    
    else
      param.typename := NULL
    
    if path = NULL
      owner String name
      read-new(user ", "): owner name, copy glob.end
      param.value := name
    
    else
      owner Member-path mpath
      read-mpath(user "., "): owner mpath, copy glob.end
      param.value := mpath
    
    if last = NULL
      new-func.outputs := param
    
    else
      last.next := param
    
    last := param
    while glob.end = ','
  
  out st-func := new-func
  out end := glob.end
  return

# func
func write-func(user St-func st-func)
  write-func-header(user st-func)
  write-block()
  return

func add-arg-vars(user St-arg first, copy Bool is-ref)
  user St-arg arg(first)
  do
    while arg != NULL
    new Var-attrs new-var
    new-copy(user arg.value): owner new-var.name
    find-type(user arg.typename): user new-var.type-attrs
    new-var.subtype := NULL
    if arg.type-param != NULL
      find-type(user arg.type-param): user new-var.subtype
    
    new-var.is-ref := string-equal(user arg.access, user "var"): copy glob.flag = false and is-ref
    nm-init(user new-var.name, owner new-var): owner glob.curr.var-map
    arg := arg.next
  
  return

func parse-func-body(copy Func writer)
  owner St-func st-func
  parse-func-header(user NULL): owner st-func, copy glob.end
  add-node(copy writer, owner st-func)
  start-block()
  # add vars to var-map
  if glob.class-attrs != NULL
    new Var-attrs new-var
    new-copy(user "self"): owner new-var.name
    new-var.type-attrs := glob.class-attrs
    new-var.subtype := NULL
    new-var.is-ref := false
    nm-init(user new-var.name, owner new-var): owner glob.curr.var-map
  
  add-arg-vars(user st-func.params, copy false)
  add-arg-vars(user st-func.outputs, copy true)
  return

func parse-func()
  parse-func-body(copy write-func)
  return

# native
func write-native-type(user String name)
  write(user "typedef void ")
  write-cstyle(user name)
  write(user ";\n")
  return

func write-native-func(user St-func st-func)
  write-func-header(user st-func)
  write(user ";\n")
  return

func parse-native()
  var String{80} kind
  read(user " "): var kind, copy glob.end
  if string-equal(user kind, user "func"): copy glob.flag
    owner St-func st-func
    parse-func-header(user NULL): owner st-func, copy glob.end
    add-node(copy write-native-func, owner st-func)
  
  else
    owner String name
    read-new(user ""): owner name, copy glob.end
    add-type(user name, user NULL)
    add-node(copy write-native-type, owner name)
  
  return

# main
func write-main(user St-func st-func)
  write-func(user st-func)
  write(user "\nMAIN_FUNC\n")
  return

func parse-main()
  parse-func-body(copy write-main)
  return

# declerations
class St-dec
  owner String name
  owner String typename
  owner String array-length
  owner String string-length
  owner String init
  owner String slice-start
  owner String slice-length

func parse-dec(): owner St-dec new-st-dec
  new St-dec st-dec
  st-dec.array-length := NULL
  st-dec.string-length := NULL
  st-dec.init := NULL
  st-dec.slice-start := NULL
  st-dec.slice-length := NULL
  
  read-new(user " {"): owner st-dec.typename, copy glob.end
  var Bool is-array(false)
  var Bool is-array-var(false)
  if glob.end = '{'
    if string-equal(user st-dec.typename, user "Array"): copy is-array
      if read-new(user "}:"): owner st-dec.array-length, copy glob.end = ':'
        is-array-var := true
        read-new(user "}{"): owner st-dec.typename, copy glob.end
      
    
    if string-equal(user st-dec.typename, user "String"): copy glob.flag
      read-new(user "}"): owner st-dec.string-length, copy glob.end
      readc(): copy glob.end
    
    if is-array
      readc(): copy glob.end
    
  
  if read-new(user "("): owner st-dec.name, copy glob.end = '('
    if read-new(user ")["): owner st-dec.init, copy glob.end = '['
      read-new(user ":"): owner st-dec.slice-start, copy glob.end
      read-new(user "]"): owner st-dec.slice-length, copy glob.end
      readc(): copy glob.end
    
    readc(): copy glob.end
  
  new Var-attrs new-var
  new-copy(user st-dec.name): owner new-var.name
  user Type-attrs type-attr
  find-type(user st-dec.typename): user type-attr
  new-var.subtype := NULL
  if is-array-var
    new-var.subtype := type-attr
    find-type(user "Array"): user type-attr
  
  else-if is-array
    find-type(user st-dec.array-length): user new-var.subtype
  
  new-var.type-attrs := type-attr
  new-var.is-ref := false
  
  if glob.class-attrs != NULL
    nm-init(user new-var.name, owner new-var): owner glob.class-attrs.members
  
  else
    nm-init(user new-var.name, owner new-var): owner glob.curr.var-map
  
  out new-st-dec := st-dec
  return

# var
func write-var-primitive(user St-dec st-dec)
  write-cstyle(user st-dec.typename)
  write(user " ")
  write-cstyle(user st-dec.name)
  if st-dec.init != NULL
    write(user " = ")
    write-cstyle(user st-dec.init)
  
  write(user ";\n")
  return

func write-ref-prefix(user String typename, user String name)
  write-cstyle(user typename)
  write(user "* ")
  write-cstyle(user name)
  write(user " = &(")
  write-cstyle(user typename)
  write(user "){")
  return

func write-var-class(user St-dec st-dec)
  write-ref-prefix(user st-dec.typename, user st-dec.name)
  write(user "0};\n")
  return

func write-var-string(user St-dec st-dec)
  write-ref-prefix(user "String", user st-dec.name)
  write(user st-dec.string-length)
  write(user ", 0, (char[")
  write(user st-dec.string-length)
  write(user "]){0}};\n")
  return

func write-var-array(user St-dec st-dec)
  write-ref-prefix(user "Array", user st-dec.name)
  write(user st-dec.array-length)
  write(user ", (")
  write-cstyle(user st-dec.typename)
  write(user "[")
  write(user st-dec.array-length)
  write(user "]){0}};")
  
  if st-dec.string-length != NULL
    write-new-indent-line()
    write(user "char _")
    write-cstyle(user st-dec.name)
    write(user "_chars[")
    write(user st-dec.string-length)
    write(user "][")
    write(user st-dec.array-length)
    write(user "];")
    write-new-indent-line()
    write(user "{int n; for(n=0; n<")
    write(user st-dec.array-length)
    write(user "; ++n)")
    write-new-indent-line()
    write(user " ((String*)(")
    write-cstyle(user st-dec.name)
    write(user "->values))[n] = (String){")
    write(user st-dec.string-length)
    write(user ", 0, _")
    write-cstyle(user st-dec.name)
    write(user "_chars[n]};}")
  
  write(user "\n")
  return

func add-dec-node(copy Func writer, owner Generic value)
  user St node
  st-new(copy writer, user value, user glob.curr, copy glob.class-attrs != NULL): user node
  return

func parse-var()
  owner St-dec st-dec
  parse-dec(): owner st-dec
  
  if st-dec.array-length != NULL
    add-dec-node(copy write-var-array, owner st-dec)
    return
  
  if st-dec.string-length != NULL
    add-dec-node(copy write-var-string, owner st-dec)
    return
  
  if is-primitive(user st-dec.typename): copy glob.flag
    add-dec-node(copy write-var-primitive, owner st-dec)
    return
  
  add-dec-node(copy write-var-class, owner st-dec)
  return

# ref
func write-ref(user St-dec st-dec)
  if st-dec.slice-start != NULL
    write(user "if ((")
    write-cstyle(user st-dec.slice-start)
    write(user ") + (")
    write-cstyle(user st-dec.slice-length)
    write(user ") > ")
    write-cstyle(user st-dec.init)
    write(user "->")
    if st-dec.array-length = NULL
      write(user "actual_")
    
    write(user "length) RAISE")
    write-new-indent-line()
  
  write-cstyle(user st-dec.typename)
  write(user "* ")
  write-cstyle(user st-dec.name)
  
  if st-dec.init != NULL
    write(user " = ")
    if st-dec.slice-start = NULL
      write-cstyle(user st-dec.init)
    
    else-if st-dec.array-length != NULL
      write(user "&(Array){")
      write-cstyle(user st-dec.slice-length)
      write(user ", (Byte*)(")
      write-cstyle(user st-dec.init)
      write(user "->values) + (")
      write-cstyle(user st-dec.slice-start)
      write(user ") * sizeof(")
      write-cstyle(user st-dec.array-length)
      write(user ")}")
    
    else
      write(user "&(String){")
      write-cstyle(user st-dec.slice-length)
      write(user ", ")
      write-cstyle(user st-dec.slice-length)
      write(user ", ")
      write-cstyle(user st-dec.init)
      write(user "->chars + ")
      write-cstyle(user st-dec.slice-start)
      write(copy "}")
    
  
  write(user ";\n")
  return

func parse-ref()
  owner St-dec st-dec
  parse-dec(): owner st-dec
  add-dec-node(copy write-ref, owner st-dec)
  return

# new
func write-new(user St-dec st-dec)
  if st-dec.array-length != NULL
    write(user "Array")
  
  else
    write-cstyle(user st-dec.typename)
  
  write(user "* ")
  write-cstyle(user st-dec.name)
  write(user " = ")
  
  if st-dec.array-length != NULL
    write(user "new_array(")
    write-cstyle(user st-dec.array-length)
    write(user ", sizeof(")
    write-cstyle(user st-dec.typename)
    write(copy ")")
    if st-dec.string-length != NULL
      write(user " + (")
      write-cstyle(user st-dec.string-length)
      writec(copy ')')
    
  
  else-if st-dec.string-length != NULL
    write(user "new_string(")
    write-cstyle(user st-dec.string-length)
  
  else
    write(user "malloc(sizeof(")
    write-cstyle(user st-dec.typename)
    writec(copy ')')
    
  
  write(user ");")
  write-new-indent-line()
  write(user "if (")
  write-cstyle(user st-dec.name)
  write(user " == NULL) RAISE")
  
  if st-dec.array-length != NULL and st-dec.string-length != NULL
    write-new-indent-line()
    write(user "{int n; for(n=0; n<(")
    write-cstyle(user st-dec.array-length)
    write(user "); ++n)")
    write-new-indent-line()
    write(user " ((String*)(")
    write-cstyle(user st-dec.name)
    write(user "->values))[n] = (String){")
    write-cstyle(user st-dec.string-length)
    write(user ", 0, (Byte*)(")
    write-cstyle(user st-dec.name)
    write(user "->values) + (")
    write-cstyle(user st-dec.array-length)
    write(user ") * sizeof(String) + (")
    write-cstyle(user st-dec.string-length)
    write(user ") * n};}")
  
  write(copy "\n")
  return

func parse-new()
  owner St-dec st-dec
  parse-dec(): owner st-dec
  add-node(copy write-new, owner st-dec)
  return

# delete
func write-delete(user String name)
  write(user "free(")
  write-cstyle(user name)
  write(user ");\n")
  return

func parse-delete()
  owner String name
  read-new(user ""): owner name, copy glob.end
  add-node(copy write-delete, owner name)
  return

# if
func write-if(user St-exp st-exp)
  write-exp-intro(user st-exp)
  write(user "if (")
  write-exp(user st-exp)
  write(user ")")
  write-block()
  return

func parse-if()
  owner St-exp st-exp
  parse-exp(user ""): owner st-exp, copy glob.end
  add-node(copy write-if, owner st-exp)
  start-block()
  return

# else
func write-else(user Generic null)
  write(user "else")
  write-block()
  return

func parse-else()
  add-node(copy write-else, user NULL)
  start-block()
  return

# else-if
func write-else-if(user St-exp st-exp)
  write-exp-intro(user st-exp)
  write(user "else if (")
  write-exp(user st-exp)
  write(user ")")
  write-block()
  return

func parse-else-if()
  owner St-exp st-exp
  parse-exp(user ""): owner st-exp, copy glob.end
  add-node(copy write-else-if, owner st-exp)
  start-block()
  return

# do
func write-do(user Generic null)
  write(user "while (true)")
  write-block()
  return

func parse-do()
  add-node(copy write-do, user NULL)
  start-block()
  return

# while
func write-while(user St-exp st-exp)
  write-exp-intro(user st-exp)
  write(user "if (not(")
  write-exp(user st-exp)
  write(user ")) break;\n")
  return

func parse-while()
  owner St-exp st-exp
  parse-exp(user ""): owner st-exp, copy glob.end
  add-node(copy write-while, owner st-exp)
  return

# for
class St-for
  owner String counter
  owner St-exp limit

func write-for(user St-for st-for)
  write-exp-intro(user st-for.limit)
  write(user "Int ")
  write-cstyle(user st-for.counter)
  write(user "; for (")
  write-cstyle(user st-for.counter)
  write(user " = 0; ")
  write-cstyle(user st-for.counter)
  write(user " < ")
  write-exp(user st-for.limit)
  write(user "; ++")
  write-cstyle(user st-for.counter)
  write(user ")")
  write-block()
  return

func parse-for()
  new St-for st-for
  read-new(user " "): owner st-for.counter, copy glob.end
  # ignore "in "
  read-ignore(copy 3)
  parse-exp(user ""): owner st-for.limit, copy glob.end
  add-node(copy write-for, owner st-for)
  start-block()
  return

# return
func write-return(user Generic null)
  write(user "return OK;\n")
  return

func parse-return()
  add-node(user write-return, user NULL)
  return

# raise
func write-raise(user Generic null)
  write(user "RAISE\n")
  return

func parse-raise()
  add-node(user write-raise, user NULL)
  return

# class
func write-class-members(user St self-node, copy Bool in-class)
  user St son(self-node.first-son)
  do
    while son != NULL
    glob.curr := son
    if son.in-class = in-class
      write-spaces()
      son.writer(user son.value)
    
    son := son.next-brother
  
  return

func write-class(user Type-attrs class-attrs)
  write(user "typedef struct ")
  write-cstyle(user class-attrs.name)
  write(user " ")
  write-cstyle(user class-attrs.name)
  write(user "; struct ")
  write-cstyle(user class-attrs.name)
  write(user " {\n")
  # write members
  glob.spaces := glob.spaces + 2
  glob.class-attrs := class-attrs
  user St self-node(glob.curr)
  write-class-members(user self-node, copy true)
  glob.spaces := glob.spaces - 2
  write-spaces()
  write(user "};\n")
  write-class-members(user self-node, copy false)
  glob.class-attrs := NULL
  return

func parse-class()
  var String{256} name
  read(user ""): var name, copy glob.end
  add-type(user name, owner NULL)
  user Type-attrs class-attrs(glob.type-map.value)
  add-node(copy write-class, owner class-attrs)
  glob.class-attrs := class-attrs
  start-block()
  return

# call
func write-call(user St-func st-func)
  write-func-call(user st-func)
  write(user ";\n")
  return

func parse-call(owner Member-path mpath)
  owner St-func st-func
  parse-func-header(owner mpath): owner st-func, copy glob.end
  add-node(copy write-call, owner st-func)
  return

# assign
class St-assign
  owner St-exp target
  owner St-exp value

func write-assign(user St-assign st-assign)
  write-exp-intro(user st-assign.value)
  write-exp-intro(user st-assign.target)
  write-exp(user st-assign.target)
  write(user " = ")
  write-exp(user st-assign.value)
  write(user ";\n")
  return

func parse-assign(user Member-path mpath, copy Char end)
  new St-assign st-assign
  new St-exp target
  target.next := NULL
  target.operator := NULL
  target.item := mpath
  target.call := NULL
  target.subexp := NULL
  if end = '['
    parse-exp(user "]"): owner target.subexp, copy glob.end
    read-ignore(copy 1)
  
  st-assign.target := target
  # ignore ":= "
  read-ignore(copy 3)
  parse-exp(user ""): owner st-assign.value, copy glob.end
  add-node(copy write-assign, owner st-assign)
  return

# member path
func parse-member-path(user String name)
  new Member-path mem-path
  user Member-path mpath(mem-path)
  new-copy(user name): owner mpath.name
  do
    new Member-path new-mpath
    mpath.next := new-mpath
    mpath := new-mpath
    mpath.next := NULL
    while read-new(user " .(["): owner mpath.name, copy glob.end = '.'
  
  if glob.end = '('
    parse-call(owner mem-path)
  
  else
    parse-assign(owner mem-path, copy glob.end)
  
  return

# lines
func parse-line(): copy Bool more-lines
  var String{80} key-word
  var Int spaces
  var Char end
  read-indent(user " .([", copy true): var key-word, copy end, copy spaces
  if end = EOF
    out more-lines := false
    return
  
  out more-lines := true
  do
    while spaces < glob.spaces
    end-block()
  
  if string-equal(user key-word, user ""): copy glob.flag
    add-node(copy write-empty, owner NULL)
    return
  
  if end = '('
    new Member-path mpath
    new-copy(user key-word): owner mpath.name
    mpath.next := NULL
    parse-call(owner mpath)
  
  else-if end = '.'
    parse-member-path(user key-word)
  
  else
    var Bool parsed(false)
    if end != '['
      var Func parser
      if fm-find(user glob.key-word-map, user key-word): copy parser, copy parsed
        parser()
      
    
    if not parsed
      new Member-path mpath
      new-copy(user key-word): owner mpath.name
      mpath.next := NULL
      parse-assign(owner mpath, copy end)
    
  
  return

func parse-lines()
  var Bool flag
  do
    while parse-line(): copy flag
  
  return

# global init
func create-key-word-map()
  new Array{18:Func-map} key-word-map
  fm-add(user key-word-map, copy 0, user "#", copy parse-comment)
  fm-add(user key-word-map, copy 1, user "func", copy parse-func)
  fm-add(user key-word-map, copy 2, user "native", copy parse-native)
  fm-add(user key-word-map, copy 3, user "main", copy parse-main)
  fm-add(user key-word-map, copy 4, user "var", copy parse-var)
  fm-add(user key-word-map, copy 5, user "owner", copy parse-ref)
  fm-add(user key-word-map, copy 6, user "user", copy parse-ref)
  fm-add(user key-word-map, copy 7, user "new", copy parse-new)
  fm-add(user key-word-map, copy 8, user "delete", copy parse-delete)
  fm-add(user key-word-map, copy 9, user "if", copy parse-if)
  fm-add(user key-word-map, copy 10, user "else", copy parse-else)
  fm-add(user key-word-map, copy 11, user "else-if", copy parse-else-if)
  fm-add(user key-word-map, copy 12, user "do", copy parse-do)
  fm-add(user key-word-map, copy 13, user "while", copy parse-while)
  fm-add(user key-word-map, copy 14, user "for", copy parse-for)
  fm-add(user key-word-map, copy 15, user "return", copy parse-return)
  fm-add(user key-word-map, copy 16, user "raise", copy parse-raise)
  fm-add(user key-word-map, copy 17, user "class", copy parse-class)
  glob.key-word-map := key-word-map
  return

func create-name-maps()
  glob.type-map := NULL
  glob.var-map := NULL
  # Func
  add-type(user "Func", owner NULL)
  user Type-attrs func-type(glob.type-map.value)
  # Int
  owner Name-map int-members(NULL)
  add-member(user "str", user func-type, user NULL): owner int-members
  add-type(user "Int", owner int-members)
  user Type-attrs int-type(glob.type-map.value)
  # Char
  add-type(user "Char", owner NULL)
  # Bool
  add-type(user "Bool", owner NULL)
  # String
  owner Name-map string-members(NULL)
  add-member(user "actual-length", user int-type, user NULL): owner string-members
  add-member(user "max-length", user int-type, user NULL): owner string-members
  add-member(user "clear", user func-type, user NULL): owner string-members
  add-member(user "equal", user func-type, user NULL): owner string-members
  add-member(user "get", user func-type, user NULL): owner string-members
  add-member(user "append", user func-type, user NULL): owner string-members
  add-member(user "copy", user func-type, user NULL): owner string-members
  add-member(user "concat", user func-type, user NULL): owner string-members
  add-member(user "find", user func-type, user NULL): owner string-members
  add-member(user "replace", user func-type, user NULL): owner string-members
  add-member(user "has", user func-type, user NULL): owner string-members
  add-type(user "String", owner string-members)
  # Array
  owner Name-map array-members(NULL)
  add-member(user "length", user int-type, user NULL): owner array-members
  add-type(user "Array", owner array-members)
  # File
  owner Name-map file-members(NULL)
  add-member(user "close", user func-type, user NULL): owner file-members
  add-member(user "getc", user func-type, user NULL): owner file-members
  add-member(user "putc", user func-type, user NULL): owner file-members
  add-member(user "write", user func-type, user NULL): owner file-members
  add-type(user "File", owner file-members)
  # Sys
  owner Name-map sys-members(NULL)
  add-member(user "print", user func-type, user NULL): owner sys-members
  add-member(user "exit", user func-type, user NULL): owner sys-members
  add-member(user "system", user func-type, user NULL): owner sys-members
  add-member(user "getenv", user func-type, user NULL): owner sys-members
  add-type(user "Sys", owner sys-members)
  return

func init-glob-state(user St root)
  glob.curr := root
  glob.spaces := 0
  glob.class-attrs := NULL
  return

# main
main func(user Array{String} argv)
  print(user "MR compiler start")
  
  if argv.length != 3
    print(user "usage: mr2-compiler [input MR file] [output C file]")
    return
  
  # open files
  user String infile-name
  [] String infile-name := argv[1]
  user String outfile-name
  [] String outfile-name := argv[2]
  file-open-read(user infile-name): owner glob.infile
  file-open-write(user outfile-name): owner glob.outfile
  
  # init global data
  owner St root
  st-new(copy write-sons, user NULL, user NULL, copy false): owner root
  create-key-word-map()
  create-name-maps()
  
  # parse
  print(user "parsing...")
  init-glob-state(user root)
  parse-lines()
  
  # write
  print(user "writing...")
  init-glob-state(user root)
  write(user "#include \"mr.2.h\"\n\n")
  root.writer()
  
  # close files
  file-close(owner glob.infile)
  file-close(owner glob.outfile)
  
  print(user "MR compiler end")
  return

