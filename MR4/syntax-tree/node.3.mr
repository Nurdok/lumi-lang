(## MR4 compiler - Syntax tree basic node types


#)

## Access values
var Int ACCESS-COPY(0)
var Int ACCESS-USER(1)
var Int ACCESS-OWNER(2)
var Int ACCESS-VAR(3)
var Int ACCESS-NEW(4)
var Int ACCESS-AUX(5)


## Basic node type for all syntax tree nodes
class SyntaxTreeNode
  user String input-file-name
  var Int line-number
  
  func inst set-location()
    self.input-file-name := glob.input-file-name
    self.line-number := glob.line-number
  
  func inst get-access(user String access-str):(copy Int access)
    if access-str.equal(user "copy")
      access := ACCESS-COPY
    else-if access-str.equal(user "user")
      access := ACCESS-USER
    else-if access-str.equal(user "owner")
      access := ACCESS-OWNER
    else-if access-str.equal(user "var")
      access := ACCESS-VAR
    else
      self.m-syntax-error(user "illegal access", user access-str)
  
  func inst m-find-type(user String name):(user TypeData type-data)
    if not (? glob.type-map.find(user name):(user type-data))
      self.m-syntax-error(user "unknown type", user name)
  
  ## Expect `expected-text` to be read exaclty from the input file
  func inst read-expect(user String expected-text)
    new String{expected-text.length + 1} actual-text
    for n in expected-text.length
      actual-text.append(copy read-c())
    if not actual-text.equal(user expected-text)
      self.m-syntax-error2(
          user "expected", user expected-text, user "got", user actual-text)
    delete actual-text
  
  ## Read and check indentation spaces for a line break from the input file
  func inst read-line-break-spaces(u)
    for n in glob.spaces + 4
      if read-c() != ' '
        var String{128} expected-spaces
        var String{128} actual-spaces
        Int.str(var glob.spaces + 4, user expected-spaces)
        Int.str(var n - 1, user actual-spaces)
        self.m-syntax-error2(
            user "too short indentation, expected",
            user expected-spaces,
            user "got",
            user actual-spaces)
  
  func inst analyze-expression(
      user Expression expression, user TypeData expected-type)
    expression.analyze()
    if not (? expression.result-type)
      self.m-syntax-error(
          user "got void expression, expected", user expected-type.name)
    if expression.result-type.type-data != expected-type
      self.m-syntax-error2(
          user "got",
          user expression.result-type.type-data.name,
          user "expression, expected",
          user expected-type.name)
  
  func inst write-line-num()
    write-int(copy self.line-number)
  
  func inst write-raise()
    write(user "RAISE(")
    self.write-line-num()
    write(user ")")
  
  func inst write-call()
    write(user "CHECK(")
    self.write-line-num()
    write(user ", ")
  
  ## Raise a syntax error with message:
  ## `Code error in {file-name}[{line-number}] {text} "{item}"`
  func inst m-syntax-error(user String text, user String item)
    self.print-syntax-error-header()
    print-msg-with-item(user text, user item)
    print(user "\n")
    raise
  
  ## Same as `m-syntax-error` but but with another `{text} "{item}" pair
  func inst m-syntax-error2(
      user String text1, user String item1, user String text2, user String item2)
    self.print-syntax-error-header()
    print-msg-with-item(user text1, user item1)
    print(user " ")
    print-msg-with-item(user text2, user item2)
    print(user "\n")
    raise
  
  ## Same as `m-syntax-error` but but with another 2 `{text} "{item}" pair
  func inst m-syntax-error3(
      user String text1,
      user String item1,
      user String text2,
      user String item2,
      user String text3,
      user String item3)
    self.print-syntax-error-header()
    print-msg-with-item(user text1, user item1)
    print(user " ")
    print-msg-with-item(user text2, user item2)
    print(user " ")
    print-msg-with-item(user text3, user item3)
    print(user "\n")
    raise
  
  ## Same as `m-syntax-error` but with a character item
  func inst m-syntax-error-c(user String text, copy Char item)
    var String{16} char-str
    if item = EOF
      char-str.copy(user "EOF")
    else-if item = '\n'
      char-str.copy(user "new-line")
    else
      char-str.append(copy item)
    self.m-syntax-error(user text, user char-str)
  
  func inst m-syntax-error-msg(user String text)
    self.print-syntax-error-header()
    print(user text)
    print(user "\n")
    raise
  
  func inst print-syntax-error-header()
    print(user "Code error in ")
    print(user self.input-file-name)
    print(user "[")
    var String{32} line-num-str
    self.line-number.str(user line-num-str)
    print(user line-num-str)
    print(user "] ")
  
  func dynamic analyze()
    # do nothing as default
  
  func dynamic write()
    raise
