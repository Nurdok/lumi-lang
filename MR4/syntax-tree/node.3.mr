(## MR4 compiler - Syntax tree basic node types


#)

## Basic node type for all syntax tree nodes
class SyntaxTreeNode
  func dynamic analyze()
    # do nothing as default
  
  func dynamic write()
    raise


## A basic branch node in the syntax tree - a node with chldren nodes
class SyntaxTreeBranch(SyntaxTreeNode)
  var Int indentation-spaces
  owner List{SyntaxTreeVariable} variables
  owner List{SyntaxTreeCode} code-nodes
  
  func inst init()
    new List{SyntaxTreeVariable} in self.variables
    new List{SyntaxTreeCode} in self.code-nodes
  
  func inst parse-block-children(user SyntaxTreeType parent-type):(
      copy Char end)
    if end != '\n'
      f-syntax-error-c(user "expected block in a new line, got", copy end)
    self.init()
    self.parse-children(user parent-type):(copy end)
    if end != EOF
      glob.save-input := true
  
  func inst parse-children(user SyntaxTreeType parent-type):(copy Char end)
    do
      user String keyword
      var Int spaces
      read-until(user " .([?", copy true):(user keyword, copy end, copy spaces)
      # ignore empty lines
      if keyword.length > 0 or end != '\n'
        
        if spaces > self.indentation-spaces
          var String{32} expecte-num
          self.indentation-spaces.str(user expecte-num)
          var String{32} actual-num
          spaces.str(user actual-num)
          f-syntax-error2(
              user "indentation too big, expected",
              user expecte-num,
              user "got",
              user actual-num)
        
        while spaces = self.indentation-spaces and end != EOF
        
        if not self.parse-if-common(user keyword, user parent-type):(copy end)
          self.parse-child(user keyword):(copy end)
        
        while end != EOF
        if not glob.save-input and end != '\n'
          # TODO: is possible?
          f-syntax-error-c(user "expected new-line in line end, got", copy end)
  
  func inst parse-if-common(
      user String keyword, user SyntaxTreeType parent-type):(
      copy Char end, copy Bool is-parsed)
    is-parsed := end = ' '
    if not is-parsed
      return
    
    if keyword.equal(user "#") or keyword.equal(user "##")
      user String text
      read-until(user "", copy false):(user text, copy end)
    else-if keyword.equal(user "{#") or keyword.equal(user "{##")
      var Char prev('\0')
      do
        var Char curr
        read-c():(copy curr)
        while curr != EOF and (curr != '}' or prev != '#')
        prev := curr
      read-c():(copy end)
      
    else-if keyword.equal(user "var")
      self.add-variable(user parent-type, copy ACCESS-VAR):(copy end)
    else-if keyword.equal(user "user")
      self.add-variable(user parent-type, copy ACCESS-USER):(copy end)
    else-if keyword.equal(user "owner")
      self.add-variable(user parent-type, copy ACCESS-OWNER):(copy end)
      
    else
      is-parsed := false
  
  func inst add-variable(user SyntaxTreeType parent-type, copy Int access):(
      copy Char end)
    owner SyntaxTreeVariableInit var-init
    self.variables.add(owner SyntaxTreeVariable.parse-new(
        var _, copy access, user parent-type):(copy end, owner var-init))
    if ? var-init
      self.code-nodes.add(owner var-init)
    
  
  func dynamic parse-child(user String keyword):(copy Char end)
    raise
  
  func dynamic write()
    self.write-children(user self.variables)
  
  func inst write-children(user List{SyntaxTreeNode} child-list)
    user ListNode{SyntaxTreeNode} child(child-list.first)
    do
      while ? child
      if self.indentation-spaces > 0
        write-spaces(copy self.indentation-spaces)
      else
        write(user "\n")
      child.item.write()
      write(user "\n")
      child := child.next


## A basic namespace node in the syntax tree
class SyntaxTreeNamespace(SyntaxTreeBranch)
  owner List{SyntaxTreeFunction} functions
  
  func inst init()
    base.init()
    new List{SyntaxTreeFunction} in self.functions
  
  func inst parse-if-function(
      user String keyword, user SyntaxTreeType parent-type):(
      copy Char end, copy Bool is-func)
    keyword.equal(user "func"):(copy is-func)
    if is-func
      if end != ' '
        f-syntax-error-c(user "expected space after \"func\", got", copy end)
      self.functions.add(owner SyntaxTreeFunction.parse-new(
          var _, user parent-type):(copy end))
  
  func dynamic write()
    base.write()
    self.write-children(user self.functions)


## A basic code node in the syntax tree
class SyntaxTreeCode(SyntaxTreeNode)
  user SyntaxTreeBlock parent


## Count occurrences of a specific type
static TypeCount
  user TypeData type-data
  var Int count


## A basic code block node in the syntax tree
class SyntaxTreeBlock(SyntaxTreeBranch)
  user List{TypeCount} aux-variables
  user SyntaxTreeIf previous-if
  
  func inst parse-block():(copy Char end)
    self.parse-block-children(user _):(copy end)
  
  func dynamic parse-child(user String keyword):(copy Char end)
    owner SyntaxTreeCode node
    user SyntaxTreeIf new-if
    
    if keyword.equal(user "if")
      if end != ' '
        f-syntax-error-c(user "expected space after \"if\", got", copy end)
      SyntaxTreeIf.parse-new(var _, user self):(copy end, owner new-if)
      self.code-nodes.add(owner new-if)
      
    else-if keyword.equal(user "else")
      if not (? self.previous-if)
        f-syntax-error-msg(user "\"else\" without a previous \"if\"")
      if end != '\n'
        f-syntax-error-c(user "expected new-line after \"else\", got", copy end)
      self.previous-if.add-else(
          owner SyntaxTreeElse.parse-new(var _, user self):(copy end))
      
    else-if keyword.equal(user "else-if")
      if not (? self.previous-if)
        f-syntax-error-msg(user "\"else-if\" without a previous \"if\"")
      if end != ' '
        f-syntax-error-c(user "expected space after \"else-if\", got", copy end)
      SyntaxTreeIf.parse-new(var _, user self):(copy end, owner new-if)
      self.previous-if.add-else-if(owner new-if)
      
    else-if keyword.equal(user "do")
      if end != '\n'
        f-syntax-error-c(user "expected new-line after \"do\", got", copy end)
      self.code-nodes.add(
          owner SyntaxTreeDoLoop.parse-new(var _, user self):(copy end))
      
    else-if keyword.equal(user "for")
      if end != ' '
        f-syntax-error-c(user "expected space after \"for\", got", copy end)
      self.code-nodes.add(
          owner SyntaxTreeForLoop.parse-new(var _, user self):(copy end))
      
    else-if keyword.equal(user "while")
      if end != ' '
        f-syntax-error-c(user "expected space after \"while\", got", copy end)
      self.code-nodes.add(
          owner SyntaxTreeWhile.parse-new(var _, user self):(copy end))
      
    else-if keyword.equal(user "continue")
      if end != '\n'
        f-syntax-error-c(
            user "expected new-line after \"continue\", got", copy end)
      self.code-nodes.add(
          owner SyntaxTreeContinue.parse-new(var _, user self):(copy end))
      
    else-if keyword.equal(user "return")
      if end != '\n'
        f-syntax-error-c(
            user "expected new-line after \"return\", got", copy end)
      self.code-nodes.add(
          owner SyntaxTreeReturn.parse-new(var _, user self):(copy end))
      
    else-if keyword.equal(user "raise")
      if end != '\n'
        f-syntax-error-c(
            user "expected new-line after \"raise\", got", copy end)
      self.code-nodes.add(
          owner SyntaxTreeRaise.parse-new(var _, user self):(copy end))
      
    else-if keyword.equal(user "new")
      if end != ' '
        f-syntax-error-c(user "expected space after \"new\", got", copy end)
      self.add-variable(user _, copy ACCESS-OWNER):(copy end)
      
    else
      glob.save-input := true
      self.code-nodes.add(
          owner SyntaxTreeExpression.parse-new(var _, user self):(copy end))
    
    self.previous-if := new-if
  
  func inst write-block()
    # `previous-text` {
    #   `block...`
    # }
    write(user " {\n")
    base.write()
    self.write-children(user self.code-nodes)
    write-spaces(copy self.indentation-spaces - 2)
    write(user "}")
