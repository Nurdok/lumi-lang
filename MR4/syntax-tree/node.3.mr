(## MR4 compiler - Syntax tree basic node types


#)

## Basic node type for all syntax tree nodes
class SyntaxTreeNode
  func dynamic write()
    raise


## A basic branch node in the syntax tree - a node with chldren nodes
class SyntaxTreeBranch(SyntaxTreeNode)
  var Int indentation-spaces
  owner List{SyntaxTreeVariable} variables
  
  func inst parse-children(user SyntaxTreeType parent-type):(copy Char end)
    if end != '\n'
      f-syntax-error-c(user "expected block in a new line, got", copy end)
    new List{SyntaxTreeVariable} in self.variables
    do
      user String keyword
      var Int spaces
      read-until(user " .([?", copy true):(user keyword, copy end, copy spaces)
      # ignore empty lines
      if keyword.length > 0 or end != '\n'
        
        if spaces > self.indentation-spaces
          var String{32} expecte-num
          self.indentation-spaces.str(user expecte-num)
          var String{32} actual-num
          spaces.str(user actual-num)
          f-syntax-error2(
              user "indentation too big, expected",
              user expecte-num,
              user "got",
              user actual-num)
        
        while spaces = self.indentation-spaces and end != EOF
        
        if not self.parse-if-variable(user keyword, user parent-type):(copy end)
          self.parse-child(user keyword):(copy end)
        
        while end != EOF
        if not glob.save-input and end != '\n'
          # TODO: is possible?
          f-syntax-error-c(user "expected new-line in line end, got", copy end)
    
    glob.save-input := true
  
  func inst parse-if-variable(
      user String keyword, user SyntaxTreeType parent-type):(
      copy Char end, copy Bool is-variable)
    is-variable := end = ' '
    if not is-variable
      return
    if keyword.equal(user "var")
      self.variables.add(owner SyntaxTreeVariable.parse-new(
          var _, copy ACCESS-VAR, user parent-type):(copy end))
    else-if keyword.equal(user "user")
      self.variables.add(owner SyntaxTreeVariable.parse-new(
          var _, copy ACCESS-USER, user parent-type):(copy end))
    else-if keyword.equal(user "owner")
      self.variables.add(owner SyntaxTreeVariable.parse-new(
          var _, copy ACCESS-OWNER, user parent-type):(copy end))
    else
      is-variable := false
  
  func dynamic parse-child(user String keyword):(copy Char end)
    raise
  
  func dynamic write()
    self.write-children(user self.variables)
  
  func inst write-children(user List{SyntaxTreeNode} child-list)
    user ListNode{SyntaxTreeNode} child(child-list.first)
    do
      while ? child
      if self.indentation-spaces > 0
        write-spaces(copy self.indentation-spaces)
      else
        write(user "\n")
      child.item.write()
      write(user "\n")
      child := child.next


## A basic namespace node in the syntax tree
class SyntaxTreeNamespace(SyntaxTreeBranch)
  owner List{SyntaxTreeFunction} functions
  
  func inst init()
    new List{SyntaxTreeFunction} in self.functions
  
  func inst parse-if-function(
      user String keyword, user SyntaxTreeType parent-type):(
      copy Char end, copy Bool is-func)
    if end != ' '
      f-syntax-error-c(user "expected space after key-word, got", copy end)
    keyword.equal(user "func"):(copy is-func)
    if is-func
      self.functions.add(owner SyntaxTreeFunction.parse-new(
          var _, user parent-type):(copy end))
  
  func dynamic write()
    base.write()
    self.write-children(user self.functions)


## A basic code node in the syntax tree
class SyntaxTreeCode(SyntaxTreeNode)
  user SyntaxTreeBlock parent


## A basic code block node in the syntax tree
class SyntaxTreeBlock(SyntaxTreeBranch)
  owner List{SyntaxTreeCode} nodes
  user SyntaxTreeIf previous-if
  
  func inst parse-block():(copy Char end)
    new List{SyntaxTreeCode} in self.nodes
    self.parse-children(user _):(copy end)
  
  func dynamic parse-child(user String keyword):(copy Char end)
    owner SyntaxTreeCode node
    user SyntaxTreeIf new-if
    
    if keyword.equal(user "if")
      if end != ' '
        f-syntax-error-c(user "expected space after \"if\", got", copy end)
      SyntaxTreeIf.parse-new(var _, user self):(copy end, owner new-if)
      self.nodes.add(owner new-if)
      
    else-if keyword.equal(user "else")
      if not (? self.previous-if)
        f-syntax-error-msg(user "\"else\" without a previous \"if\"")
      if end != '\n'
        f-syntax-error-c(user "expected new-line after \"else\", got", copy end)
      self.previous-if.add-else(
          owner SyntaxTreeElse.parse-new(var _, user self):(copy end))
      
    else-if keyword.equal(user "else-if")
      if not (? self.previous-if)
        f-syntax-error-msg(user "\"else-if\" without a previous \"if\"")
      if end != ' '
        f-syntax-error-c(user "expected space after \"else-if\", got", copy end)
      SyntaxTreeIf.parse-new(var _, user self):(copy end, owner new-if)
      self.previous-if.add-else-if(owner new-if)
      
    else-if keyword.equal(user "do")
      if end != '\n'
        f-syntax-error-c(user "expected new-line after \"do\", got", copy end)
      self.nodes.add(
          owner SyntaxTreeDoLoop.parse-new(var _, user self):(copy end))
      
    else
      glob.save-input := true
      self.nodes.add(
          owner SyntaxTreeExpression.parse-new(var _, user self):(copy end))
    
    self.previous-if := new-if
  
  func inst write-block()
    write(user " {\n")
    base.write()
    self.write-children(user self.nodes)
    write-spaces(copy self.indentation-spaces - 2)
    write(user "}")
