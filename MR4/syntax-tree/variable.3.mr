## MR4 compiler - Syntax tree variable

## Variable node in the syntax tree
class SyntaxTreeVariable(SyntaxTreeCode)
  owner String name
  var Int access
  owner TypeInstance type-instance
  user TypeData parent-type
  var Bool is-output
  
  func inst parse-new(
      copy Int access,
      user TypeData parent-type,
      user SyntaxTreeBlock parent-block):(
      copy Char end,
      owner SyntaxTreeVariable new-node)
    new SyntaxTreeVariable in new-node
    new-node.parse(copy access, user parent-type, user parent-block):(copy end)
  
  func inst parse(
      copy Int access,
      user TypeData parent-type,
      user SyntaxTreeBlock parent-block):(
      copy Char end)
    self.set-location()
    self.parent := parent-block
    self.parent-type := parent-type
    self.access := access
    new TypeInstance in self.type-instance
    if self.access = ACCESS-VAR or self.access = ACCESS-NEW
      self.type-instance.parse(user " ", user self, user self):(copy end)
    else
      self.type-instance.parse(user " ", user self, user _):(copy end)
    if end != ' '
      self.m-syntax-error-c(user "expected space after type, got", copy end)
    if self.access = ACCESS-VAR
      if self.type-instance.name.equal(user "Array") or
          self.type-instance.name.equal(user "String")
        SyntaxTreeInitVarSequence.init-new(var _, user self)
    read-new(user "("):(owner self.name, copy end)
    self.m-check-name()
    if end = '('
      if ? self.parent-type
        self.m-syntax-error-msg(user "type members cannot be initialized")
      if not (? self.parent)
        self.m-syntax-error-msg(user "global variables cannot be initialized")
      SyntaxTreeVariableInit.parse-new(var _, user self):(copy end)
  
  func inst m-check-name()
    if not f-is-legal-name(user self.name, copy false)
      self.m-syntax-error(user "illegal variable name", user self.name)
    if ? self.parent-type
      user SyntaxTreeVariable field
      self.parent-type.m-find-field(user self.name):(user field)
      if ? field
        self.m-syntax-error(user "redefinition of field", user self.name)
      user SyntaxTreeFunction meth
      self.parent-type.m-find-meth(user self.name):(user meth)
      if ? meth
        self.m-syntax-error(
            user "field name overrides method", user self.name)
    else
      if ? glob.root.m-find-variable(user self.name)
        self.m-syntax-error(
            user "redefinition of global variable", user self.name)
      if ? glob.root.m-find-function(user self.name)
        self.m-syntax-error(
            user "variable name overrides function", user self.name)
      if ? self.parent
        if ? self.parent.m-find-variable(user self.name)
          self.m-syntax-error(
              user "redefinition of variable", user self.name)
  
  func inst m-find-variable(user String name):(
      user SyntaxTreeVariable variable, copy Bool found)
    self.name.equal(user name):(copy found)
    if found
      variable := self
  
  func dynamic m-link-types()
    # sys.print-raw(user "m-link-type var ")
    # sys.print(user self.name)
    self.type-instance.m-link-types(user self)
  
  func dynamic analyze()
    if self.type-instance.type-data.is-primitive and self.access != ACCESS-VAR
      self.m-syntax-error(
          user "only \"var\" access is supported for primitive types, got",
          user glob.access-names[self.access])
    self.type-instance.analyze-lengths(user self)
    if (self.access = ACCESS-VAR or self.access = ACCESS-NEW) and
        not self.type-instance.type-data.is-primitive and not (? self.parent)
      self.m-syntax-error-msg(
          user "non-primitives cannot be declared \"var\" here yet...")
    if self.access = ACCESS-VAR
      self.type-instance.m-check-sequence(user self)
  
  func dynamic write()
    if ? self.parent or ? self.parent-type
      self.write-spaces()
    else
      write(user "\n")
    if self.access = ACCESS-VAR and
        (self.type-instance.type-data = glob.type-array or
        self.type-instance.type-data = glob.type-string)
      if self.type-instance.type-data = glob.type-array and
          self.type-instance.sub-type.type-data = glob.type-string
        # char `name`_Chars[`length` * `string-legth`];
        write(user "char ")
        write-cname(user self.name)
        write(user "_Chars[")
        self.type-instance.length.write()
        write(user " * ")
        self.type-instance.sub-type.length.write()
        write(user "];\n")
        self.write-spaces()
      # `sub-type` `name`_Values[`length`];
      if self.type-instance.type-data = glob.type-string
        write(user "char ")
      else-if self.type-instance.sub-type.type-data = glob.type-func
        write(user "Returncode (*")
      else
        write-cname(user self.type-instance.sub-type.type-data.name)
        write(user " ")
      write-cname(user self.name)
      write(user "_Values[")
      self.type-instance.length.write()
      write(user "]")
      if self.type-instance.type-data = glob.type-array and
          self.type-instance.sub-type.type-data = glob.type-func
        write(user ")")
        self.type-instance.sub-type.arguments.write(copy true)
      write(user ";\n")
      self.write-spaces()
    
    if self.type-instance.type-data = glob.type-func
      self.type-instance.arguments.write-pointer(user self.name)
    else
      write-cname(user self.type-instance.type-data.name)
      if self.access != ACCESS-VAR and self.access != ACCESS-AUX
        write(user "*")
      write(user " ")
      write-cname(user self.name)
    
    if not self.type-instance.type-data.is-primitive and
        (self.access = ACCESS-VAR or self.access = ACCESS-AUX)
      # `type` `name`_Var = {...};
      # `type`* `name` = &`name`_Var;
      write(user "_Var = {")
      if (self.type-instance.type-data = glob.type-array or
          self.type-instance.type-data = glob.type-string) and
          self.access = ACCESS-VAR
        # {`length`, 0, NULL}
        self.type-instance.length.write()
        if self.type-instance.type-data = glob.type-string
          write(user ", 0")
        write(user ", NULL")
      else
        write(user "0")
      write(user "};\n")
      self.write-spaces()
      write-cname(user self.type-instance.type-data.name)
      write(user "* ")
      write-cname(user self.name)
      write(user " = &")
      write-cname(user self.name)
      write(user "_Var")
    else-if ? self.parent
      # `type` `name` = 0;
      # `type`* `name` = NULL;
      if self.access = ACCESS-VAR and
          self.type-instance.type-data != glob.type-func
        write(user " = 0")
      else
        write(user " = NULL")
    write(user ";\n")
    
    if self.type-instance.type-data.is-dynamic
      # `type`_Dynamic* `name`_Dynamic[ = `type`_dynamic];
      if ? self.parent
        self.write-spaces()
      else-if ? self.parent-type
        write(user "  ")
      write-cname(user self.type-instance.type-data.name)
      write(user "_Dynamic* ")
      write-cname(user self.name)
      write(user "_Dynamic")
      if ? self.parent
        write(user " = ")
        if self.access = ACCESS-VAR or self.access = ACCESS-NEW
          write(user "&")
          write-cname(user self.type-instance.type-data.name)
          write(user "_dynamic")
        else
          write(user "NULL")
      write(user ";\n")
  
  func inst write-spaces()
    if ? self.parent
      self.parent.write-spaces()
    else-if ? self.parent-type
      self.parent-type.write-spaces()


class BaseVariableInit(SyntaxTreeCode)
  user SyntaxTreeVariable variable
  
  func inst init(user SyntaxTreeVariable variable)
    self.variable := variable
    self.init-parent(user variable.parent)
  
  func inst init-parent(user SyntaxTreeBlock parent)
    self.parent := parent
    self.set-location()
    self.parent.code-nodes.add(owner self)


## Initialize sequence variable node in the syntax tree
class SyntaxTreeInitVarSequence(BaseVariableInit)
  func inst init-new(user SyntaxTreeVariable variable)
    new SyntaxTreeInitVarSequence new-node
    new-node.init(user variable)
  
  func dynamic write()
    # `name`_Var.values = `name`_Values;
    self.write-spaces()
    write-cname(user self.variable.name)
    write(user "_Var.values = ")
    write-cname(user self.variable.name)
    write(user "_Values;\n")
    if self.variable.type-instance.type-data = glob.type-array and
        self.variable.type-instance.sub-type.type-data = glob.type-string
      # MR_set_var_string_array(
      #    `array-length`, `string-length`, `name`, `name`_Chars);
      self.write-spaces()
      write(user "MR_set_var_string_array(")
      self.variable.type-instance.length.write()
      write(user ", ")
      self.variable.type-instance.sub-type.length.write()
      write(user ", ")
      write-cname(user self.variable.name)
      write(user ", ")
      write-cname(user self.variable.name)
      write(user "_Chars);\n")


## Initialize dynamically allocated variable node in the syntax tree
class SyntaxTreeInitNew(BaseVariableInit)
  owner NewExpression new-expression
  
  func inst parse-new(user SyntaxTreeBlock parent-block):(
      copy Char end, owner SyntaxTreeVariable new-var-node)
    new SyntaxTreeInitNew node-init-new
    node-init-new.parse(user parent-block):(copy end, owner new-var-node)
  
  func dynamic parse(user SyntaxTreeBlock parent-block):(
      copy Char end, owner SyntaxTreeVariable new-var-node)
    self.init-parent(user parent-block)
    SyntaxTreeVariable.parse-new(
        var _, copy ACCESS-NEW, user _, user parent-block):(
        copy end, owner new-var-node)
    self.variable := new-var-node
    new NewExpression in self.new-expression
    self.new-expression.init(owner self.variable.type-instance, user self)
    self.new-expression.result-type.m-copy-new():(
        owner self.variable.type-instance)
    self.new-expression.is-statement := true
  
  func dynamic analyze()
    new SymbolExpression symbol
    string-new-copy(user self.variable.name):(owner symbol.name)
    symbol.variable := self.variable
    self.new-expression.symbol := symbol
    self.new-expression.analyze()
  
  func dynamic write()
    # `variable.name` = `new-expression`
    self.write-spaces()
    self.new-expression.write()


## Variable initialization node in the syntax tree
class SyntaxTreeVariableInit(BaseVariableInit)
  owner Expression value
  
  func inst parse-new(user SyntaxTreeVariable variable):(copy Char end)
    new SyntaxTreeVariableInit new-node
    new-node.parse(user variable):(copy end)
  
  func inst parse(user SyntaxTreeVariable variable):(copy Char end)
    self.init(user variable)
    parse-new-expression(user ")", user self):(owner self.value, copy end)
    if end != ')'
      self.m-syntax-error-c(
          user "expected \")\" after initialization, got",
          copy end)
    read-c():(copy end)
  
  func dynamic analyze()
    if (self.variable.access = ACCESS-VAR or
        self.variable.access = ACCESS-NEW) and
        not self.variable.type-instance.type-data.is-primitive and
        not (self.variable.type-instance.type-data = glob.type-string)
      self.m-syntax-error(
          user "cannot initialize non-primitive type",
          user self.variable.type-instance.type-data.name)
    self.value.analyze()
    self.variable.type-instance.m-check-assign-from(user self):(
        owner self.value)
  
  func dynamic write()
    self.write-spaces()
    self.value.write-preactions()
    if (self.variable.access = ACCESS-VAR or
        self.variable.access = ACCESS-NEW) and
        self.variable.type-instance.type-data = glob.type-string
      # CHECK(`line-num`, String_copy(`name`, `value`) )
      self.write-call()
      write(user "String_copy(")
      write-cname(user self.variable.name)
      write(user ", ")
      self.value.write()
      write(user ") )\n")
    else
      # `name` = `value`;
      write-cname(user self.variable.name)
      write(user " = ")
      self.value.write()
      write(user ";\n")
      if self.variable.type-instance.type-data.is-dynamic
        # `name`_Dynamic = `Type`_Dynamic;
        self.write-spaces()
        write-cname(user self.variable.name)
        write(user "_Dynamic = ")
        self.value.write-dynamic()
        write(user ";\n")
