## MR4 compiler - Syntax tree variable

## Variable node in the syntax tree
class SyntaxTreeVariable(SyntaxTreeCode)
  owner String name
  var Int access
  owner TypeInstance type-instance
  user TypeData parent-type
  var Bool is-output
  var Bool is-create
  var Bool is-native
  
  func inst parse-new(
      copy Int access,
      copy Bool is-create,
      user TypeData parent-type,
      user SyntaxTreeBlock parent-block):(
      copy Char end,
      owner SyntaxTreeVariable new-node)
    new SyntaxTreeVariable in new-node
    new-node.parse(
        copy access, copy is-create, user parent-type, user parent-block):(
        copy end)
  
  func inst parse(
      copy Int access,
      copy Bool is-create,
      user TypeData parent-type,
      user SyntaxTreeBlock parent-block):(
      copy Char end)
    self.set-location()
    self.parent := parent-block
    self.parent-type := parent-type
    self.access := access
    self.is-create := is-create
    new TypeInstance in self.type-instance
    if self.is-create
      self.type-instance.parse(user " ", user self, user self):(copy end)
    else
      self.type-instance.parse(user " ", user self, user _):(copy end)
    if end != ' '
      self.m-syntax-error-c(user "expected space after type, got", copy end)
    read-new(user "("):(owner self.name, copy end)
    self.check-name()
    if end = '('
      if ? self.parent-type
        self.m-syntax-error-msg(user "type members cannot be initialized")
      if not (? self.parent)
        self.m-syntax-error-msg(user "global variables cannot be initialized")
    if ? self.parent and (end = '(' or self.is-create)
      VariableInit.parse-new(var _, user self):(copy end)
  
  func inst check-name()
    if not f-is-legal-name(user self.name, copy false)
      self.m-syntax-error(user "illegal variable name", user self.name)
    if ? self.parent-type
      user SyntaxTreeVariable field
      self.parent-type.find-field(user self.name):(user field)
      if ? field
        self.m-syntax-error(user "redefinition of field", user self.name)
      user SyntaxTreeFunction meth
      self.parent-type.find-meth(user self.name):(user meth)
      if ? meth
        self.m-syntax-error(
            user "field name overrides method", user self.name)
    else
      if ? glob.root.find-variable(user self.name)
        self.m-syntax-error(
            user "redefinition of global variable", user self.name)
      if ? glob.root.find-function(user self.name)
        self.m-syntax-error(
            user "variable name overrides function", user self.name)
      if ? self.parent
        if ? self.parent.find-variable(user self.name)
          self.m-syntax-error(
              user "redefinition of variable", user self.name)
  
  func inst find-variable(user String name):(
      user SyntaxTreeVariable variable, copy Bool found)
    self.name.equal(user name):(copy found)
    if found
      variable := self
  
  func dynamic link-types()
    # sys.print-raw(user "m-link-type var ")
    # sys.print(user self.name)
    self.type-instance.link-types(user self)
  
  func dynamic analyze()
    if self.type-instance.type-data.is-primitive and self.access != ACCESS-VAR
      self.m-syntax-error(
          user "only \"var\" access is supported for primitive types, got",
          user glob.access-names[self.access])
    self.type-instance.analyze-lengths(user self)
    if self.is-create and not self.type-instance.type-data.is-primitive and
        not (? self.parent)
      self.m-syntax-error-msg(
          user "non-primitives cannot be declared \"var\" here yet...")
    if self.access = ACCESS-VAR
      self.type-instance.check-sequence(user self)
  
  func dynamic write()
    if ? self.parent or ? self.parent-type
      self.write-spaces()
    else-if not self.is-native
      write(user "\n")
    
    if self.access = ACCESS-VAR and self.is-create and
        (self.type-instance.type-data = glob.type-array or
        self.type-instance.type-data = glob.type-string)
      self.write-sequence()
    
    if not self.type-instance.type-data.is-primitive and
        self.access = ACCESS-VAR
      self.write-var()
    
    # `type` `name`[ = 0];
    # `type`* `name`[ = NULL];
    # RefManager* `name`_Refman[ = NULL];
    if self.type-instance.type-data = glob.type-func
      self.type-instance.arguments.write-pointer(user self.name)
    else
      write-cname(user self.type-instance.type-data.name)
      if not self.type-instance.type-data.is-primitive
        write(user "*")
      write(user " ")
      write-cname(user self.name)
    
    if not (? self.parent-type) and not self.is-native
      if self.type-instance.type-data.is-primitive and
          self.type-instance.type-data != glob.type-func
        write(user " = 0")
      else
        write(user " = NULL")
    
    write(user ";\n")
    
    if not self.type-instance.type-data.is-primitive
      self.write-refman()
    
    if self.type-instance.type-data.is-dynamic
      self.write-dynamic()
  
  func dynamic write-sequence()
    if self.type-instance.type-data = glob.type-array and
        self.type-instance.sub-types.first.item.type-data = glob.type-string
      # char `name`_Chars[`length` * `string-legth`];
      write(user "char ")
      write-cname(user self.name)
      write(user "_Chars[")
      self.type-instance.length.write()
      write(user " * ")
      self.type-instance.sub-types.first.item.length.write()
      write(user "];\n")
      self.write-spaces()
    # `sub-type` `name`_Values[`length`];
    if self.type-instance.type-data = glob.type-string
      write(user "char ")
    else-if self.type-instance.sub-types.first.item.type-data = glob.type-func
      write(user "Returncode (*")
    else
      write-cname(user self.type-instance.sub-types.first.item.type-data.name)
      write(user " ")
    write-cname(user self.name)
    write(user "_Values[")
    self.type-instance.length.write()
    write(user "]")
    if self.type-instance.type-data = glob.type-array and
        self.type-instance.sub-types.first.item.type-data = glob.type-func
      write(user ")")
      self.type-instance.sub-types.first.item.arguments.write()
    write(user ";\n")
    self.write-spaces()
  
  func inst write-var()
    # `type` `name`_Var = {...};
    write-cname(user self.type-instance.type-data.name)
    write(user " ")
    write-cname(user self.name)
    write(user "_Var = {")
    if self.is-create and
        (self.type-instance.type-data = glob.type-array or
        self.type-instance.type-data = glob.type-string)
      # {`length`, 0, NULL}
      self.type-instance.length.write()
      if self.type-instance.type-data = glob.type-string
        write(user ", 0")
      write(user ", NULL")
    else
      var Int bases
      user TypeData type-data(self.type-instance.type-data.base-type)
      do
        while ? type-data
        type-data := type-data.base-type
        bases += 1
        write(user "{")
      write(user "0")
      for n in bases
        write(user "}")
    write(user "};\n")
    self.write-spaces()
  
  func inst write-refman()
    self.write-spaces()
    write(user "RefManager* ")
    write-cname(user self.name)
    write(user "_Refman")
    if not (? self.parent-type)
      write(user " = NULL")
    write(user ";\n")
  
  func inst write-dynamic()
    # `type`_Dynamic* `name`_Dynamic[ = `type`_dynamic];
    self.write-spaces()
    # if ? self.parent
      # self.write-spaces()
    # else-if ? self.parent-type
      # write(user "  ")
    write-cname(user self.type-instance.type-data.name)
    write(user "_Dynamic* ")
    write-cname(user self.name)
    write(user "_Dynamic")
    if ? self.parent
      write(user " = ")
      if self.is-create
        write(user "&")
        write-cname(user self.type-instance.type-data.name)
        write(user "_dynamic")
      else
        write(user "NULL")
    write(user ";\n")
  
  func inst write-spaces()
    if ? self.parent
      self.parent.get-function().write-spaces()
    else-if ? self.parent-type
      self.parent-type.write-spaces()


class VariableInit(SyntaxTreeCode)
  owner InitExpression expression-init
  
  func inst parse-new(user SyntaxTreeVariable variable):(copy Char end)
    new VariableInit new-node
    new-node.parse(user variable):(copy end)
  
  func inst parse(user SyntaxTreeVariable variable):(copy Char end)
    self.set-location()
    self.parent := variable.parent
    new InitExpression in self.expression-init
    self.expression-init.parse(
        owner variable.type-instance.copy-new(), user self):(copy end)
    self.expression-init.is-statement := true
    new SymbolExpression in self.expression-init.symbol
    string-new-copy(user variable.name):(
        owner self.expression-init.symbol.name)
    self.expression-init.symbol.variable := variable
    variable.type-instance.copy-new():(
        owner self.expression-init.symbol.result-type)
    self.expression-init.symbol.access := variable.access
    variable.parent.code-nodes.add(owner self)
  
  func dynamic analyze()
    self.expression-init.analyze()
  
  func dynamic write()
    self.expression-init.write()
