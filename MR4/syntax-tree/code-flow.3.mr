## MR4 compiler - Syntax tree code flow elements

## Basic code flow element node in the syntax tree
class SyntaxTreeFlowElement(SyntaxTreeCode)
  owner SyntaxTreeBlock block
  
  func inst init(user SyntaxTreeBlock parent)
    new SyntaxTreeBlock in self.block
    self.set-parent(user parent)
  
  func inst set-parent(user SyntaxTreeBlock parent)
    self.parent := parent
    self.block.parent := parent
    self.block.indentation-spaces := parent.indentation-spaces + 2
    self.block.is-in-loop := parent.is-in-loop
  
  func inst parse-block(user SyntaxTreeBlock parent, copy Bool is-loop):(
      copy Char end)
    self.init(user parent)
    if is-loop
      self.block.is-in-loop := true
    self.block.parse-block():(copy end)
  
  func dynamic link-types()
    self.block.link-types()
  
  func dynamic analyze()
    self.block.analyze()
  
  func inst write-block()
    self.block.write-block()
  
  func inst write-block-body()
    self.block.write-block-body()


## If statement node in the syntax tree
class SyntaxTreeIf(SyntaxTreeFlowElement)
  owner Expression condition
  owner SyntaxTreeElse else-node
  
  func inst parse-new(user SyntaxTreeBlock parent):(
      copy Char end, owner SyntaxTreeIf new-node)
    new SyntaxTreeIf in new-node
    new-node.parse(user parent):(copy end)
  
  func inst parse(user SyntaxTreeBlock parent):(copy Char end)
    self.set-location()
    parse-new-expression(user "", user self):(owner self.condition, copy end)
    self.parse-block(user parent, copy false):(copy end)
  
  func inst add-else(owner SyntaxTreeElse else-node)
    else-node.set-parent(user self.parent)
    self.else-node := else-node
  
  func inst add-else-if(owner SyntaxTreeIf new-if)
    new SyntaxTreeElse in self.else-node
    self.else-node.init(user self.parent)
    new List{SyntaxTreeVariable} in self.else-node.block.variables
    new List{SyntaxTreeCode} in self.else-node.block.code-nodes
    self.else-node.block.code-nodes.add(owner new-if)
    new-if.set-parent(user self.else-node.block)
  
  func dynamic analyze()
    self.analyze-expression(user self.condition, user glob.type-bool)
    base.analyze()
    if ? self.else-node
      self.else-node.analyze()
  
    # if (`condition`) {
    #   `block...`
    # }
    # `else-block`
  func dynamic write()
    self.write-spaces()
    self.condition.write-preactions()
    write(user "if (")
    self.condition.write()
    write(user ")")
    self.write-block()
    if ? self.else-node
      self.else-node.write()


## Else statement node in the syntax tree
class SyntaxTreeElse(SyntaxTreeFlowElement)
  func inst parse-new(user SyntaxTreeBlock parent):(
      copy Char end, owner SyntaxTreeElse new-node)
    new SyntaxTreeElse in new-node
    new-node.set-location()
    new-node.parse-block(user parent, copy false):(copy end)
  
  func dynamic write()
    # else {
    #   `block...`
    # }
    self.write-spaces()
    write(user "else")
    self.write-block()


## Do loop node in the syntax tree
class SyntaxTreeDoLoop(SyntaxTreeFlowElement)
  func inst parse-new(user SyntaxTreeBlock parent):(
      copy Char end, owner SyntaxTreeDoLoop new-node)
    new SyntaxTreeDoLoop in new-node
    new-node.set-location()
    new-node.parse-block(user parent, copy true):(copy end)
  
  func dynamic write()
    # while (true) {
    #   `block...`
    # }
    self.write-spaces()
    write(user "while (true)")
    self.write-block()


## For loop node in the syntax tree
class SyntaxTreeForLoop(SyntaxTreeFlowElement)
  owner String item-name
  user SyntaxTreeVariable item
  owner Expression start
  owner Expression iterator
  user SymbolExpression aux-symbol
  user SyntaxTreeFunction has-func
  user SyntaxTreeFunction get-func
  user SyntaxTreeFunction next-func
  
  func inst parse-new(user SyntaxTreeBlock parent):(
      copy Char end, owner SyntaxTreeForLoop new-node)
    new SyntaxTreeForLoop in new-node
    new-node.parse(user parent):(copy end)
  
  func inst parse(user SyntaxTreeBlock parent):(copy Char end)
    self.set-location()
    read-new(user " "):(owner self.item-name, copy end)
    if end != ' '
      self.m-syntax-error-c(
          user "expected space after index name, got", copy end)
    self.read-expect(user "in ")
    parse-new-expression(user ":", user self):(owner self.iterator, copy end)
    if end = ':'
      self.start := self.iterator
      parse-new-expression(user "", user self):(owner self.iterator, copy end)
    
    self.parse-block(user parent, copy true):(copy end)
  
  func dynamic analyze()
    owner TypeInstance type-instance
    if ? self.start
      self.analyze-expression(user self.start, user glob.type-int)
      self.analyze-expression(user self.iterator, user glob.type-int)
      glob.type-int.m-new-type-instance():(owner type-instance)
    else
      self.iterator.analyze()
      if not (? self.iterator.result-type)
        self.m-syntax-error-msg(user "cannot iterate void expression")
      if self.iterator.result-type.type-data = glob.type-int
        glob.type-int.m-new-type-instance():(owner type-instance)
      else-if self.iterator.result-type.type-data = glob.type-string
        glob.type-char.m-new-type-instance():(owner type-instance)
      else-if self.iterator.result-type.type-data = glob.type-array
        self.iterator.result-type.parameters.first.item.copy-new():(
            owner type-instance)
      else
        self.get-iterator-type():(owner type-instance)
    
    if ? self.parent.find-variable(user self.item-name):(user self.item)
      type-instance.check-assign-to(user self.item.type-instance, user self)
      delete type-instance
      delete self.item-name
    else
      new SyntaxTreeVariable item
      item.name := self.item-name
      if type-instance.type-data.is-primitive
        item.access := ACCESS-VAR
      else
        item.access := ACCESS-USER
      item.type-instance := type-instance
      user SyntaxTreeFunction function
      self.get-function():(user function)
      item.parent := function
      self.item := item
      function.variables.add(owner item)
    self.item-name := _
    
    if self.iterator.result-type.type-data != glob.type-int
      new SymbolExpression in self.aux-symbol
      self.aux-symbol.code-node := self
      self.iterator.result-type.copy-new():(owner self.aux-symbol.result-type)
      self.get-function().add-aux-variable(
          copy ACCESS-USER, copy false, user self.iterator.result-type):(
          user self.aux-symbol.variable)
      string-new-copy(user self.aux-symbol.variable.name):(
          owner self.aux-symbol.name)
    
    base.analyze()
  
  func inst get-iterator-type():(owner TypeInstance type-instance)
    self.iterator.result-type.type-data.find-meth(user "has"):(
        user self.has-func)
    if not (? self.has-func)
      self.m-syntax-error(
          user "cannot iterate type with no \"has\" named method - ",
          user self.iterator.result-type.type-data.name)
    if ? self.has-func.arguments.parameters.first.next
      self.m-syntax-error(
          user "iterator \"has\" method has parameters in type",
          user self.iterator.result-type.type-data.name)
    if not (? self.has-func.arguments.outputs.first)
      self.m-syntax-error(
          user "iterator \"has\" method has no outputs in type",
          user self.iterator.result-type.type-data.name)
    if ? self.has-func.arguments.outputs.first.next
      self.m-syntax-error(
          user "iterator \"has\" method has more than one output in type",
          user self.iterator.result-type.type-data.name)
    if self.has-func.arguments.outputs.first.item.get-type-instance().type-data !=
        glob.type-bool
      self.m-syntax-error(
          user "iterator \"has\" method output is not \"Bool\" in type",
          user self.iterator.result-type.type-data.name)
    
    self.iterator.result-type.type-data.find-meth(user "get"):(
        user self.get-func)
    if not (? self.get-func)
      self.m-syntax-error(
          user "cannot iterate type with no \"get\" named method - ",
          user self.iterator.result-type.type-data.name)
    if ? self.get-func.arguments.parameters.first.next
      self.m-syntax-error(
          user "iterator \"get\" method has parameters in type",
          user self.iterator.result-type.type-data.name)
    if not (? self.get-func.arguments.outputs.first)
      self.m-syntax-error(
          user "iterator \"get\" method has no outputs in type",
          user self.iterator.result-type.type-data.name)
    if ? self.get-func.arguments.outputs.first.next
      self.m-syntax-error(
          user "iterator \"get\" method has more than one output in type",
          user self.iterator.result-type.type-data.name)
    if self.get-func.arguments.outputs.first.item.access = ACCESS-OWNER
      self.m-syntax-error(
          user "iterator \"get\" method output has \"owner\" access in type",
          user self.iterator.result-type.type-data.name)
    
    self.get-func.arguments.outputs.first.item.get-type-instance().f-new-replace-params(
        user self.iterator.result-type, copy 0):(owner type-instance)
    
    self.iterator.result-type.type-data.find-meth(user "next"):(
        user self.next-func)
    if not (? self.next-func)
      self.m-syntax-error(
          user "cannot iterate type with no \"next\" named method - ",
          user self.iterator.result-type.type-data.name)
    if ? self.next-func.arguments.parameters.first.next
      self.m-syntax-error(
          user "iterator \"next\" method has parameters in type",
          user self.iterator.result-type.type-data.name)
    if ? self.next-func.arguments.outputs.first
      self.m-syntax-error(
          user "iterator \"next\" method has outputs in type",
          user self.iterator.result-type.type-data.name)
  
  func dynamic write()
    user TypeData iterator-type(self.iterator.result-type.type-data)
    if ? self.aux-symbol
      self.write-assign(
          user self.aux-symbol.variable, owner self.iterator, user self.parent)
    self.write-spaces()
    if ? self.start
      self.start.write-preactions()
    if iterator-type = glob.type-int
      self.write-int-iter()
    else-if iterator-type = glob.type-string or iterator-type = glob.type-array
      self.write-seq()
    else
      self.write-iter()
    if ? self.aux-symbol
      new EmptyExpression empty
      self.write-assign(
          user self.aux-symbol.variable, owner empty, user self.parent)
  
  func inst write-assign(
      user SyntaxTreeVariable item,
      owner Expression value,
      user SyntaxTreeBlock parent)
    var SyntaxTreeExpression expression-node
    expression-node.parent := parent
    value.code-node := expression-node
    
    new SymbolExpression symbol
    string-new-copy(user item.name):(owner symbol.name)
    item.type-instance.copy-new():(owner symbol.result-type)
    
    new BinaryExpression assign
    assign.top := true
    assign.is-statement := true
    assign.code-node := expression-node
    assign.left-expression := symbol
    glob.operator-map.find(user ":="):(user assign.operator)
    assign.right-expression := value
    
    expression-node.expression := assign
    expression-node.write()
  
  func inst write-int-iter()
    # for(`item` = `start`; `item` < `iterator`; ++`item`) {
    #   `block...`
    # }
    write(user "for (")
    write-cname(user self.item.name)
    write(user " = ")
    if ? self.start
      self.start.write()
    else
      write(user "0")
    write(user "; ")
    write-cname(user self.item.name)
    write(user " < ")
    self.iterator.write()
    write(user "; ++")
    write-cname(user self.item.name)
    write(user ")")
    self.write-block()
  
  func inst write-seq()
    # {int `item`_Index; for (`item`_Index = 0; `item`_Index < `iterator`->length; ++`item`_Index) {
    #   `item` = `aux-var`[`item`_Index];
    #   `block...`
    # }}
    write(user "{int ")
    write-cname(user self.item.name)
    write(user "_Index; for (")
    write-cname(user self.item.name)
    write(user "_Index = 0; ")
    write-cname(user self.item.name)
    write(user "_Index < ")
    self.aux-symbol.write()
    write(user "->length; ++")
    write-cname(user self.item.name)
    write(user "_Index) {\n")
    
    new SymbolExpression index-symbol
    string-new-concat(user self.item.name, user "_Index"):(
        owner index-symbol.name)
    new SliceExpression slice
    slice.top := true
    slice.line-number := self.line-number
    slice.sequence := self.aux-symbol
    slice.index := index-symbol
    self.item.type-instance.copy-new():(owner slice.result-type)
    self.write-assign(user self.item, owner slice, user self.block)
    
    self.write-block-body()
    
    self.write-spaces()
    write(user "}}\n")
  
  func inst write-iter()
    # while (true) {
    #   Bool `item`_Has = false;
    #   `has-func`()->(`item`_Has)
    #   if (!`item`_Has) break;
    #   `get-func`()->(`item`)
    #   `block...`
    #   `next-func`()
    # }
    write(user "while (true) {\n")
    self.block.write-spaces()
    write(user "Bool ")
    write-cname(user self.item.name)
    write(user "_Has = false;\n")
    
    new SymbolExpression has-symbol
    string-new-concat(user self.item.name, user "_Has"):(owner has-symbol.name)
    glob.type-bool.m-new-type-instance():(owner has-symbol.result-type)
    new CallArgument has-arg
    has-arg.value := has-symbol
    self.write-iter-meth(user self.has-func, owner has-arg)
    
    self.block.write-spaces()
    write(user "if (!")
    write-cname(user self.item.name)
    write(user "_Has) break;\n")
    
    new SymbolExpression item-symbol
    string-new-copy(user self.item.name):(owner item-symbol.name)
    self.item.type-instance.copy-new():(owner item-symbol.result-type)
    new CallArgument item-arg
    item-arg.value := item-symbol
    item-arg.is-generic :=
        self.get-func.arguments.outputs.first.item.get-type-instance().type-data =
        glob.type-generic
    self.write-iter-meth(user self.get-func, owner item-arg)
    
    self.write-block-body()
    
    self.write-iter-meth(user self.next-func, owner _)
    self.write-spaces()
    write(user "}\n")
  
  func inst write-iter-meth(
      user SyntaxTreeFunction meth, owner CallArgument output-arg)
    var SyntaxTreeExpression expression-node
    expression-node.parent := self.block
    
    new SymbolExpression symbol
    symbol.function := meth
    
    new CallArgument self-arg
    self-arg.is-dynamic := self.aux-symbol.result-type.type-data.is-dynamic
    self-arg.value := self.aux-symbol
    
    new CallExpression call
    call.line-number := self.line-number
    call.top := true
    call.is-statement := true
    call.function := symbol
    new FunctionArguments in call.arguments
    call.arguments.init()
    call.arguments.parameters.add(owner self-arg)
    if ? output-arg
      output-arg.is-output := true
      output-arg.code-node := expression-node
      call.arguments.outputs.add(owner output-arg)
    
    expression-node.expression := call
    expression-node.write()
