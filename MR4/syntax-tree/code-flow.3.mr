## MR4 compiler - Syntax tree code flow elements

## Basic code flow element node in the syntax tree
class SyntaxTreeFlowElement(SyntaxTreeCode)
  owner SyntaxTreeBlock block
  
  func inst init(user SyntaxTreeBlock parent)
    new SyntaxTreeBlock in self.block
    self.set-parent(user parent)
  
  func inst set-parent(user SyntaxTreeBlock parent)
    self.parent := parent
    self.block.parent := parent
    self.block.indentation-spaces := parent.indentation-spaces + 2
    self.block.is-in-loop := parent.is-in-loop
  
  func inst parse-block(user SyntaxTreeBlock parent, copy Bool is-loop):(
      copy Char end)
    self.init(user parent)
    if is-loop
      self.block.is-in-loop := true
    self.block.parse-block():(copy end)
  
  func dynamic link-types()
    self.block.link-types()
  
  func dynamic analyze()
    self.block.analyze()
  
  func inst write-block()
    self.block.write-block()


## If statement node in the syntax tree
class SyntaxTreeIf(SyntaxTreeFlowElement)
  owner Expression condition
  owner SyntaxTreeElse else-node
  
  func inst parse-new(user SyntaxTreeBlock parent):(
      copy Char end, owner SyntaxTreeIf new-node)
    new SyntaxTreeIf in new-node
    new-node.parse(user parent):(copy end)
  
  func inst parse(user SyntaxTreeBlock parent):(copy Char end)
    self.set-location()
    parse-new-expression(user "", user self):(owner self.condition, copy end)
    self.parse-block(user parent, copy false):(copy end)
  
  func inst add-else(owner SyntaxTreeElse else-node)
    else-node.set-parent(user self.parent)
    self.else-node := else-node
  
  func inst add-else-if(owner SyntaxTreeIf new-if)
    new SyntaxTreeElse in self.else-node
    self.else-node.init(user self.parent)
    new List{SyntaxTreeVariable} in self.else-node.block.variables
    new List{SyntaxTreeCode} in self.else-node.block.code-nodes
    self.else-node.block.code-nodes.add(owner new-if)
    new-if.set-parent(user self.else-node.block)
  
  func dynamic analyze()
    self.analyze-expression(user self.condition, user glob.type-bool)
    base.analyze()
    if ? self.else-node
      self.else-node.analyze()
  
    # if (`condition`) {
    #   `block...`
    # }
    # `else-block`
  func dynamic write()
    self.write-spaces()
    self.condition.write-preactions()
    write(user "if (")
    self.condition.write()
    write(user ")")
    self.write-block()
    if ? self.else-node
      self.else-node.write()


## Else statement node in the syntax tree
class SyntaxTreeElse(SyntaxTreeFlowElement)
  func inst parse-new(user SyntaxTreeBlock parent):(
      copy Char end, owner SyntaxTreeElse new-node)
    new SyntaxTreeElse in new-node
    new-node.set-location()
    new-node.parse-block(user parent, copy false):(copy end)
  
  func dynamic write()
    # else {
    #   `block...`
    # }
    self.write-spaces()
    write(user "else")
    self.write-block()


## Do loop node in the syntax tree
class SyntaxTreeDoLoop(SyntaxTreeFlowElement)
  func inst parse-new(user SyntaxTreeBlock parent):(
      copy Char end, owner SyntaxTreeDoLoop new-node)
    new SyntaxTreeDoLoop in new-node
    new-node.set-location()
    new-node.parse-block(user parent, copy true):(copy end)
  
  func dynamic write()
    # while (true) {
    #   `block...`
    # }
    self.write-spaces()
    write(user "while (true)")
    self.write-block()


## For loop node in the syntax tree
class SyntaxTreeForLoop(SyntaxTreeFlowElement)
  owner String index-name
  owner Expression start
  owner Expression upper-bound
  
  func inst parse-new(user SyntaxTreeBlock parent):(
      copy Char end, owner SyntaxTreeForLoop new-node)
    new SyntaxTreeForLoop in new-node
    new-node.parse(user parent):(copy end)
  
  func inst parse(user SyntaxTreeBlock parent):(copy Char end)
    self.set-location()
    read-new(user " "):(owner self.index-name, copy end)
    if end != ' '
      self.m-syntax-error-c(
          user "expected space after index name, got", copy end)
    self.read-expect(user "in ")
    parse-new-expression(user ":", user self):(owner self.upper-bound, copy end)
    if end = ':'
      self.start := self.upper-bound
      parse-new-expression(
          user "", user self):(owner self.upper-bound, copy end)
    self.parse-block(user parent, copy true):(copy end)
    new SyntaxTreeVariable in self.block.ref-variable
    string-new-copy(user self.index-name):(owner self.block.ref-variable.name)
    self.block.ref-variable.check-name()
    self.block.ref-variable.access := ACCESS-VAR
    glob.type-int.m-new-type-instance():(
        owner self.block.ref-variable.type-instance)
  
  func dynamic analyze()
    if ? self.start
      self.analyze-expression(user self.start, user glob.type-int)
    self.analyze-expression(user self.upper-bound, user glob.type-int)
    base.analyze()
  
  func dynamic write()
    # {int `index`; for(`index`=`start`; `index`<`upper-bound`; ++`index`) {
    #    `block...`
    # }}
    self.write-spaces()
    if ? self.start
      self.start.write-preactions()
    self.upper-bound.write-preactions()
    write(user "{int ")
    write-cname(user self.index-name)
    write(user "; for(")
    write-cname(user self.index-name)
    write(user "=")
    if ? self.start
      self.start.write()
    else
      write(user "0")
    write(user "; ")
    write-cname(user self.index-name)
    write(user "<")
    self.upper-bound.write()
    write(user "; ++")
    write-cname(user self.index-name)
    write(user ")")
    self.write-block()
    self.write-spaces()
    write(user "}\n")
