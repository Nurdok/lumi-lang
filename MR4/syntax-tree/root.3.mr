## MR4 compiler - Syntax tree root

## The syntax tree root
class SyntaxTreeRoot(SyntaxTreeNamespace)
  owner List{SyntaxTreeType} types
  user String output-file-name
  
  func inst parse(user Array{String} argv)
    if argv.length < 3
      sys.print(
          user "usage: mr-4compiler OUTPUT-C-FILE-NAME INPUT-MR3-FILES...")
      raise
    
    self.init()
    self.output-file-name := argv[1]
    new List{SyntaxTreeType} in self.types
    for n in 2:argv.length
      glob.input-file-name := argv[n]
      glob.line-number := 0
      file-open(user glob.input-file-name, copy true):(owner glob.input-file)
      
      self.parse-children(user _)
      
      if glob.input-buffer.length > 0 or glob.input-spaces > 0
        f-syntax-error-msg(user "no new-line before file end")
      
      file-close(owner glob.input-file)
  
  func dynamic parse-child(user String keyword):(copy Char end)
    if self.parse-if-function(user keyword, user _):(copy end)
      return
    
    if keyword.equal(user "struct")
      if end != ' '
        f-syntax-error-c(user "expected space after \"struct\", got", copy end)
      self.types.add(owner SyntaxTreeType.parse-new(var _):(copy end))
      
    else-if keyword.equal(user "class")
      if end != ' '
        f-syntax-error-c(user "expected space after \"class\", got", copy end)
      self.types.add(owner SyntaxTreeType.parse-new(var _):(copy end))
      
    else-if keyword.equal(user "main")
      if end != '\n'
        f-syntax-error-c(user "expected new-line after \"main\", got", copy end)
      self.functions.add(owner SyntaxTreeMainFunction.parse-new(var _):(
          copy end))
      
    else-if keyword.equal(user "native")
      if end != ' '
        f-syntax-error-c(user "expected space after \"native\", got", copy end)
      self.functions.add(owner SyntaxTreeNativeFunction.parse-new(var _):(
          copy end))
      
    else-if keyword.equal(user "test")
      if end != ' '
        f-syntax-error-c(user "expected space after \"test\", got", copy end)
      self.functions.add(owner SyntaxTreeTestFunction.parse-new(var _):(
          copy end))
      
    else-if keyword.equal(user "mock")
      if end != ' '
        f-syntax-error-c(user "expected space after \"mock\", got", copy end)
      self.functions.add(owner SyntaxTreeMockFunction.parse-new(var _):(
          copy end))
      
    else
      f-syntax-error(user "unknown keyword", user keyword)
  
  (## write C file in this order:
  1. type declarations
  2. type structs (ordered by depth)
  3. function declarations
  4. global variables
  5. function bodies
  #)
  func dynamic write()
    file-open(user self.output-file-name, copy false):(owner glob.output-file)
    
    write-global(user "#include \"mr.4.h\"\n")
    
    write-global(user "\n\n/* types declaration */\n")
    var SyntaxTreeTypeDeclarationWriter type-declaration-writer
    self.write-for-type(user type-declaration-writer)
    
    # will write type structs
    write-global(user "\n\n/* types struct */\n")
    self.write-children(user self.types)
    
    write-global(user "\n\n/* types methods declaration */\n")
    var SyntaxTreeTypeMethodsDeclarationWriter type-methods-declaration-writer
    self.write-for-type(user type-methods-declaration-writer)
    
    write-global(user "\n\n/* types DTL */\n")
    var SyntaxTreeTypeDtlWriter type-dtl-writer
    self.write-for-type(user type-dtl-writer)
    
    # will write global variables
    write-global(user "\n\n/* global variables */\n")
    self.write-children(user self.variables)
    
    write-global(user "\n\n/* functions declaration */\n")
    self.write-functions-declaration()
    
    write-global(user "\n\n/* types methods body */\n")
    var SyntaxTreeTypeMethodsBodyWriter type-methods-body-writer
    self.write-for-type(user type-methods-body-writer)
    
    # will write global functions bodies
    write-global(user "\n\n/* global functions body */\n")
    self.write-children(user self.functions)
    
    file-close(owner glob.output-file)
  
  func inst write-for-type(user SyntaxTreeTypeWriter type-writer)
    user ListNode{SyntaxTreeType} child(self.types.first)
    do
      while ? child
      write(user "\n")
      type-writer.write(user child.item)
      write(user "\n")
      child := child.next


## proxy write function to be mocked on unit-tests
func write-global(user String text)
  write(user text)
