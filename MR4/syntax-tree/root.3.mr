## MR4 compiler - Syntax tree root

## The syntax tree root
class SyntaxTreeRoot(SyntaxTreeNamespace)
  owner List{TypeData} types
  user String output-file-name
  owner SyntaxTreeMainFunction main-function
  owner GlobalInit global-init
  owner Array{LineCount} line-counts
  var Bool is-library
  var Bool testing
  
  func inst init()
    base.init()
    new List{TypeData} in self.types
    new GlobalInit in self.global-init
    self.global-init.init()
  
  func inst parse(user Array{String} argv)
    if argv.length < 3
      print(user "usage: mr-4compiler OUTPUT-C-FILE-NAME INPUT-MR3-FILES...")
      raise
    
    var Int tested-files
    for n in 2:argv.length
      if argv[n].equal(user "-test")
        self.testing := true
        while false
      tested-files += 1
    if self.testing and tested-files > 0
      new Array{tested-files:LineCount} in self.line-counts
      glob.is-in-testing := true
    
    self.output-file-name := argv[1]
    for n in 2:argv.length
      glob.input-file-name := argv[n]
      glob.input-file-index := n - 2
      if glob.input-file-name.equal(user "-test")
        glob.is-in-testing := false
      else
        glob.line-number := 1
        file-open(user glob.input-file-name, copy true):(owner glob.input-file)
        
        self.parse-children(user _, user _)
        
        if glob.input-buffer.length > 0 or glob.input-spaces > 0
          self.set-location()
          self.m-syntax-error-msg(user "no new-line before file end")
        
        file-close(owner glob.input-file)
        if glob.is-in-testing
          self.line-counts[n - 2].init()
    
    self.input-file-name := argv[2]
    self.line-number := 0
  
  func dynamic parse-child(user String keyword):(copy Char end)
    if self.parse-if-function(user keyword, user _):(copy end)
      return
    
    if keyword.equal(user "struct")
      if end != ' '
        self.m-syntax-error-c(
            user "expected space after \"struct\", got", copy end)
      self.types.add(owner TypeData.parse-new(var _, copy false):(
          copy end))
      
    else-if keyword.equal(user "class")
      if end != ' '
        self.m-syntax-error-c(
            user "expected space after \"class\", got", copy end)
      self.types.add(owner TypeData.parse-new(var _, copy true):(
          copy end))
      
    else-if keyword.equal(user "main")
      if end != '\n'
        self.m-syntax-error-c(
            user "expected new-line after \"main\", got", copy end)
      SyntaxTreeMainFunction.parse-new(var _):(
          copy end, owner self.main-function)
      
    else-if keyword.equal(user "native")
      if end != ' '
        self.m-syntax-error-c(
            user "expected space after \"native\", got", copy end)
      parse-native(user self):(copy end)
      
    else-if keyword.equal(user "test")
      if end != ' '
        self.m-syntax-error-c(
            user "expected space after \"test\", got", copy end)
      self.functions.add(owner SyntaxTreeTestFunction.parse-new(var _):(
          copy end))
      
    else-if keyword.equal(user "mock")
      if end != ' '
        self.m-syntax-error-c(
            user "expected space after \"mock\", got", copy end)
      self.functions.add(owner SyntaxTreeMockFunction.parse-new(var _):(
          copy end))
      
    else
      self.m-syntax-error(user "unknown keyword", user keyword)
  
  func dynamic link-types()
    raise
  
  func dynamic analyze()
    self.m-order-types()
    base.link-types()
    self.link-children-types(user self.types)
    self.global-init.link-types()
    if ? self.main-function
      self.main-function.link-types()
    base.analyze()
    self.analyze-children(user self.types)
    self.global-init.analyze()
    if self.testing
      if not (? glob.test-functions.first)
        print(user "General code error: no test functions")
        raise
    else-if ? self.main-function
      self.main-function.analyze()
    else-if not self.is-library
      print(user "General code error: no main function")
      raise
  
  func inst m-order-types()
    new List{TypeData} ordered-list
    do
      owner TypeData type-data
      self.types.pop():(owner type-data)
      while ? type-data
      type-data.m-order-bases(user ordered-list)
    delete self.types
    self.types := ordered-list
  
  (## write C file in this order:
  1. type declarations
  2. type structs (ordered by depth)
  3. function declarations
  4. global variables
  5. function bodies
  6. main function
  #)
  func dynamic write()
    file-open(user self.output-file-name, copy false):(owner glob.output-file)
    
    write-global(user "#include \"mr.4.h\"\n")
    
    write-global(user "\n\n/* types declaration */\n")
    var TypeDeclarationWriter type-declaration-writer
    self.write-for-type(user type-declaration-writer)
    
    # will write type structures
    write-global(user "\n\n/* types struct */\n")
    self.write-children(user self.types)
    
    write-global(user "\n\n/* types methods declaration */\n")
    var TypeMethodsDeclarationWriter type-methods-declaration-writer
    self.write-for-type(user type-methods-declaration-writer)
    
    write-global(user "\n\n/* global functions declaration */\n")
    self.write-functions-declaration()
    
    write-global(user "\n\n/* types global variables */\n")
    var TypeGlobalWriter type-global-writer
    self.write-for-type(user type-global-writer)
    
    # will write global variables
    write-global(user "\n\n/* global variables */\n")
    self.write-children(user self.variables)
    
    if ? self.line-counts
      self.write-test-coverage-data()
    
    write-global(user "\n\n/* types methods body */\n")
    var TypeMethodsBodyWriter type-methods-body-writer
    self.write-for-type(user type-methods-body-writer)
    
    # will write global functions bodies
    write-global(user "\n\n/* global functions body */\n")
    self.write-children(user self.functions)
    
    # write main function
    if self.testing or ? self.main-function
      if not glob.is-new-mocked
        write(
            user "\n\nReturncode new_Mock(Bool* allocate_success) { return OK; }")
      if not glob.is-delete-mocked
        write(user "\n\nReturncode delete_Mock(Ref self) { return OK; }")
    if self.testing
      self.write-test-main()
    else-if ? self.main-function
      write-global(user "\n\n/* main function */\n")
      self.main-function.write()
    
    file-close(owner glob.output-file)
  
  func inst write-for-type(user TypeWriter type-writer)
    user ListNode{TypeData} child(self.types.first)
    do
      while ? child
      child.item.write-me(user type-writer)
      child := child.next
  
  func inst write-test-coverage-data()
    for n in self.line-counts.length
      user LineCount line-count(self.line-counts[n])
      write(user "\nint MR_file")
      write-int(copy n)
      write(user "_line_count[")
      write-int(copy line-count.line-needs-cover.length)
      write(user "] = {\n  ")
      var Int mod
      for i in line-count.line-needs-cover.length
        if i > 0
          write(user ",")
        if mod = 25
          write(user "\n  ")
          mod := 1
        else
          mod += 1
        if line-count.line-needs-cover[i]
          write(user " 0")
        else
          write(user "-1")
      write(user "\n};")
    write(user "\nFile_Coverage MR_file_coverage[")
    write-int(copy self.line-counts.length)
    write(user "] = {")
    for n in self.line-counts.length
      user LineCount line-count(self.line-counts[n])
      if n > 0
        write(user ",")
      write(user "\n  {\"")
      write(user line-count.filename)
      write(user "\", ")
      write-int(copy line-count.line-needs-cover.length)
      write(user ", MR_file")
      write-int(copy n)
      write(user "_line_count}")
    write(user "\n};\n")
  
  func inst write-test-main()
    write(user "\nUSER_MAIN_HEADER {\n")
    write(user "  Bool MR_success = true;\n")
    self.global-init.write()
    write(user "\n")
    user NameMapNode{SyntaxTreeTestFunction} node(glob.test-functions.first)
    do
      write(user "  RUN_TEST(")
      node.value.write-cname()
      write(user ");\n")
      node := node.next
      while ? node
    if ? self.line-counts
      write(user "  MR_success &= MR_test_coverage(MR_file_coverage, ")
      write-int(copy self.line-counts.length)
      write(user ");\n")
    write(user "  return MR_success? OK : FAIL;\n")
    write(user "}\n")
    write(user "\nTEST_MAIN_FUNC\n")


## Main function node in the syntax tree
class SyntaxTreeMainFunction(SyntaxTreeFunction)
  func inst parse-new():(copy Char end, owner SyntaxTreeMainFunction new-node)
    new SyntaxTreeMainFunction in new-node
    new-node.parse():(copy end)
  
  func inst parse():(copy Char end)
    self.init()
    string-new-copy(user "main"):(owner self.name)
    new FunctionArguments in self.arguments
    self.arguments.init()
    self.parse-body():(copy end)
  
  func dynamic write()
    # USER_MAIN_HEADER {
    #   `block...`
    # }
    # MAIN_FUNC
    write(user "\nUSER_MAIN_HEADER")
    self.write-block()
    write-post-func()
    write(user "\nMAIN_FUNC\n")
  
  func dynamic write-block-body()
    glob.root.global-init.write()
    write-pre-func(user self)
    write(user "\n")
    base.write-block-body()


class GlobalInit(SyntaxTreeFunction)
  func inst init()
    base.init()
    new List{SyntaxTreeCode} in self.code-nodes
    new List{SyntaxTreeVariable} in self.variables
    new FunctionArguments in self.arguments
    self.arguments.init()
    self.indentation-spaces := 2
  
  func dynamic write()
    if not (? self.code-nodes.first)
      return
    self.write-children(user self.variables)
    write(user "#undef RETURN_ERROR\n")
    write(user "#define RETURN_ERROR(value) return value;\n")
    write(user "#define MR_FUNC_NAME \"global variable initialization\"\n")
    self.write-block-body()
    write(user "#undef MR_FUNC_NAME\n")
    write(user "#undef RETURN_ERROR\n")
    write(user "#define RETURN_ERROR(value) MR_err = value; goto MR_cleanup")


static LineCount
  user String filename
  owner Array{Bool} line-needs-cover
  
  func inst init()
    self.filename := glob.input-file-name
    new Array{glob.line-number + 1:Bool} in self.line-needs-cover


## proxy write function to be mocked on unit-tests
func write-global(user String text)
  write(user text)
