## MR4 compiler - Syntax tree node branch

## A basic branch node in the syntax tree - a node with chldren nodes
class SyntaxTreeBranch(SyntaxTreeNode)
  var Int indentation-spaces
  owner List{SyntaxTreeVariable} variables
  
  func inst init()
    new List{SyntaxTreeVariable} in self.variables
  
  func inst parse-block-children(
      user TypeData parent-type, user SyntaxTreeBlock parent-block):(
      copy Char end)
    if end != '\n'
      self.m-syntax-error-c(user "expected block in a new line, got", copy end)
    self.init()
    self.parse-children(user parent-type, user parent-block):(copy end)
    if end != EOF
      glob.save-input := true
  
  func inst parse-children(
      user TypeData parent-type, user SyntaxTreeBlock parent-block):(
      copy Char end)
    var Int my-line-number(self.line-number)
    do
      user String keyword
      var Int spaces
      read-until(user " .([{?", copy true):(user keyword, copy end, copy spaces)
      # ignore empty lines
      if keyword.length > 0 or end != '\n'
        self.set-location()
        
        if not self.parse-if-comment(user keyword):(copy end)
          if spaces > self.indentation-spaces
            var String{32} expecte-num
            self.indentation-spaces.str(user expecte-num)
            var String{32} actual-num
            spaces.str(user actual-num)
            self.m-syntax-error2(
                user "indentation too big, expected",
                user expecte-num,
                user "got",
                user actual-num)
          
          while spaces = self.indentation-spaces and end != EOF
          
          if not self.parse-if-common(
              user keyword, user parent-type, user parent-block):(copy end)
            self.parse-child(user keyword):(copy end)
        
        while end != EOF
        if not glob.save-input and end != '\n'
          self.m-syntax-error-c(
              user "expected new-line in line end, got", copy end)
    
    self.line-number := my-line-number
  
  func inst parse-if-comment(user String keyword):(
      copy Char end, copy Bool is-parsed)
    is-parsed := end = ' '
    if not is-parsed
      return
    if keyword.equal(user "#") or keyword.equal(user "##")
      user String text
      read-until(user "", copy false):(user text, copy end)
    else-if keyword.equal(user "~#") or keyword.equal(user "~##")
      var Char prev('\0')
      do
        var Char curr
        read-c():(copy curr)
        while curr != EOF and (curr != '~' or prev != '#')
        prev := curr
      read-c():(copy end)
    else
      is-parsed := false
  
  func inst parse-if-common(
      user String keyword,
      user TypeData parent-type,
      user SyntaxTreeBlock parent-block):(
      copy Char end,
      copy Bool is-parsed)
    is-parsed := end = ' '
    user List{SyntaxTreeVariable} variables(self.variables)
    if ? parent-block
      variables := parent-block.get-function().variables
    
    if not is-parsed
      return
      
    else-if keyword.equal(user "var")
      variables.add(owner SyntaxTreeVariable.parse-new(
          var _,
          copy ACCESS-VAR,
          copy true,
          user parent-type,
          user parent-block):(
          copy end))
    else-if keyword.equal(user "user")
      variables.add(owner SyntaxTreeVariable.parse-new(
          var _,
          copy ACCESS-USER,
          copy false,
          user parent-type,
          user parent-block):(
          copy end))
    else-if keyword.equal(user "owner")
      variables.add(owner SyntaxTreeVariable.parse-new(
          var _,
          copy ACCESS-OWNER,
          copy false,
          user parent-type,
          user parent-block):(
          copy end))
      
    else
      is-parsed := false
  
  func dynamic parse-child(user String keyword):(copy Char end)
    raise
  
  func dynamic find-variable(user String name):(
      user SyntaxTreeVariable variable)
    variable := _
    user ListNode{SyntaxTreeVariable} child(self.variables.first)
    do
      while ? child
      while not child.item.find-variable(user name):(user variable)
      child := child.next
  
  func dynamic link-types()
    self.link-children-types(user self.variables)
  
  func dynamic analyze()
    self.analyze-children(user self.variables)
  
  func dynamic write()
    self.write-children(user self.variables)
  
  func inst write-spaces()
    write-spaces(copy self.indentation-spaces)
  
  func inst write-cleanup(copy Bool is-type)
    user ListNode{SyntaxTreeVariable} var-node(self.variables.last)
    do
      while ? var-node
      if not var-node.item.type-instance.type-data.is-primitive
        self.write-variable-cleanup(user var-node.item, copy is-type)
      var-node := var-node.prev
  
  func inst write-variable-cleanup(
      user SyntaxTreeVariable variable, copy Bool is-type)
    user TypeData item-type-data(variable.type-instance.type-data)
    if item-type-data = glob.type-array
      item-type-data := variable.type-instance.parameters.first.item.type-data
    if variable.access = ACCESS-OWNER and not item-type-data.is-primitive and
        item-type-data != glob.type-string and
        item-type-data != glob.type-file and
        item-type-data != glob.type-generic
      write(user "  ")
      if variable.type-instance.type-data.is-dynamic
        if is-type
          write(user "self->")
        write-cname(user variable.name)
        write(user "_Dynamic->")
        user TypeData type-data(item-type-data)
        do
          while ? type-data.base-type
          type-data := type-data.base-type.type-data
          while type-data.is-dynamic
          write(user "_base.")
        write(user "_del(")
      else-if variable.type-instance.type-data = glob.type-array
        write(user "ARRAY_DEL(")
        write-cname(user item-type-data.name)
        write(user ", ")
      else
        write-cname(user item-type-data.name)
        write(user "_Del(")
      if is-type
        write(user "self->")
      write-cname(user variable.name)
      write(user ");\n")
    write(user "  MR_")
    if variable.access = ACCESS-OWNER
      write(user "owner_")
    write(user "dec_ref(")
    if is-type
      write(user "self->")
    write-cname(user variable.name)
    write(user "_Refman);\n")


## A basic namespace node in the syntax tree
class SyntaxTreeNamespace(SyntaxTreeBranch)
  owner List{SyntaxTreeFunction} functions
  
  func inst init()
    base.init()
    new List{SyntaxTreeFunction} in self.functions
  
  func inst parse-if-function(
      user String keyword, user TypeData parent-type):(
      copy Char end, copy Bool is-func)
    keyword.equal(user "func"):(copy is-func)
    if is-func
      if end != ' '
        self.m-syntax-error-c(
            user "expected space after \"func\", got", copy end)
      self.functions.add(owner SyntaxTreeFunction.parse-new(
          var _, user parent-type):(copy end))
  
  func inst find-function(user String name):(user SyntaxTreeFunction function)
    user ListNode{SyntaxTreeFunction} child(self.functions.first)
    do
      while ? child
      if child.item.name.equal(user name)
        function := child.item
        return
      child := child.next
    function := _
  
  func dynamic link-types()
    base.link-types()
    self.link-children-types(user self.functions)
  
  func dynamic analyze()
    base.analyze()
    self.analyze-children(user self.functions)
  
  func inst write-functions-declaration()
    user ListNode{SyntaxTreeFunction} child(self.functions.first)
    do
      while ? child
      child.item.write-declaration()
      child := child.next
