## MR4 compiler - Syntax tree type

## Type node in the syntax tree 
class TypeData(SyntaxTreeNamespace)
  owner String name
  owner String base-type-name
  user TypeData base-type
  owner NameMap{SyntaxTreeFunction} dynamic-base-methods
  user SyntaxTreeConstructor constructor
  var Bool is-primitive
  var Bool is-dynamic
  var Bool is-ordered
  
  func inst parse-new(copy Bool is-dynamic):(
      copy Char end, owner TypeData new-node)
    new TypeData in new-node
    new-node.parse(copy is-dynamic):(copy end)
  
  func inst parse(copy Bool is-dynamic):(copy Char end)
    self.is-dynamic := is-dynamic
    self.set-location()
    read-new(user "("):(owner self.name, copy end)
    self.add-type()
    if end = '('
      read-new(user ")"):(owner self.base-type-name, copy end)
      if end != ')'
        self.m-syntax-error-c(
            user "expected \")\" after base type, got", copy end)
      read-c():(copy end)
    self.indentation-spaces := 2
    self.parse-block-children(user self, user _):(copy end)
    self.indentation-spaces := 0
  
  func inst add-type()
    if not f-is-legal-name(user self.name, copy true)
      self.m-syntax-error(user "illegal type name", user self.name)
    if ? glob.type-map.find(user self.name)
      self.m-syntax-error(user "redefinition of type", user self.name)
    glob.add-type(user self)
  
  func dynamic parse-child(user String keyword):(copy Char end)
    if self.parse-if-function(user keyword, user self):(copy end)
      return
    
    if keyword.equal(user "new")
      if end != '('
        self.m-syntax-error-c(
            user "expected \"(\" after \"new\", got", copy end)
      if ? self.constructor
        self.m-syntax-error(
            user "constructor already defined for type", user self.name)
      owner SyntaxTreeConstructor constructor
      self.constructor := SyntaxTreeConstructor.parse-new(
          var _, user self):(copy end, owner constructor)
      self.functions.add(owner constructor)
      
    else
      self.m-syntax-error(user "unknown keyword", user keyword)
  
  func inst m-is-same(user TypeData other):(copy Bool is-same)
    is-same := self = other or
        ((self = glob.type-int or self = glob.type-char) and
        (other = glob.type-int or other = glob.type-char))
  
  func inst m-new-type-instance():(owner TypeInstance type-instance)
    new TypeInstance in type-instance
    type-instance.type-data := self
  
  func inst find-field(user String name):(
      user SyntaxTreeVariable field, copy Int bases)
    user TypeData type-data(self)
    bases := 0
    do
      while ? type-data
      user ListNode{SyntaxTreeVariable} child(type-data.variables.first)
      do
        while ? child
        if child.item.name.equal(user name)
          field := child.item
          return
        child := child.next
      type-data := type-data.base-type
      bases += 1
    field := _
  
  func inst find-meth(user String name):(
      user SyntaxTreeFunction method, copy Int bases)
    user TypeData type-data(self)
    bases := 0
    do
      while ? type-data
      user ListNode{SyntaxTreeFunction} child(type-data.functions.first)
      do
        while ? child
        if child.item.name.equal(user name)
          method := child.item
          return
        child := child.next
      type-data := type-data.base-type
      bases += 1
    method := _
  
  func inst m-order-bases(user List{TypeData} ordered-list)
    if self.is-ordered
      return
    # init `self.base-type`
    if ? self.base-type-name
      self.find-type(user self.base-type-name):(user self.base-type)
      self.base-type.m-order-bases(user ordered-list)
    ordered-list.add(owner self)
    # init `self.dynamic-base-methods` and test override methods
    if self.is-dynamic
      new NameMap{SyntaxTreeFunction} in self.dynamic-base-methods
    user ListNode{SyntaxTreeFunction} child(self.functions.first)
    do
      while ? child
      user SyntaxTreeFunction method
      var Int bases
      self.base-type.find-meth(user child.item.name):(user method, copy bases)
      if ? method
        child.item.m-compare(user method)
        if child.item.is-dynamic
          child.item.dynamic-base-method := method.dynamic-base-method
          child.item.dynamic-base-count := method.dynamic-base-count + bases + 1
      else-if child.item.is-dynamic
        child.item.dynamic-base-method := child.item
        self.dynamic-base-methods.add(user child.item.name, user child.item)
      child := child.next
    self.is-ordered := true
  
  func dynamic analyze()
    if not (? self.base-type) and self.variables.m-is-empty()
      self.m-syntax-error(user "type with no fields", user self.name)
    if self.is-dynamic and not (? self.base-type and self.base-type.is-dynamic)
      user ListNode{SyntaxTreeFunction} node(self.functions.first)
      do
        if not (? node)
          self.m-syntax-error(
              user "class with no dynamic methods", user self.name)
        while not node.item.is-dynamic
        node := node.next
    base.analyze()
  
  func dynamic write-declaration()
    # typedef struct `name` `name`;
    # typedef struct `name`_Dynamic `name`_Dynamic;
    write(user "\ntypedef struct ")
    write-cname(user self.name)
    write(user " ")
    write-cname(user self.name)
    write(user ";\n")
    if self.is-dynamic
      write(user "\ntypedef struct ")
      write-cname(user self.name)
      write(user "_Dynamic ")
      write-cname(user self.name)
      write(user "_Dynamic;\n")
  
  func dynamic write()
    # struct `name` {
    #   `variables...`
    # };
    # struct `name`_Dynamic {
    #   `dynamic-function-pointers...`
    # };
    write(user "\nstruct ")
    write-cname(user self.name)
    write(user " {\n")
    self.indentation-spaces := 2
    if ? self.base-type
      self.write-spaces()
      write-cname(user self.base-type.name)
      write(user " _base;\n")
    self.write-children(user self.variables)
    write(user "};\n")
    if self.is-dynamic
      write(user "\nstruct ")
      write-cname(user self.name)
      write(user "_Dynamic {\n")
      if ? self.base-type and self.base-type.is-dynamic
        self.write-spaces()
        write-cname(user self.base-type.name)
        write(user "_Dynamic _base;\n")
      user NameMapNode{SyntaxTreeFunction} child(self.dynamic-base-methods.first)
      do
        while ? child
        self.write-spaces()
        child.value.write-pointer()
        write(user ";\n")
        child := child.next
      write(user "};\n")
    self.indentation-spaces := 0
  
  func inst write-methods-declaration()
    self.write-functions-declaration()
  
  func inst write-global()
    # `name`_Dynamic `name`_dynamic = {`dynamic-functions...`};
    if self.is-dynamic
      write(user "\n")
      write-cname(user self.name)
      write(user "_Dynamic ")
      write-cname(user self.name)
      write(user "_dynamic = ")
      self.write-dynamic-init(user self)
      write(user ";\n")
  
  func inst write-dynamic-init(user TypeData type-data)
    write(user "{")
    var Bool not-first(? type-data.base-type and type-data.base-type.is-dynamic)
    if not-first
      self.write-dynamic-init(user type-data.base-type)
    user NameMapNode{SyntaxTreeFunction} child(type-data.dynamic-base-methods.first)
    do
      while ? child
      user SyntaxTreeFunction method
      self.find-meth(user child.value.name):(user method)
      if not-first
        write(user ", ")
      if method != child.value
        write(user "(Func)")
      write-cname(user method.parent-type.name)
      write(user "_")
      write-cname(user method.name)
      not-first := true
      child := child.next
    write(user "}")
  
  func inst write-methods-body()
    self.write-children(user self.functions)
  
  func dynamic write-me(user TypeWriter type-writer)
    type-writer.write(user self)


class TypeWriter
  func dynamic write(user TypeData type-data)
    raise

class TypeDeclarationWriter(TypeWriter)
  func dynamic write(user TypeData type-data)
    type-data.write-declaration()

class TypeMethodsDeclarationWriter(TypeWriter)
  func dynamic write(user TypeData type-data)
    type-data.write-methods-declaration()

class TypeGlobalWriter(TypeWriter)
  func dynamic write(user TypeData type-data)
    type-data.write-global()

class TypeMethodsBodyWriter(TypeWriter)
  func dynamic write(user TypeData type-data)
    type-data.write-methods-body()
