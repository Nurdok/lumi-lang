## MR4 compiler - Syntax tree function

## Function node in the syntax tree
class SyntaxTreeFunction(SyntaxTreeBlock)
  owner List{TypeCount} aux-variables-owner
  user TypeData parent-type
  owner String name
  owner FunctionArguments arguments
  user SyntaxTreeMockFunction mocker-function
  user SyntaxTreeFunction dynamic-base-method
  var Int dynamic-base-count
  var Bool is-dynamic
  
  func inst parse-new(user TypeData parent-type):(
      copy Char end, owner SyntaxTreeFunction new-node)
    new SyntaxTreeFunction in new-node
    new-node.parse(user parent-type):(copy end)
  
  func inst parse(user TypeData parent-type):(copy Char end)
    self.init()
    self.parent-type := parent-type
    if ? self.parent-type
      self.indentation-spaces := 2
      if self.parent-type.is-dynamic
        user String meth-type
        read-until(user " ", copy false):(user meth-type, copy end)
        if meth-type.equal(user "dynamic")
          self.is-dynamic := true
        else-if not meth-type.equal(user "inst")
          self.m-syntax-error(
              user "expected \"dynamic\" or \"inst\" method type, got",
              user meth-type)
    self.parse-header():(copy end)
    self.indentation-spaces += 2
    self.parse-body():(copy end)
    self.indentation-spaces := 2
  
  func inst init()
    self.set-location()
    new List{TypeCount} in self.aux-variables-owner
    self.aux-variables := self.aux-variables-owner
  
  func inst parse-body():(copy Char end)
    self.parse-block():(copy end)
    if not self.m-has-end-point()
      self.code-nodes.add(
          owner SyntaxTreeReturn.parse-new(var _, user self):(copy end))
  
  func inst parse-header():(copy Char end)
    read-new(user "("):(owner self.name, copy end)
    self.m-check-name()
    if end != '('
      self.m-syntax-error-c(
          user "expected \"(\" after function name, got", copy end)
    new FunctionArguments in self.arguments
    var DeclarationArgumentFactory argument-factory
    var SyntaxTreeCode dummy-node
    dummy-node.parent := self
    self.arguments.parse(user argument-factory, user dummy-node):(copy end)
    if ? self.parent-type
      self.arguments.add-self-parameter(user self.parent-type)
  
  func dynamic m-check-name()
    if not f-is-legal-name(user self.name, copy false)
      self.m-syntax-error(user "illegal function name", user self.name)
    if ? self.parent-type
      user SyntaxTreeFunction meth
      self.parent-type.m-find-meth(user self.name):(user meth)
      if ? meth
        self.m-syntax-error(user "redefinition of method", user self.name)
      user SyntaxTreeVariable field
      self.parent-type.m-find-field(user self.name):(user field)
      if ? field
        self.m-syntax-error(
            user "method name overrides field", user self.name)
    else
      if ? glob.root.m-find-function(user self.name)
        self.m-syntax-error(user "redefinition of function", user self.name)
      if ? glob.root.m-find-variable(user self.name)
        self.m-syntax-error(
            user "function name overrides global variable", user self.name)
  
  func dynamic m-get-parent-type():(user TypeData parent-type)
    parent-type := self.parent-type
  
  func dynamic m-find-variable(user String name):(
      user SyntaxTreeVariable variable)
    base.m-find-variable(user name):(user variable)
    if not (? variable)
      self.arguments.m-find-variable(user name):(user variable)
    if not (? variable)
      glob.root.m-find-variable(user name):(user variable)
  
  func dynamic m-link-types()
    self.arguments.m-link-types()
    base.m-link-types()
  
  func dynamic analyze()
    self.arguments.analyze()
    base.analyze()
  
  func inst m-compare(user SyntaxTreeFunction other)
    if self.is-dynamic != other.is-dynamic
      self.m-syntax-error(user "illegal dynamic in function", user self.name)
  
  ## write function body
  func dynamic write()
    # #define MR_FILE_NAME "`file-name`"
    # #define MR_FUNC_NAME "`parent-type`.`function-name`"
    # Returncode `Type`_`name`(`args`) {
    #   `block...`
    # }
    # #undef MR_FILE_NAME
    # #undef MR_FUNC_NAME
    write-pre-func(user self)
    self.write-header()
    self.write-block()
    write-post-func()
  
  func inst write-header()
    write(user "Returncode ")
    self.write-cname()
    self.arguments.write(copy true)
  
  func inst write-cname()
    if ? self.parent-type
      write-cname(user self.parent-type.name)
      write(user "_")
    write-cname(user self.name)
  
  func inst write-pointer()
    self.arguments.write-pointer(user self.name)
  
  func inst write-declaration()
    # Returncode `Type`_`name`(`args`);
    write(user "\n")
    self.write-header()
    write(user ";\n")

# to be mocked in unit-tests
func write-pre-func(user SyntaxTreeFunction self)
  write(user "#define MR_FILE_NAME \"")
  write(user self.input-file-name)
  write(user "\"\n#define MR_FUNC_NAME \"")
  if ? self.parent-type
    write(user self.parent-type.name)
    write(user ".")
  write(user self.name)
  write(user "\"\n")

# to be mocked in unit-tests
func write-post-func()
    write(user "\n#undef MR_FILE_NAME\n")
    write(user "#undef MR_FUNC_NAME")


## Main function node in the syntax tree
class SyntaxTreeMainFunction(SyntaxTreeFunction)
  func inst parse-new():(copy Char end, owner SyntaxTreeMainFunction new-node)
    new SyntaxTreeMainFunction in new-node
    new-node.parse():(copy end)
  
  func inst parse():(copy Char end)
    self.init()
    self.indentation-spaces := 2
    string-new-copy(user "main"):(owner self.name)
    new FunctionArguments in self.arguments
    self.arguments.init()
    self.parse-body():(copy end)
  
  func dynamic write()
    # USER_MAIN_HEADER {
    #   `block...`
    # }
    # MAIN_FUNC
    write(user "\n")
    write-pre-func(user self)
    write(user "USER_MAIN_HEADER")
    self.write-block()
    write-post-func()
    write(user "\n\nMAIN_FUNC\n")


## Native function declaration in the syntax tree
class SyntaxTreeNativeFunction(SyntaxTreeFunction)
  func inst parse-new():(copy Char end, owner SyntaxTreeNativeFunction new-node)
    new SyntaxTreeNativeFunction in new-node
    new-node.parse():(copy end)
  
  func inst parse():(copy Char end)
    self.set-location()
    self.indentation-spaces := 2
    self.parse-header():(copy end)
    new List{SyntaxTreeCode} in self.code-nodes
  
  func dynamic write()
    # do nothing


## Function declaration argument
class DeclarationArgument(Argument)
  owner SyntaxTreeVariable variable
  
  func dynamic m-copy-new():(owner DeclarationArgument new-argument)
    new DeclarationArgument in new-argument
    new-argument.access := self.access
    new SyntaxTreeVariable in new-argument.variable
    new-argument.variable.access := self.variable.access
    self.variable.type-instance.m-copy-new():(
        owner new-argument.variable.type-instance)
    string-new-copy(user self.variable.name):(owner new-argument.variable.name)
  
  func dynamic parse-value(user SyntaxTreeCode code-node):(copy Char end)
    new SyntaxTreeVariable in self.variable
    self.variable.access := self.access
    self.variable.is-output := self.is-output
    new TypeInstance in self.variable.type-instance
    self.variable.type-instance.parse(user " ", user self, user _):(copy end)
    if end != ' '
      self.m-syntax-error-c(user "expected space after type, got", copy end)
    read-new(user ",)"):(owner self.variable.name, copy end)
  
  func dynamic m-link-types()
    self.variable.type-instance.m-link-types(user self)
  
  func dynamic analyze()
    if self.variable.type-instance.type-data.is-primitive
      if self.access != ACCESS-COPY
        self.m-syntax-error2(
            user "argument",
            user self.variable.name,
            user "access should be \"copy\" for primitive types, got",
            user glob.access-names[self.access])
    else-if self.access = ACCESS-COPY
      self.m-syntax-error2(
          user "argument",
          user self.variable.name,
          user "access should not be \"copy\" for non-primitive type",
          user self.variable.type-instance.type-data.name)
    self.variable.type-instance.analyze-lengths(user self)
  
  func dynamic get-type-instance():(user TypeInstance type-instance)
    type-instance := self.variable.type-instance
  
  func dynamic get-variable():(user SyntaxTreeVariable variable)
    variable := self.variable
  
  func dynamic write()
    if self.variable.type-instance.type-data = glob.type-func
      write(user "Returncode (*")
      if self.is-output
        write(user "*")
      write-cname(user self.variable.name)
      write(user ")")
      self.variable.type-instance.arguments.write(copy true)
      return
    # `type`[*][*] `name`[, `type`_Dynamic*[*] `name`_Dynamic]
    write-cname(user self.variable.type-instance.type-data.name)
    if self.access != ACCESS-COPY
      write(user "*")
    if self.is-output
      write(user "*")
    write(user " ")
    write-cname(user self.variable.name)
    if self.variable.type-instance.type-data.is-dynamic
      write(user ", ")
      write-cname(user self.variable.type-instance.type-data.name)
      write(user "_Dynamic*")
      if self.is-output
        write(user "*")
      write(user " ")
      write-cname(user self.variable.name)
      write(user "_Dynamic")


class DeclarationArgumentFactory(ArgumentFactory)
  func dynamic m-new-argument():(owner Argument new-argument)
    new DeclarationArgument in new-argument
