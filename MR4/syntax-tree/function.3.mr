## MR4 compiler - Syntax tree function

## Function node in the syntax tree
class SyntaxTreeFunction(SyntaxTreeBlock)
  owner List{TypeCount} aux-variables-owner
  user TypeData parent-type
  owner String name
  owner FunctionArguments arguments
  var Bool is-dynamic
  
  func inst parse-new(user TypeData parent-type):(
      copy Char end, owner SyntaxTreeFunction new-node)
    new SyntaxTreeFunction in new-node
    new-node.parse(user parent-type):(copy end)
  
  func inst parse(user TypeData parent-type):(copy Char end)
    self.init()
    self.parent-type := parent-type
    if ? self.parent-type
      self.indentation-spaces := 4
      if self.parent-type.is-dynamic
        user String meth-type
        read-until(user " ", copy false):(user meth-type, copy end)
        if meth-type.equal(user "dynamic")
          self.is-dynamic := true
        else-if not meth-type.equal(user "inst")
          self.m-syntax-error(
              user "expected \"dynamic\" or \"inst\" method type, got",
              user meth-type)
    self.parse-header():(copy end)
    self.parse-body():(copy end)
    self.indentation-spaces := 2
  
  func inst init()
    self.set-location()
    new List{TypeCount} in self.aux-variables-owner
    self.aux-variables := self.aux-variables-owner
    self.indentation-spaces := 2
  
  func inst parse-body():(copy Char end)
    self.parse-block():(copy end)
    if not self.m-has-end-point()
      self.code-nodes.add(
          owner SyntaxTreeReturn.parse-new(var _, user self):(copy end))
  
  func inst parse-header():(copy Char end)
    read-new(user "("):(owner self.name, copy end)
    if end != '('
      self.m-syntax-error-c(
          user "expected \"(\" after function name, got", copy end)
    new FunctionArguments in self.arguments
    var ArgumentFactory argument-factory
    self.arguments.parse(
        user argument-factory, user _, user self.parent-type):(copy end)
  
  func dynamic m-get-parent-type():(user TypeData parent-type)
    parent-type := self.parent-type
  
  func dynamic m-find-variable(user String name):(
      user SyntaxTreeVariable variable)
    base.m-find-variable(user name):(user variable)
    if not (? variable)
      self.arguments.m-find-variable(user name):(user variable)
    if not (? variable)
      glob.root.m-find-variable(user name):(user variable)
  
  func dynamic analyze()
    self.arguments.analyze()
    base.analyze()
  
  func inst m-compare(user SyntaxTreeFunction other)
    if self.is-dynamic != other.is-dynamic
      self.m-syntax-error(user "illegal dynamic in function", user self.name)
  
  ## write function body
  func dynamic write()
    # Returncode `Type`_`name`(`args`) {
    #   `block...`
    # }
    self.write-header()
    self.write-block()
  
  func inst write-header()
    write(user "Returncode ")
    if ? self.parent-type
      write-cname(user self.parent-type.name)
      write(user "_")
    write-cname(user self.name)
    self.arguments.write(copy true)
  
  func inst write-pointer()
    write(user "Returncode (*")
    write-cname(user self.name)
    write(user ")")
    self.arguments.write(copy true)
  
  func inst write-declaration()
    # Returncode `Type`_`name`(`args`);
    write(user "\n")
    self.write-header()
    write(user ";\n")


## Main function node in the syntax tree
class SyntaxTreeMainFunction(SyntaxTreeFunction)
  func inst parse-new():(copy Char end, owner SyntaxTreeMainFunction new-node)
    new SyntaxTreeMainFunction in new-node
    new-node.parse():(copy end)
  
  func inst parse():(copy Char end)
    self.init()
    string-new-copy(user "main"):(owner self.name)
    new FunctionArguments in self.arguments
    self.arguments.init()
    self.parse-body():(copy end)
  
  func dynamic write()
    # USER_MAIN_HEADER {
    #   `block...`
    # }
    # MAIN_FUNC
    write(user "\nUSER_MAIN_HEADER")
    self.write-block()
    write(user "\nMAIN_FUNC\n")


## Native function declaration in the syntax tree
class SyntaxTreeNativeFunction(SyntaxTreeFunction)
  func inst parse-new():(copy Char end, owner SyntaxTreeNativeFunction new-node)
    new SyntaxTreeNativeFunction in new-node
    new-node.parse():(copy end)
  
  func inst parse():(copy Char end)
    self.set-location()
    self.indentation-spaces := 2
    self.parse-header():(copy end)
    new List{SyntaxTreeCode} in self.code-nodes
  
  func dynamic write()
    # do nothing


## Basic function argument
class Argument(SyntaxTreeNode)
  var Int access
  var Bool is-output
  
  func dynamic m-copy-new():(owner DeclarationArgument new-argument)
    raise
  
  func inst parse(
      user String access-str,
      copy Bool is-output,
      user SyntaxTreeCode code-node):(
      copy Char end)
    self.is-output := is-output
    self.set-location()
    self.get-access(user access-str):(copy self.access)
    self.parse-value(user code-node):(copy end)
  
  func dynamic parse-value(user SyntaxTreeCode code-node):(copy Char end)
    raise
  
  func dynamic get-type-instance():(user TypeInstance type-instance)
    raise
  
  func dynamic get-variable():(user SyntaxTreeVariable variable)
    raise
  
  func dynamic get-output():(user Expression output)
    raise
  
  func dynamic write-preactions()
    raise


## Function declaration argument
class DeclarationArgument(Argument)
  owner SyntaxTreeVariable variable
  
  func dynamic m-copy-new():(owner DeclarationArgument new-argument)
    new DeclarationArgument in new-argument
    new-argument.access := self.access
    new SyntaxTreeVariable in new-argument.variable
    new-argument.variable.access := self.variable.access
    self.variable.type-instance.m-copy-new():(
        owner new-argument.variable.type-instance)
    string-new-copy(user self.variable.name):(owner new-argument.variable.name)
  
  func dynamic parse-value(user SyntaxTreeCode code-node):(copy Char end)
    new SyntaxTreeVariable in self.variable
    self.variable.access := self.access
    new TypeInstance in self.variable.type-instance
    self.variable.type-instance.parse(user " ", user self):(copy end)
    if end != ' '
      self.m-syntax-error-c(user "expected space after type, got", copy end)
    read-new(user ",)"):(owner self.variable.name, copy end)
  
  func dynamic analyze()
    self.variable.type-instance.analyze(user self)
  
  func dynamic get-type-instance():(user TypeInstance type-instance)
    type-instance := self.variable.type-instance
  
  func dynamic get-variable():(user SyntaxTreeVariable variable)
    variable := self.variable
  
  func dynamic write()
    # `type`** `name`
    write-cname(user self.variable.type-instance.type-data.name)
    if self.access != ACCESS-COPY
      write(user "*")
    if self.is-output
      write(user "*")
    write(user " ")
    write-cname(user self.variable.name)


class ArgumentFactory
  func dynamic m-new-argument():(owner Argument new-argument)
    new DeclarationArgument in new-argument


## All function parameters and outputs
class FunctionArguments(SyntaxTreeNode)
  owner List{Argument} parameters
  owner List{Argument} outputs
  
  func inst m-copy-new():(owner FunctionArguments new-arguments)
    self.m-copy-new-args(user self.parameters, user new-arguments.parameters)
    self.m-copy-new-args(user self.outputs, user new-arguments.outputs)
  
  func inst m-copy-new-args(
      user List{Argument} arguments, user List{Argument} new-arguments)
    user ListNode{Argument} node(arguments.first)
    do
      while ? node
      new-arguments.add(owner node.item.m-copy-new())
      node := node.next
  
  func inst init()
    self.set-location()
    new List{Argument} in self.parameters
    new List{Argument} in self.outputs
  
  func inst parse(
      user ArgumentFactory argument-factory,
      user SyntaxTreeCode code-node,
      user TypeData parent-type):(
      copy Char end)
    self.init()
    if ? parent-type
      new DeclarationArgument self-args
      self-args.access := ACCESS-VAR
      new SyntaxTreeVariable in self-args.variable
      string-new-copy(user "self"):(owner self-args.variable.name)
      parent-type.m-new-type-instance():(owner self-args.variable.type-instance)
      self.parameters.add(owner self-args)
    self.parse-args(
        user self.parameters, user argument-factory, user code-node):(copy end)
    if end = '-'
      self.read-expect(user ">(")
      self.parse-args(
          user self.outputs, user argument-factory, user code-node):(copy end)
  
  func inst parse-args(
      user List{Argument} arguments,
      user ArgumentFactory argument-factory,
      user SyntaxTreeCode code-node):(
      copy Char end)
    owner Argument argument
    user String access-str
    var Bool is-output(arguments = self.outputs)
    read-until(user " )", copy false):(user access-str, copy end)
    if end = '\n' and access-str.length = 0
      self.read-line-break-spaces()
      read-until(user " ", copy false):(user access-str, copy end)
    if end != ')' or access-str.length > 0
      do
        if access-str.length = 0
          self.m-syntax-error-c(user "expected access, got", copy end)
        if end != ' '
          self.m-syntax-error-c(
              user "expected space after access, got", copy end)
        argument-factory.m-new-argument():(owner argument)
        arguments.add(owner argument)
        argument.parse(user access-str, copy is-output, user code-node):(
            copy end)
        while end = ','
        read-c():(copy end)
        if end = '\n'
          self.read-line-break-spaces()
        else-if end != ' '
          self.m-syntax-error-c(
              user "expected space or new-line after \",\", got",
              copy end)
        read-until(user " ", copy false):(user access-str, copy end)
    read-c():(copy end)
  
  func inst analyze()
    self.analyze-args(user self.parameters)
    self.analyze-args(user self.outputs)
  
  func inst analyze-args(user List{Argument} arguments)
    user ListNode{Argument} node(arguments.first)
    do
      while ? node
      node.item.analyze()
      node := node.next
  
  func inst get-result-type():(user TypeInstance result-type)
    if ? self.outputs.last
      self.outputs.last.item.get-type-instance():(user result-type)
    else
      result-type := _
  
  func inst get-output():(user Expression output)
    if ? self.outputs.last
      self.outputs.last.item.get-output():(user output)
    else
      output := _
  
  func inst m-find-variable(user String name):(
      user SyntaxTreeVariable variable)
    self.m-find-variable-args(user self.parameters, user name):(user variable)
    if not (? variable)
      self.m-find-variable-args(user self.outputs, user name):(user variable)
  
  func inst m-find-variable-args(
      user List{Argument} arguments, user String name):(
      user SyntaxTreeVariable variable)
    user ListNode{Argument} node(arguments.first)
    do
      while ? node
      while not
          node.item.get-variable().m-find-variable(user name):(user variable)
      node := node.next
  
  func inst m-check-calling(
      user FunctionArguments other):(copy Bool output-ommited)
    user ListNode{Argument} my-node(self.parameters.first)
    user ListNode{Argument} other-node(other.parameters.first)
    do
      while ? my-node and ? other-node
      my-node.item.get-type-instance().m-check-assign-to(
          user other-node.item.get-type-instance(), user self)
      my-node := my-node.next
      other-node := other-node.next
    if ? my-node
      self.m-syntax-error-msg(user "too many parameters")
    if ? other-node
      self.m-syntax-error-msg(user "too few parameters")
    
    my-node := self.outputs.first
    other-node := other.outputs.first
    do
      while ? my-node and ? other-node
      other-node.item.get-type-instance().m-check-assign-to(
          user my-node.item.get-type-instance(), user self)
      my-node := my-node.next
      other-node := other-node.next
    if ? my-node
      self.m-syntax-error-msg(user "too many outputs")
    if ? other-node and ? other-node.next
      self.m-syntax-error-msg(user "too few outputs")
    output-ommited := ? other-node
  
  func inst write-preactions()
    self.write-args-preactions(user self.parameters)
    self.write-args-preactions(user self.outputs)
  
  func inst write-args-preactions(user List{Argument} arguments)
    user ListNode{Argument} node(arguments.first)
    do
      while ? node
      node.item.write-preactions()
      node := node.next
  
  func inst write(copy Bool is-decleration)
    # (`params...`, `outputs...`)
    write(user "(")
    if ? self.parameters.first
      self.write-args(user self.parameters)
    if ? self.outputs.first
      if ? self.parameters.first
        write(user ", ")
      self.write-args(user self.outputs)
    else-if not (? self.parameters.first) and is-decleration
      write(user "void")
    write(user ")")
  
  func inst write-args(user List{Argument} arguments)
    user ListNode{Argument} node(arguments.first)
    do
      node.item.write()
      node := node.next
      while ? node
      write(user ", ")
