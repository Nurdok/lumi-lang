## MR4 compiler - Type instance

## Specific usage of a type including the assigned subtypes and values
static TypeInstance
  owner String name
  user TypeData type-data
  owner List{TypeInstance} sub-types
  owner Expression length-owner
  user Expression length
  owner FunctionArguments arguments
  
  ## Return a new deep-copy of self
  func inst copy-new():(owner TypeInstance type-instance)
    self.f-new-replace-params(user _):(owner type-instance)
  
  func inst f-new-replace-params(user TypeInstance instance-type):(
      owner TypeInstance type-instance)
    if not (? self)
      type-instance := _
      return
    if self.type-data = glob.type-subtype and ? instance-type and
        ? instance-type.sub-types and ? instance-type.type-data.sub-types
      user ListNode{String} dec-node(instance-type.type-data.sub-types.first)
      user ListNode{TypeInstance} inst-node(instance-type.sub-types.first)
      do
        while ? dec-node and ? inst-node
        if dec-node.item.equal(user self.name)
          type-instance := inst-node.item
          return
        dec-node := dec-node.next
        inst-node := inst-node.next
    self.type-data.m-new-type-instance():(owner type-instance)
    string-new-copy(user self.name):(owner type-instance.name)
    type-instance.length := self.length
    if ? self.sub-types
      new List{TypeInstance} in type-instance.sub-types
      user ListNode{TypeInstance} node(self.sub-types.first)
      do
        while ? node
        type-instance.sub-types.add(owner node.item.f-new-replace-params(
            user instance-type))
        node := node.next
    if ? self.arguments
      self.arguments.copy-new():(owner type-instance.arguments)
  
  func inst parse(
      user String ends,
      user SyntaxTreeNode node,
      user SyntaxTreeCode code-node):(
      copy Char end)
    user String name
    read-until(user string-new-concat(user ends, user "{"), copy false):(
        user name, copy end)
    self.parse-name(user name, user node, user code-node):(copy end)
  
  func inst parse-name(
      user String name,
      user SyntaxTreeNode node,
      user SyntaxTreeCode code-node):(
      copy Char end)
    string-new-copy(user name):(owner self.name)
    if end = '{'
      if self.name.equal(user "Func")
        read-c():(copy end)
        if end != '('
          node.m-syntax-error-c(
              user "expected \"(\" inside Function type, got", copy end)
        new FunctionArguments in self.arguments
        var DeclarationArgumentFactory argument-factory
        self.arguments.parse(
            user argument-factory, copy false, user code-node):(copy end)
      else-if ? code-node and self.name.equal(user "String")
        parse-new-expression(user "}", user code-node):(
            owner self.length-owner, copy end)
        self.length := self.length-owner
      else
        var Bool has-sub-type(true)
        var Bool is-array(self.name.equal(user "Array"))
        if ? code-node and is-array
          parse-new-expression(user ":}", user code-node):(
              owner self.length-owner, copy end)
          self.length := self.length-owner
          if end != ':' and end != '}'
            node.m-syntax-error-c(
                user "expected \":\" or \"} after array length\", got",
                copy end)
          has-sub-type := end = ':'
        if has-sub-type
          if not is-array
            code-node := _
          new List{TypeInstance} in self.sub-types
          do
            new TypeInstance sub-type
            sub-type.parse(user ":}", user node, user code-node):(copy end)
            self.sub-types.add(owner sub-type)
            while end = ':'
            if is-array
              node.m-syntax-error-msg(user "more than one subtype for array")
      if end != '}'
        node.m-syntax-error-c(user "expected \"}\" after sub-types, got",
            copy end)
      read-c():(copy end)
  
  func inst add-subtype-copy(user TypeData type-data)
    if not (? self.sub-types)
      new List{TypeInstance} in self.sub-types
    self.sub-types.add(owner type-data.m-new-type-instance())
  
  func inst analyze(user SyntaxTreeNode node)
    self.analyze-part(user node, copy true, copy true)
  
  func inst link-types(user SyntaxTreeNode node)
    self.analyze-part(user node, copy true, copy false)
  
  func inst analyze-lengths(user SyntaxTreeNode node)
    self.analyze-part(user node, copy false, copy true)
  
  func inst analyze-part(
      user SyntaxTreeNode node, copy Bool check-types, copy Bool check-length)
    if check-types
      if not (? self.type-data)
        node.find-type(user self.name):(user self.type-data)
      if ? self.arguments
        self.arguments.link-types()
    if check-length
      if ? self.length
        node.analyze-expression(user self.length, user glob.type-int)
      if ? self.arguments
        self.arguments.analyze()
    if ? self.sub-types
      user ListNode{TypeInstance} sub-type(self.sub-types.first)
      do
        while ? sub-type
        sub-type.item.analyze-part(
            user node, copy check-types, copy check-length)
        sub-type := sub-type.next
    if check-types
      self.check-parameters(user node)
  
  func inst check-parameters(user SyntaxTreeNode node)
    if self.type-data = glob.type-array
      if not (? self.sub-types)
        node.m-syntax-error-msg(user "missing subtype for array")
      if self.sub-types.first.item.type-data = glob.type-array
        node.m-syntax-error-msg(
            user "multidimensional array not supported yet...")
    else-if ? self.sub-types
      if not (? self.type-data.sub-types)
        node.m-syntax-error(
            user "parameter given for type with no parameters",
            user self.type-data.name)
      user ListNode{TypeInstance} sub-type(self.sub-types.first)
      user ListNode{String} dec-node(self.type-data.sub-types.first)
      do
        while ? sub-type
        if not (? dec-node)
          node.m-syntax-error(
              user "too many parameter for type", user self.type-data.name)
        if sub-type.item.type-data.is-primitive
          node.m-syntax-error(
              user "unsupported primitive parameter type",
              user sub-type.item.type-data.name)
        sub-type := sub-type.next
        dec-node := dec-node.next
    else-if self.type-data = glob.type-func and not (? self.arguments)
      node.m-syntax-error-msg(user "missing arguments in function type")
  
  func inst check-assign-from(user SyntaxTreeNode node):(
      owner Expression value)
    var Int bases
    value.result-type.check-assign-to(user self, user node):(copy bases)
    if bases > 0
      UpCastExpression.init-new(var _, copy bases):(owner value)
  
  func inst check-assign-to(
      user TypeInstance target, user SyntaxTreeNode node):(copy Int bases)
    bases := 0
    if not (? self)
      node.m-syntax-error-msg(user "cannot assign void expression")
    if self.type-data = glob.type-empty and
        (not target.type-data.is-primitive or target.type-data = glob.type-func)
      return
    if self.type-data = glob.type-subtype and
        target.type-data = glob.type-subtype
      if not self.name.equal(user target.name)
        node.m-syntax-error2(
            user "cannot assign generic subtype",
            user self.name,
            user "into different generic subtype",
            user target.name)
    user TypeData base-type(self.type-data)
    do
      while not target.type-data.m-is-same(user base-type)
      if not (? base-type.base-type)
        node.m-syntax-error2(
            user "cannot assign",
            user self.type-data.name,
            user "into",
            user target.type-data.name)
      while ? base-type.base-type
      base-type := base-type.base-type.type-data
      bases += 1
    
    if ? self.arguments
      if self.arguments.check-same-as(user target.arguments, user _)
        node.m-syntax-error-msg(user "too few outputs")
    
    self.check-sub-equal(user target, user node)
  
  func inst check-equal(user TypeInstance other, user SyntaxTreeNode node)
    if self.type-data != other.type-data
      node.m-syntax-error2(
          user "non matching types",
          user self.type-data.name,
          user "and",
          user other.type-data.name)
    self.check-sub-equal(user other, user node)
  
  func inst check-sub-equal(user TypeInstance target, user SyntaxTreeNode node)
    if not (? target.sub-types)
      return
    user ListNode{TypeInstance} target-sub-type(target.sub-types.first)
    if not (? self.sub-types)
      node.m-syntax-error2(
          user "cannot assign type",
          user self.type-data.name,
          user "with no parameter into same type with parameter",
          user target-sub-type.item.type-data.name)
    
    user ListNode{TypeInstance} my-sub-type(self.sub-types.first)
    do
      while ? target-sub-type
      if not (? my-sub-type)
        node.m-syntax-error2(
            user "cannot assign type",
            user self.type-data.name,
            user "with parameters into same type with more parameters",
            user target-sub-type.item.type-data.name)
      if my-sub-type.item.type-data != target-sub-type.item.type-data
        node.m-syntax-error2(
            user "non matching subtypes",
            user my-sub-type.item.type-data.name,
            user "and",
            user target-sub-type.item.type-data.name)
      my-sub-type.item.check-sub-equal(user target-sub-type.item, user node)
      my-sub-type := my-sub-type.next
      target-sub-type := target-sub-type.next
    
  func inst check-sequence(user SyntaxTreeNode node)
    if (self.type-data = glob.type-array or
        self.type-data = glob.type-string) and not (? self.length)
      node.m-syntax-error-msg(user "missing length for sequence")
    if self.type-data = glob.type-array and
        self.sub-types.first.item.type-data = glob.type-string and
        not (? self.sub-types.first.item.length)
      node.m-syntax-error-msg(user "missing length for sequence")
