## MR4 compiler - Type instance

## Specific usage of a type including the assigned subtypes and values
static TypeInstance
  owner String name
  user TypeData type-data
  owner TypeInstance sub-type
  owner Expression length-owner
  user Expression length
  owner FunctionArguments arguments
  
  ## Return a new deep-copy of self
  func inst copy-new():(owner TypeInstance type-instance)
    if not (? self)
      type-instance := _
      return
    self.type-data.m-new-type-instance():(owner type-instance)
    string-new-copy(user self.name):(owner type-instance.name)
    type-instance.length := self.length
    if ? self.sub-type
      self.sub-type.copy-new():(owner type-instance.sub-type)
    if ? self.arguments
      self.arguments.copy-new():(owner type-instance.arguments)
  
  func inst parse(
      user String ends,
      user SyntaxTreeNode node,
      user SyntaxTreeCode code-node):(
      copy Char end)
    user String name
    read-until(user string-new-concat(user ends, user "{"), copy false):(
        user name, copy end)
    self.parse-name(user name, user node, user code-node):(copy end)
  
  func inst parse-name(
      user String name,
      user SyntaxTreeNode node,
      user SyntaxTreeCode code-node):(
      copy Char end)
    string-new-copy(user name):(owner self.name)
    if end = '{'
      if self.name.equal(user "Func")
        read-c():(copy end)
        if end != '('
          node.m-syntax-error-c(
              user "expected \"(\" inside Function type, got", copy end)
        new FunctionArguments in self.arguments
        var DeclarationArgumentFactory argument-factory
        self.arguments.parse(user argument-factory, user code-node):(copy end)
      else-if ? code-node and self.name.equal(user "String")
        parse-new-expression(user "}", user code-node):(
            owner self.length-owner, copy end)
        self.length := self.length-owner
      else
        var Bool has-sub-type(true)
        if ? code-node and self.name.equal(user "Array")
          parse-new-expression(user ":}", user code-node):(
              owner self.length-owner, copy end)
          self.length := self.length-owner
          if end != ':' and end != '}'
            node.m-syntax-error-c(user "expected \":\", got", copy end)
          has-sub-type := end = ':'
        if has-sub-type
          new TypeInstance in self.sub-type
          self.sub-type.parse(user "}", user node, user code-node):(copy end)
      if end != '}'
        node.m-syntax-error-c(user "expected \"}\", got", copy end)
      read-c():(copy end)
  
  func inst analyze(user SyntaxTreeNode node)
    self.analyze-part(user node, copy true, copy true)
  
  func inst link-types(user SyntaxTreeNode node)
    self.analyze-part(user node, copy true, copy false)
  
  func inst analyze-lengths(user SyntaxTreeNode node)
    self.analyze-part(user node, copy false, copy true)
  
  func inst analyze-part(
      user SyntaxTreeNode node, copy Bool check-types, copy Bool check-length)
    if check-types
      if not (? self.type-data)
        node.find-type(user self.name):(user self.type-data)
      if ? self.arguments
        self.arguments.link-types()
    if check-length
      if ? self.length
        node.analyze-expression(user self.length, user glob.type-int)
      if ? self.arguments
        self.arguments.analyze()
    if ? self.sub-type
      self.sub-type.analyze-part(user node, copy check-types, copy check-length)
    if check-types
      if self.type-data = glob.type-array
        if not (? self.sub-type)
          node.m-syntax-error-msg(user "missing subtype for array")
        if self.sub-type.type-data = glob.type-array
          node.m-syntax-error-msg(
              user "multidimensional array not supported yet...")
      else-if self.type-data = glob.type-func and not (? self.arguments)
        node.m-syntax-error-msg(user "missing arguments in function type")
  
  func inst check-assign-from(user SyntaxTreeNode node):(
      owner Expression value)
    var Int bases
    value.result-type.check-assign-to(user self, user node):(copy bases)
    if bases > 0
      UpCastExpression.init-new(var _, copy bases):(owner value)
  
  func inst check-assign-to(
      user TypeInstance target, user SyntaxTreeNode node):(copy Int bases)
    bases := 0
    if not (? self)
      node.m-syntax-error-msg(user "cannot assign void expression")
    if not (? target)
      node.m-syntax-error-msg(user "cannot assign into void expression")
    if self.type-data = glob.type-empty and
        (not target.type-data.is-primitive or target.type-data = glob.type-func)
      return
    user TypeData base-type(self.type-data)
    do
      while not target.type-data.m-is-same(user base-type)
      if not (? base-type.base-type)
        node.m-syntax-error2(
            user "cannot assign",
            user self.type-data.name,
            user "into",
            user target.type-data.name)
      base-type := base-type.base-type
      bases += 1
    
    if ? self.arguments
      if self.arguments.check-same-as(user target.arguments)
        node.m-syntax-error-msg(user "too few outputs")
    
    self.check-sub-equal(user target, user node)
  
  func inst check-equal(user TypeInstance other, user SyntaxTreeNode node)
    if self.type-data != other.type-data
      node.m-syntax-error2(
          user "non matching types",
          user self.type-data.name,
          user "and",
          user other.type-data.name)
    self.check-sub-equal(user other, user node)
  
  func inst check-sub-equal(user TypeInstance other, user SyntaxTreeNode node)
    if ? self.sub-type
      if ? other.sub-type
        if self.sub-type.type-data != other.sub-type.type-data
          node.m-syntax-error2(
              user "non matching subtypes",
              user self.sub-type.type-data.name,
              user "and",
              user other.sub-type.type-data.name)
        self.sub-type.check-sub-equal(user other.sub-type, user node)
      else
        node.m-syntax-error2(
            user "non matching subtypes",
            user self.sub-type.type-data.name,
            user "and type with no subtype",
            user other.type-data.name)
    else-if ? other.sub-type
      node.m-syntax-error2(
          user "non matching type with no subtype",
          user self.type-data.name,
          user "and subtype",
          user other.sub-type.type-data.name)
    
  func inst check-sequence(user SyntaxTreeNode node)
    if (self.type-data = glob.type-array or
        self.type-data = glob.type-string) and not (? self.length)
      node.m-syntax-error-msg(user "missing length for sequence")
    if self.type-data = glob.type-array and
        self.sub-type.type-data = glob.type-string and
        not (? self.sub-type.length)
      node.m-syntax-error-msg(user "missing length for sequence")
  
  func inst write()
    write(user self.type-data.name)
    if ? self.sub-type
      write(user "{")
      self.sub-type.write()
      write(user "}")
