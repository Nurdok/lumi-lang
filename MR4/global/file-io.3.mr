## MR4 compiler - File read and write functions

## Proxy functions to be mocked in tests
func file-getc(user File file):(copy Char ch)
  file.getc():(copy ch)

func file-write(user File file, user String text)
  file.write(user text)


## Read a single character from the input file
func read-c():(copy Char ch)
  file-getc(user glob.input-file):(copy ch)
  if ch = '\n'
    glob.line-number += 1


## Expect `expected-text` to be read exaclty from the input file
func read-expect(user String expected-text)
  new String{expected-text.length + 1} actual-text
  for n in expected-text.length
    actual-text.append(copy read-c())
  if not actual-text.equal(user expected-text)
    f-syntax-error2(
        user "expected", user expected-text, user "got", user actual-text)
  delete actual-text


## Read and check indentation spaces for a line break from the input file
func read-line-break-spaces()
  for n in glob.spaces + 4
    if read-c() != ' '
      var String{128} expected-spaces
      var String{128} actual-spaces
      Int.str(var glob.spaces + 4, user expected-spaces)
      Int.str(var n - 1, user actual-spaces)
      f-syntax-error2(
          user "too short indentation, expected",
          user expected-spaces,
          user "got",
          user actual-spaces)


## Read from the input file to `text` until a new-line, EOF, or one of the
## characters in `ends` is reached, and return the end character in `end`.
## If `indent` is true, ignore and count trailing spaces.
func read-until(user String text, user String ends, copy Bool indent):(
    copy Char end, copy Int spaces)
  text.clear()
  var Char ch(EOF)
  var Char quote('\0')
  spaces := 0
  read-c():(copy ch)
  if indent
    # ignore and count indent
    do
      while ch = ' '
      spaces += 1
      read-c():(copy ch)
  do
    while ch != EOF and ch != '\n'
    if quote = '\0'
      while not ends.has(copy ch)
      if ch = '\'' or ch = '"'
        quote := ch
    else-if ch = '\\'
      text.append(copy ch)
      read-c():(copy ch)
    else-if ch = quote
      quote := '\0'
    text.append(copy ch)
    read-c():(copy ch)
  end := ch


## Return in `new-text` a new allocated string read using `read-until`.
func read-new(user String ends):(owner String new-text, copy Char end)
  var String{256} text
  read-until(user text, user ends, copy false):(copy end)
  string-new-copy(user text):(owner new-text)


## Access values
var Int ACCESS-COPY(0)
var Int ACCESS-USER(1)
var Int ACCESS-OWNER(2)
var Int ACCESS-VAR(3)

func get-access(user String access-str):(copy Int access)
  if access-str.equal(user "copy")
    access := 0
  else-if access-str.equal(user "user")
    access := 1
  else-if access-str.equal(user "owner")
    access := 2
  else-if access-str.equal(user "var")
    access := 3
  else
    f-syntax-error(user "illegal access", user access-str)


## write `text` to the output file
func write(user String text)
  file-write(user glob.output-file, user text)


## write `num` to the output file as text
func write-int(copy Int num)
  var String{64} num-str
  num.str(user num-str)
  write(user num-str)
