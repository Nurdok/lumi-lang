(## MR4 compiler - Expression

Expression is a basic class for all expression types.
For each part of an expression (variable, constant, function call, etc..) there
is a class that expends the basic expression type and handles its unique logic.
From a complex expression an expression tree is generated, with types such
operators and slices that contain sub-expression inside.

For example, `array[4] + 3` expression is parsed as:
BinaryExpression:
  operator: +
  left: SliceExpression:
    sequence: SymbolExpression(array)
    index: IntExpression(4)
  right: IntExpression(3)
#)

## Return in `expression` a new allocated expression parsed from the input
## file until one of the characters in `ends` is reached.
## Return the end character in `end`
func parse-new-expression(user String ends, user SyntaxTreeCode code-node):(
    owner Expression expression, copy Char end)
  Expression.parse-new(
      var _, user ends, user code-node, user _):(owner expression, copy end)


## Meta type for an expression in the language.
## Currently only the parsing is fully implemented, `write` is implemented only
## for testing.
class Expression(SyntaxTreeNode)
  user SyntaxTreeCode code-node
  owner TypeInstance result-type
  var Bool assignable
  var Bool top
  var Bool is-statement
  
  ## Parse any expression
  func inst parse-new(
      user String ends,
      user SyntaxTreeCode code-node,
      user Operator curr-operator):(
      owner Expression expression,
      copy Char end,
      user Operator operator)
    expression := _
    var Bool multi-operands(not ends.has(copy ' '))
    owner String text
    self.read-new-value(user ends):(owner text, copy end)
    glob.operator-map.find(user text):(user operator)
    if ? operator
      if not multi-operands
        code-node.m-syntax-error(user "unexpected operator", user operator.name)
      UnaryExpression.parse-new(
          var _, user ends, user operator, user code-node):(
          owner expression, copy end, user operator)
    else
      self.parse-new-operand(owner text, user ends, user code-node):(
          owner expression, copy end)
      if multi-operands and end = ' '
        self.read-new-value(user ends):(owner text, copy end)
        glob.operator-map.find(user text):(user operator)
        if not (? operator)
          code-node.m-syntax-error(user "unknown operator", user text)
    user BinaryExpression binary-left-expression
    do
      while ? operator and
          (not (? curr-operator) or operator.order < curr-operator.order)
      owner BinaryExpression new-binary-expression
      BinaryExpression.parse-new(
          var _,
          user ends,
          user operator,
          user code-node,
          owner expression,
          user binary-left-expression):(
          owner new-binary-expression,
          copy end,
          user operator)
      binary-left-expression := new-binary-expression
      expression := new-binary-expression
    if not (? curr-operator)
      expression.top := true
  
  ## Read a single expression value as new string
  func inst read-new-value(user String ends):(owner String text, copy Char end)
    owner String all-ends
    string-new-concat(user " .[({?", user ends):(owner all-ends)
    read-new(user all-ends):(owner text, copy end)
    delete all-ends
  
  ## Parse an expression that is an operand
  func inst parse-new-operand(
      owner String text, user String ends, user SyntaxTreeCode code-node):(
      owner Expression expression, copy Char end)
    if text.length = 0
      if end = '('
        BlockExpression.parse-new(var _, user code-node):(
            owner expression, copy end)
      else
        code-node.m-syntax-error-c(user "unexpected", copy end)
      delete text
    else
      self.parse-new-init-operand(owner text, user code-node):(
          owner expression, copy end)
    
    do
      if end = '?'
        QuestionExpression.parse-new(var _):(owner expression, copy end)
      while self.parse-new-follow-operand(user ends, user code-node):(
          owner expression, copy end)
  
  ## Parse the initialize part of an operand expression
  func inst parse-new-init-operand(
      owner String text, user SyntaxTreeCode code-node):(
      owner Expression expression, copy Char end)
    var Char first(text[0])
    var Char second('\0')
    if text.length > 1
      second := text[1]
    if first = '\''
      CharExpression.parse-new(var _, owner text):(owner expression)
    else-if first = '"'
      StringExpression.parse-new(var _, owner text, user code-node):(
          owner expression)
    else-if (first >= '0' and first <= '9') or
        (first = '-' and second >= '0' and second <= '9')
      IntExpression.parse-new(var _, owner text):(owner expression)
    else-if first >= 'A' and first <= 'Z' and second >= 'a' and second <= 'z'
      TypeExpression.parse-new(var _, owner text, user code-node):(
          owner expression, copy end)
    else-if text.length = 1 and first = '_'
      EmptyExpression.parse-new(var _, owner text):(owner expression)
    else-if text.equal(user "base")
      BaseMethExpression.parse-new(
          var _, owner text, user code-node, copy end):(owner expression)
    else
      SymbolExpression.parse-new(var _, owner text, user code-node):(
          owner expression)
  
  ## Parse one following part of an operand
  func inst parse-new-follow-operand(
      user String ends, user SyntaxTreeCode code-node):(
      owner Expression expression, copy Char end, copy Bool has-more)
    has-more := true
    if end = '.'
      MemberExpression.parse-new(var _, user ends, user code-node):(
          owner expression, copy end)
    else-if end = '['
      SliceExpression.parse-new(var _, user ends, user code-node):(
          owner expression, copy end)
    else-if end = '('
      CallExpression.parse-new(var _, user ends, user code-node):(
          owner expression, copy end)
    else
      has-more := false
  
  ## Set type instance to be a type that has no sub-type
  func inst set-simple-type(user TypeData type-data)
    type-data.m-new-type-instance():(owner self.result-type)
  
  func inst add-aux-variable(copy Int access, user TypeInstance type-instance):(
      owner SymbolExpression symbol)
    new SymbolExpression in symbol
    symbol.code-node := self.code-node
    type-instance.copy-new():(owner symbol.result-type)
    symbol.assignable := true
    self.code-node.get-function().add-aux-variable(
        copy access, user type-instance):(user symbol.variable)
    string-new-copy(user symbol.variable.name):(owner symbol.name)
  
  func inst write-ref-init(user SymbolExpression symbol)
    # `symbol` = MR_new_ref();
    # if (`symbol` == NULL) raise(`line-num`)
    symbol.write()
    write(user " = MR_new_ref();\n")
    self.code-node.write-spaces()
    write(user "if (")
    symbol.write()
    write(user " == NULL) ")
    self.write-raise()
  
  func inst write-init-var-ref(user SymbolExpression symbol)
    # &`symbol`_Var;
    self.code-node.write-spaces()
    write(user "*")
    symbol.write()
    write(user " = &")
    symbol.write()
    write(user "_Var;\n")
  
  func dynamic write-dynamic()
    self.write()
    write(user "_Dynamic")
  
  func dynamic analyze-call(user FunctionArguments arguments):(
      copy Bool is-function-object)
    is-function-object := true
  
  func dynamic write-preactions()
    # do noting
