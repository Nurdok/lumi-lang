(## MR4 compiler - Expression

Expression is a basic class for all expression types.
For each part of an expression (variable, constant, function call, etc..) there
is a class that expends the basic expression type and handles its unique logic.
From a complex expression an expression tree is generated, with types such
operators and slices that contain sub-expression inside.

For example, `array[4] + 3` expression is parsed as:
Binary-expression:
  operator: +
  left: Slice-expression:
    sequence: Variable-expression(array)
    index: Int-expression(4)
  right: Int-expression(3)
#)

## Return in `expression` a new allocated expression parsed from the input
## file until one of the characters in `ends` is reached.
## Return the end character in `end`
func parse-new-expression(user String ends):(
    owner Expression expression, copy Char end)
  Expression.parse-new(var _, user ends):(owner expression, copy end)


## Meta type for an expression in the language.
## Currently only the parsing is fully implemented, `write` is implemented only
## for testing.
class Expression
  owner Type-instance result-type
  
  ## Parse any expression
  func inst parse-new(user String ends):(
      owner Expression expression, copy Char end)
    expression := _
    var Bool multi-operands(not ends.has(copy ' '))
    do
      owner String text
      self.read-new-value(user ends):(owner text, copy end)
      
      user Operator operator
      glob.operator-map.find(user text):(user operator)
      if ? operator
        if not multi-operands
          f-syntax-error(user "unexpected operator", user operator.name)
        self.parse-new-operator(user operator, copy multi-operands, user ends):(
            owner expression, copy end)
      else
        if ? expression
          f-syntax-error(user "unknown operator", user text)
        self.parse-new-operand(owner text, user ends):(
            owner expression, copy end)
       
      while multi-operands and end = ' '
  
  ## Read a single expression value as new string
  func inst read-new-value(user String ends):(owner String text, copy Char end)
    owner String all-ends
    f-new-concat(user " .[(?", user ends):(owner all-ends)
    read-new(user all-ends):(owner text, copy end)
    delete all-ends
  
  ## Parse an expression with an operator
  func inst parse-new-operator(
      user Operator operator, copy Bool multi-operands, user String ends):(
      owner Expression expression, copy Char end)
    if (end != ' ' and end != '\n')
      f-syntax-error-c(user "unexpected", copy end)
    if ? expression
      Binary-expression.parse-new(var _, user ends, user operator):(
          owner expression, copy end)
    else
      Unary-expression.parse-new(var _, user ends, user operator):(
          owner expression, copy end)
  
  ## Parse an expression that is an operand
  func inst parse-new-operand(owner String text, user String ends):(
      owner Expression expression, copy Char end)
    if text.length = 0
      if end = '('
        Block-expression.parse-new(var _):(owner expression, copy end)
      else
        f-syntax-error-c(user "unexpected", copy end)
      delete text
    else
      self.parse-new-init-operand(owner text):(owner expression)
    
    do
      if end = '?'
        Question-expression.parse-new(var _):(owner expression, copy end)
      while self.parse-new-follow-operand(user ends):(
          owner expression, copy end)
  
  ## Parse the initialize part of an operand expression
  func inst parse-new-init-operand(
      owner String text):(owner Expression expression)
    var Char first(text[0])
    var Char second('\0')
    if text.length > 1
      second := text[1]
    if first = '\''
      Char-expression.parse-new(var _, owner text):(owner expression)
    else-if first = '"'
      String-expression.parse-new(var _, owner text):(owner expression)
    else-if (first >= '0' and first <= '9') or
        (first = '-' and second >= '0' and second <= '9')
      Int-expression.parse-new(var _, owner text):(owner expression)
    else-if first >= 'A' and first <= 'Z' and second >= 'a' and second <= 'z'
      Type-expression.parse-new(var _, owner text):(owner expression)
    else-if text.length = 1 and first = '_'
      Empty-expression.parse-new(var _, owner text):(owner expression)
    else-if text.equal(user "base")
      Base-meth-expression.parse-new(var _, owner text):(owner expression)
    else
      Variable-expression.parse-new(var _, owner text):(owner expression)
  
  ## Parse one following part of an operand
  func inst parse-new-follow-operand(user String ends):(
      owner Expression expression, copy Char end, copy Bool has-more)
    has-more := true
    if end = '.'
      Member-expression.parse-new(var _, user ends):(owner expression, copy end)
    else-if end = '['
      Slice-expression.parse-new(var _, user ends):(owner expression, copy end)
    else-if end = '('
      Call-expression.parse-new(var _, user ends):(owner expression, copy end)
    else
      has-more := false
  
  ## Set type instance to be a type that has no sub-type
  func inst set-simple-type(user Type-data type-data)
    new Type-instance in self.result-type
    self.result-type.type-data := type-data
  
  ## write to C - currently inly used in testing
  func dynamic write()
    # should be implemented by each specific expression type
    raise


## A basic expression that has a single textual value
class Text-expression(Expression)
  owner String text
  
  func dynamic write()
    self.write-text(user self.result-type.type-data.name)
  
  func inst write-text(user String type-name)
    write(user type-name)
    write(user "(")
    write(user self.text)
    write(user ")")
