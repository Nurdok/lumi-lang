## MR4 compiler - Symbol expression

## A single symbol expression (variable or global-function)
class SymbolExpression(Expression)
  owner String name
  user SyntaxTreeVariable variable
  user SyntaxTreeFunction function
  
  func inst parse-new(owner String text, user SyntaxTreeCode code-node):(
      owner Expression expression)
    new SymbolExpression symbol-expression
    symbol-expression.parse(owner text, user code-node)
    expression := symbol-expression
  
  ## parsing `symbol`
  func inst parse(owner String text, user SyntaxTreeCode code-node)
    self.code-node := code-node
    self.name := text
    self.set-location()
  
  func dynamic analyze()
    self.code-node.m-find-variable(user self.name):(user self.variable)
    if ? self.variable
      self.variable.type-instance.m-copy-new():(owner self.result-type)
      self.assignable := true
    else
      glob.root.m-find-function(user self.name):(user self.function)
      if not (? self.function)
        self.m-syntax-error(user "unknown symbol", user self.name)
      self.set-simple-type(user glob.type-func)
      self.function.arguments.m-copy-new():(self.result-type.arguments)
  
  func dynamic write()
    if ? self.variable and self.variable.is-output
      write(user "(*")
    write-cname(user self.name)
    if ? self.variable and self.variable.is-output
      write(user ")")


## Type name expression
class TypeExpression(Expression)
  owner String type-name
  
  func inst parse-new(owner String text):(owner Expression expression)
    new TypeExpression type-expression
    type-expression.parse(owner text)
    expression := type-expression
  
  ## parsing `Type-name`
  func inst parse(owner String text)
    self.type-name := text
    self.set-location()
  
  func dynamic analyze()
    self.set-simple-type(user glob.type-type)
    self.m-find-type(user self.type-name).m-new-type-instance():(
        owner self.result-type.sub-type)
  
  func dynamic write()
    write-cname(user self.result-type.sub-type.type-data.name)


## The `base` method expression
class BaseMethExpression(Expression)
  func inst parse-new(owner String text, user SyntaxTreeCode code-node):(
      owner Expression expression)
    new BaseMethExpression in expression
    expression.code-node := code-node
    expression.set-location()
    delete text
  
  func dynamic analyze()
    user TypeData parent-type
    self.code-node.m-get-parent-type():(user parent-type)
    if not (? parent-type)
      self.m-syntax-error-msg(user "\"base\" used not in method")
    if not (? parent-type.base-type)
      self.m-syntax-error(user "no base type for type", user parent-type.name)
    self.set-simple-type(user parent-type.base-type)
  
  func dynamic write()
    write(user "(&(self->_base))")


## An instance member expression
class MemberExpression(SymbolExpression)
  owner Expression instance
  
  func inst parse-new(user String ends):(
      owner Expression expression, copy Char end)
    new MemberExpression member-expression
    member-expression.parse(owner expression, user ends):(copy end)
    expression := member-expression
  
  ## parsing `instance.symbol`
  func inst parse(owner Expression instance, user String ends):(copy Char end)
    self.instance := instance
    self.set-location()
    self.read-new-value(user ends):(owner self.name, copy end)
  
  func dynamic analyze()
    self.instance.analyze()
    self.assignable := self.instance.assignable
    if not (? self.instance.result-type) or
        not (? self.instance.result-type.type-data)
      self.m-syntax-error(user "void expression has no member", user self.name)
    user TypeData type-data(self.instance.result-type.type-data)
    if self.instance.result-type.type-data = glob.type-type
      if not (? self.instance.result-type.sub-type) or
          not (? self.instance.result-type.sub-type.type-data)
        self.m-syntax-error(
            user "unspecified type has no member", user self.name)
      type-data := self.instance.result-type.sub-type.type-data
    
    type-data.m-find-field(user self.name):(user self.variable)
    if ? self.variable
      self.variable.type-instance.m-copy-new():(owner self.result-type)
      self.assignable := true
    else
      type-data.m-find-meth(user self.name):(user self.function)
      if not (? self.function)
        self.m-syntax-error2(
            user "type",
            user type-data.name,
            user "has no member",
            user self.name)
      self.set-simple-type(user glob.type-func)
      self.function.arguments.m-copy-new():(owner self.result-type.arguments)
  
  func dynamic analyze-call(user FunctionArguments arguments)
    if self.instance.result-type.type-data = glob.type-type
      return
    new CallArgument self-param
    self-param.access := self.function.arguments.parameters.first.item.access
    self-param.value := self.instance
    arguments.parameters.m-prepend(owner self-param)
    new TypeExpression in self.instance
    self.instance.set-simple-type(user glob.type-type)
    self-param.value.result-type.type-data.m-new-type-instance():(
        owner self.instance.result-type.sub-type)
  
  func dynamic write-preactions()
    self.instance.write-preactions()
  
  func dynamic write()
    self.instance.write()
    if self.instance.result-type.type-data = glob.type-type
      write(user "_")
    else
      write(user "->")
    base.write()
