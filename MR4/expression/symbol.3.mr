## MR4 compiler - Symbol expression

## A single symbol expression (variable or global-function)
class SymbolExpression(Expression)
  owner String name
  user SyntaxTreeVariable variable
  user SyntaxTreeFunction function
  
  func inst parse-new(owner String text, user SyntaxTreeCode code-node):(
      owner Expression expression)
    new SymbolExpression symbol-expression
    symbol-expression.parse(owner text, user code-node)
    expression := symbol-expression
  
  ## parsing `symbol`
  func inst parse(owner String text, user SyntaxTreeCode code-node)
    self.code-node := code-node
    self.name := text
    self.set-location()
  
  func dynamic analyze()
    self.code-node.find-variable(user self.name):(user self.variable)
    if ? self.variable
      self.variable.type-instance.copy-new():(owner self.result-type)
      self.access := self.variable.access
      self.assignable := true
    else
      glob.root.find-function(user self.name):(user self.function)
      if not (? self.function)
        self.m-syntax-error(user "unknown symbol", user self.name)
      self.set-simple-type(user glob.type-func)
      self.access := ACCESS-VAR
      self.function.arguments.copy-new():(owner self.result-type.arguments)
  
  func dynamic analyze-call(user FunctionArguments arguments):(
      user TypeInstance instance-type,
      copy Int bases,
      copy Bool is-function-object)
    is-function-object := ? self.variable
    bases := 0
    instance-type := _
  
  func dynamic write()
    if ? self.function
      if ? self.function.mocker-function
        self.function.mocker-function.write-cname()
      else
        self.function.write-cname()
      return
    if ? self.variable and self.variable.is-output
      if not self.top
        write(user "(")
      write(user "*")
    write-cname(user self.name)
    if ? self.variable and self.variable.is-output and not self.top
      write(user ")")
  
  func dynamic write-dynamic()
    if ? self.variable and self.variable.is-output and not self.top
      write(user "(*")
      write-cname(user self.name)
      write(user "_Dynamic)")
    else
      base.write-dynamic()
  
  func dynamic write-refman()
    if ? self.variable and self.variable.is-output and not self.top
      write(user "(*")
      write-cname(user self.name)
      write(user "_Refman)")
    else
      base.write-refman()

## An instance member expression
class MemberExpression(SymbolExpression)
  owner Expression instance
  user Expression dynamic-call-self-instance
  var Int bases
  var Bool is-dynamic-call
  var Bool is-generic-cast
  
  func inst parse-new(user String ends, user SyntaxTreeCode code-node):(
      owner Expression expression, copy Char end)
    new MemberExpression member-expression
    member-expression.parse(owner expression, user ends, user code-node):(
        copy end)
    expression := member-expression
  
  ## parsing `instance.symbol`
  func inst parse(
      owner Expression instance,
      user String ends,
      user SyntaxTreeCode code-node):(
      copy Char end)
    self.code-node := code-node
    self.instance := instance
    self.set-location()
    self.read-new-value(user ends):(owner self.name, copy end)
  
  func dynamic analyze()
    self.instance.analyze()
    self.assignable := self.instance.assignable
    user TypeInstance instance-type(self.instance.result-type)
    if not (? instance-type) or not (? instance-type.type-data)
      self.m-syntax-error(user "void expression has no member", user self.name)
    if instance-type.type-data = glob.type-type
      instance-type := instance-type.parameters.first.item
    else-if instance-type.type-data = glob.type-base
      instance-type := instance-type.parameters.first.item.type-data.base-type
    
    instance-type.type-data.find-field(user self.name):(
        user self.variable, copy self.bases)
    if ? self.variable
      self.is-generic-cast :=
          self.variable.type-instance.type-data = glob.type-generic
      self.variable.type-instance.f-new-replace-params(
          user instance-type, copy self.bases):(owner self.result-type)
      self.access := self.variable.access
      self.assignable := true
    else
      instance-type.type-data.find-meth(user self.name):(
          user self.function, copy self.bases)
      if not (? self.function)
        self.m-syntax-error2(
            user "type",
            user instance-type.type-data.name,
            user "has no member",
            user self.name)
      if self.function.is-dynamic and
          self.instance.result-type.type-data != glob.type-type and
          self.instance.result-type.type-data != glob.type-base
        self.bases := self.function.dynamic-base-count
        self.function := self.function.dynamic-base-method
        self.is-dynamic-call := true
      self.set-simple-type(user glob.type-func)
      self.access := ACCESS-VAR
      self.function.arguments.copy-new():(owner self.result-type.arguments)
    if self.instance.result-type.type-data = glob.type-base
      if not (? self.function)
        self.m-syntax-error(
            user "calling \"base\" with non-method", user self.name)
      owner TypeInstance base-result-type(self.instance.result-type)
      self.instance.result-type := base-result-type.parameters.first.item
      delete base-result-type
  
  func dynamic analyze-call(user FunctionArguments arguments):(
      user TypeInstance instance-type,
      copy Int bases,
      copy Bool is-function-object)
    if base.analyze-call(user arguments):(
        user instance-type, copy bases, copy is-function-object)
      return
    bases := self.bases
    if self.instance.result-type.type-data = glob.type-type
      instance-type := self.instance.result-type.parameters.first.item
    else
      instance-type := self.instance.result-type
      new CallArgument self-param
      self-param.access := self.function.arguments.parameters.first.item.access
      self-param.value := self.instance
      self-param.value.top := true
      arguments.parameters.prepend(owner self-param)
      if self.is-dynamic-call
        self.dynamic-call-self-instance := self.instance
    self.instance := _
  
  func dynamic write-preactions()
    if ? self.instance
      self.instance.write-preactions()
    if not (? self.dynamic-call-self-instance or
        (? self.instance and not (? self.function) and
        self.instance.result-type.type-data != glob.type-type))
      return
    # if (...) RAISE(`line-num`)
    write(user "if (")
    if ? self.instance
      # `instance` == NULL[ || `instance`_Refman->value == NULL]
      self.instance.write-validate-ref()
    else-if ? self.dynamic-call-self-instance
      # `instance`_Dynamic == NULL
      self.dynamic-call-self-instance.top := true
      self.dynamic-call-self-instance.write-dynamic()
      self.dynamic-call-self-instance.top := false
      write(user " == NULL")
    write(user ") ")
    self.write-raise()
    self.code-node.write-spaces()
  
  func dynamic write()
    if ? self.dynamic-call-self-instance
      self.dynamic-call-self-instance.write-dynamic()
      self.write-bases()
      write-cname(user self.function.name)
      return
    if self.is-generic-cast and not self.top
      write(user "((")
      write-cname(user self.result-type.type-data.name)
      write(user "*)(")
    if ? self.instance and not (? self.function) and
        self.instance.result-type.type-data != glob.type-type
      self.instance.write()
      self.write-bases()
    base.write()
    if self.is-generic-cast and not self.top
      write(user "))")
  
  func dynamic write-refman()
    var Bool top(self.top)
    if self.is-generic-cast and not self.top
      self.top := true
    base.write-refman()
    self.top := top
  
  func inst write-bases()
    write(user "->")
    for n in self.bases
      write(user "_base.")
