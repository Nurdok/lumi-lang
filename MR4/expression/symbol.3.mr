## MR4 compiler - Symbol expression

## A single symbol expression (variable or global-function)
class SymbolExpression(Expression)
  owner String name
  user SyntaxTreeVariable variable
  user SyntaxTreeFunction function
  
  func inst parse-new(owner String text, user SyntaxTreeCode code-node):(
      owner Expression expression)
    new SymbolExpression symbol-expression
    symbol-expression.parse(owner text, user code-node)
    expression := symbol-expression
  
  ## parsing `symbol`
  func inst parse(owner String text, user SyntaxTreeCode code-node)
    self.code-node := code-node
    self.name := text
    self.set-location()
  
  func dynamic analyze()
    self.code-node.find-variable(user self.name):(user self.variable)
    if ? self.variable
      self.variable.type-instance.copy-new():(owner self.result-type)
      self.assignable := true
    else
      glob.root.find-function(user self.name):(user self.function)
      if not (? self.function)
        self.m-syntax-error(user "unknown symbol", user self.name)
      self.set-simple-type(user glob.type-func)
      self.function.arguments.copy-new():(owner self.result-type.arguments)
  
  func dynamic analyze-call(user FunctionArguments arguments):(
      copy Bool is-function-object)
    is-function-object := ? self.variable
  
  func dynamic write()
    if ? self.function
      if ? self.function.mocker-function
        self.function.mocker-function.write-cname()
      else
        self.function.write-cname()
      return
    if ? self.variable and self.variable.is-output
      if not self.top
        write(user "(")
      write(user "*")
    write-cname(user self.name)
    if ? self.variable and self.variable.is-output and not self.top
      write(user ")")
  
  func dynamic write-dynamic()
    if ? self.variable and self.variable.is-output and not self.top
      write(user "(*")
      write-cname(user self.name)
      write(user "_Dynamic)")
    else
      base.write-dynamic()
  
  func dynamic write-refman()
    if ? self.variable and self.variable.is-output and not self.top
      write(user "(*")
      write-cname(user self.name)
      write(user "_Refman)")
    else
      base.write-refman()

## An instance member expression
class MemberExpression(SymbolExpression)
  owner Expression instance
  user Expression dynamic-call-self-instance
  var Int bases
  var Bool is-dynamic-call
  
  func inst parse-new(user String ends, user SyntaxTreeCode code-node):(
      owner Expression expression, copy Char end)
    new MemberExpression member-expression
    member-expression.parse(owner expression, user ends, user code-node):(
        copy end)
    expression := member-expression
  
  ## parsing `instance.symbol`
  func inst parse(
      owner Expression instance,
      user String ends,
      user SyntaxTreeCode code-node):(
      copy Char end)
    self.code-node := code-node
    self.instance := instance
    self.set-location()
    self.read-new-value(user ends):(owner self.name, copy end)
  
  func dynamic analyze()
    self.instance.analyze()
    self.assignable := self.instance.assignable
    if not (? self.instance.result-type) or
        not (? self.instance.result-type.type-data)
      self.m-syntax-error(user "void expression has no member", user self.name)
    user TypeData type-data(self.instance.result-type.type-data)
    if type-data = glob.type-type
      type-data := self.instance.result-type.sub-type.type-data
    else-if type-data = glob.type-base
      type-data := self.instance.result-type.sub-type.type-data.base-type
    
    type-data.find-field(user self.name):(user self.variable, copy self.bases)
    if ? self.variable
      self.variable.type-instance.copy-new():(owner self.result-type)
      self.assignable := true
    else
      type-data.find-meth(user self.name):(
          user self.function, copy self.bases)
      if not (? self.function)
        self.m-syntax-error2(
            user "type",
            user type-data.name,
            user "has no member",
            user self.name)
      if self.function.is-dynamic and
          self.instance.result-type.type-data != glob.type-type and
          self.instance.result-type.type-data != glob.type-base
        self.bases := self.function.dynamic-base-count
        self.function := self.function.dynamic-base-method
        self.is-dynamic-call := true
      self.set-simple-type(user glob.type-func)
      self.function.arguments.copy-new():(owner self.result-type.arguments)
    if self.instance.result-type.type-data = glob.type-base
      if not (? self.function)
        self.m-syntax-error(
            user "calling \"base\" with non-method", user self.name)
      owner TypeInstance base-result-type(self.instance.result-type)
      self.instance.result-type := base-result-type.sub-type
      delete base-result-type
  
  func dynamic analyze-call(user FunctionArguments arguments):(
      copy Bool is-function-object)
    if base.analyze-call(user arguments):(copy is-function-object)
      return
    if self.instance.result-type.type-data = glob.type-type
      delete self.instance
    else
      new CallArgument self-param
      self-param.access := self.function.arguments.parameters.first.item.access
      self-param.value := self.instance
      self-param.value.top := true
      arguments.parameters.prepend(owner self-param)
      if self.is-dynamic-call
        self.dynamic-call-self-instance := self.instance
    self.instance := _
  
  func dynamic write-preactions()
    if ? self.instance
      self.instance.write-preactions()
    if not (? self.dynamic-call-self-instance or
        (? self.instance and not (? self.function) and
        self.instance.result-type.type-data != glob.type-type))
      return
    # if (...) RAISE(`line-num`)
    write(user "if (")
    if ? self.instance
      # `instance` == NULL[ || `instance`_Refman->value == NULL]
      self.instance.write-validate-ref()
    else-if ? self.dynamic-call-self-instance
      # `instance`_Dynamic == NULL
      self.dynamic-call-self-instance.top := true
      self.dynamic-call-self-instance.write-dynamic()
      self.dynamic-call-self-instance.top := false
      write(user " == NULL")
    write(user ") ")
    self.write-raise()
    self.code-node.write-spaces()
  
  func dynamic write()
    if ? self.dynamic-call-self-instance
      self.dynamic-call-self-instance.write-dynamic()
      self.write-bases()
      write-cname(user self.function.name)
      return
    if ? self.instance and not (? self.function) and
        self.instance.result-type.type-data != glob.type-type
      self.instance.write()
      self.write-bases()
    base.write()
  
  func inst write-bases()
    write(user "->")
    for n in self.bases
      write(user "_base.")


## The `base` method expression
class BaseMethExpression(Expression)
  var Bool is-call
  user SyntaxTreeFunction function
  user TypeData parent-type
  
  func inst parse-new(
      owner String text, user SyntaxTreeCode code-node, copy Char end):(
      owner Expression expression)
    delete text
    new BaseMethExpression base-expression
    base-expression.init(user code-node, copy end = '(')
    expression := base-expression
  
  func inst init(user SyntaxTreeCode code-node, copy Bool is-call)
    self.code-node := code-node
    self.is-call := is-call
    self.set-location()
  
  func dynamic analyze()
    user SyntaxTreeFunction function
    self.code-node.get-function():(user function)
    self.parent-type := function.parent-type
    if not (? self.parent-type)
      self.m-syntax-error-msg(user "\"base\" used not in method")
    if not (? self.parent-type.base-type)
      self.m-syntax-error(
          user "no base type for type", user function.parent-type.name)
    if self.is-call
      self.parent-type.base-type.find-meth(user function.name):(
          user self.function)
      if not (? function)
        self.m-syntax-error(
            user "no base method for method", user function.name)
      self.set-simple-type(user glob.type-func)
      self.result-type.arguments := self.function.arguments
    else
      self.set-simple-type(user glob.type-base)
      self.parent-type.m-new-type-instance():(owner self.result-type.sub-type)
  
  func dynamic analyze-call(user FunctionArguments arguments):(
      copy Bool is-function-object)
    is-function-object := false
    new CallArgument self-param
    self-param.access := self.function.arguments.parameters.first.item.access
    new BaseMethExpression in self-param.value
    self.parent-type.m-new-type-instance():(owner self-param.value.result-type)
    arguments.parameters.prepend(owner self-param)
  
  func dynamic write()
    if self.is-call
      self.function.write-cname()
    else
      write(user "self")


## An instance member expression
class UpCastExpression(Expression)
  owner Expression expression
  var Int bases
  
  func inst init-new(copy Int bases):(owner Expression expression)
    new UpCastExpression up-cast
    up-cast.init(copy bases, owner expression)
    expression := up-cast
  
  func inst init(copy Int bases, owner Expression expression)
    self.expression := expression
    self.expression.top := false
    self.bases := bases
    self.expression.result-type.copy-new():(owner self.result-type)
  
  func dynamic write-preactions()
    self.expression.write-preactions()
  
  func dynamic write()
    # &(`expression`->_base[._base]...)
    self.write-pre()
    self.expression.write()
    self.write-post()
  
  func dynamic write-dynamic()
    self.write-pre()
    self.expression.write-dynamic()
    self.write-post()
  
  func dynamic write-refman()
    self.expression.top := true
    self.expression.write-refman()
    self.expression.top := false
  
  func inst write-pre()
    write(user "&(")
  
  func inst write-post()
    write(user "->_base")
    for n in 1:self.bases
      write(user "._base")
    write(user ")")


## Type name expression
class TypeExpression(Expression)
  func inst parse-new(owner String text, user SyntaxTreeCode code-node):(
      owner Expression expression, copy Char end)
    new TypeInstance type-instance
    type-instance.parse-name(user text, user code-node, user code-node):(
        copy end)
    if end = '('
      new InitExpression expression-init
      expression-init.parse(owner type-instance, user code-node):(copy end)
      expression := expression-init
    else
      new TypeExpression type-expression
      type-expression.parse(owner type-instance)
      expression := type-expression
  
  func inst parse(owner TypeInstance type-instance)
    self.set-location()
    self.set-simple-type(user glob.type-type)
    self.result-type.sub-type := type-instance
  
  func dynamic analyze()
    self.result-type.sub-type.analyze(user self)
  
  func dynamic write()
    write-cname(user self.result-type.sub-type.type-data.name)


## Initialization expression
class InitExpression(Expression)
  owner FunctionArguments arguments
  owner SymbolExpression symbol
  user SyntaxTreeFunction constructor
  owner Expression value
  
  func inst parse(
      owner TypeInstance result-type, user SyntaxTreeCode code-node):(
      copy Char end)
    self.code-node := code-node
    self.result-type := result-type
    self.set-location()
    new FunctionArguments in self.arguments
    if end = '('
      var CallArgumentFactory argument-factory
      self.arguments.parse(user argument-factory, user code-node):(copy end)
    else
      self.arguments.init()
  
  func dynamic analyze()
    self.result-type.analyze(user self)
    
    self.arguments.analyze()
    if ? self.symbol
      self.symbol.result-type.analyze(user self)
    else
      self.add-aux-variable(copy ACCESS-NEW, user self.result-type):(
          owner self.symbol)
    
    if self.symbol.variable.access = ACCESS-NEW and
        self.result-type.type-data.is-primitive
      self.m-syntax-error(
          user "dynamic allocation of primitive type",
          user self.result-type.type-data.name)
    
    if not self.result-type.type-data.is-primitive and
        (self.symbol.variable.access = ACCESS-VAR or
        self.symbol.variable.access = ACCESS-NEW)
      self.result-type.check-sequence(user self)
      self.result-type.type-data.find-meth(user "new"):(user self.constructor)
      if not (? self.arguments.parameters.first) and
          not (? self.arguments.outputs.first) and (not (? self.constructor) or
          self.result-type.type-data = glob.type-string)
        self.constructor := _
      else-if not (? self.constructor)
        self.m-syntax-error(
            user "no contructor for type", user self.result-type.type-data.name)
      else
        new CallArgument self-param
        self-param.access :=
            self.constructor.arguments.parameters.first.item.access
        self-param.code-node := self.code-node
        self-param.value := self.symbol
        self.arguments.parameters.prepend(owner self-param)
        self.arguments.check-same-as(user self.constructor.arguments)
      
    else-if ? self.arguments.parameters.first
      if ? self.arguments.parameters.first.next or
          ? self.arguments.outputs.first
        self.m-syntax-error-msg(
            user "only one initialization parameter expected")
      user Argument param(self.arguments.parameters.first.item)
      param.check-same-type-as(user self.result-type)
  
  func inst write-allocation()
    self.arguments.write-preactions()
    if self.result-type.type-data = glob.type-array or
        self.result-type.type-data = glob.type-string
      self.result-type.length.write-preactions()
    if self.result-type.type-data = glob.type-array and
        self.result-type.sub-type.type-data = glob.type-string
      self.result-type.sub-type.length.write-preactions()
    
    if self.symbol.variable.access = ACCESS-VAR
      self.write-var-init()
    else
      self.write-new-init()
    
    self.write-refman-init(user self.symbol)
    
    if ? self.constructor
      self.code-node.write-spaces()
      self.write-call()
      self.constructor.write-cname()
      self.arguments.write-call()
      write(user " )\n")
  
  func inst write-var-init()
    self.write-init-var-ref(user self.symbol)
    
    if self.result-type.type-data = glob.type-array or
        self.result-type.type-data = glob.type-string
      # `symbol`_Var.values = `symbol`_Values;
      self.code-node.write-spaces()
      self.symbol.write()
      write(user "_Var.values = ")
      self.symbol.write()
      write(user "_Values;\n")
      if self.result-type.type-data = glob.type-array and
          self.result-type.sub-type.type-data = glob.type-string
        # MR_set_var_string_array(
        #    `array-length`, `string-length`, `name`, `name`_Chars);
        self.code-node.write-spaces()
        write(user "MR_set_var_string_array(")
        self.result-type.length.write()
        write(user ", ")
        self.result-type.sub-type.length.write()
        write(user ", ")
        self.symbol.write()
        write(user ", ")
        self.symbol.write()
        write(user "_Chars);\n")
  
  func inst write-new-init()
    # `symbol` = ...
    self.symbol.write()
    write(user " = ")
    
    if self.result-type.type-data = glob.type-array
      if self.result-type.sub-type.type-data = glob.type-string
        # MR_new_string_array(`length`, `string-length`);
        write(user "MR_new_string_array(")
        self.result-type.length.write()
        write(user ", ")
        self.result-type.sub-type.length.write()
        
      else
        # MR_new_array(`length`, sizeof(`SubType`));
        write(user "MR_new_array(")
        self.result-type.length.write()
        write(user ", sizeof(")
        write-cname(user self.result-type.sub-type.type-data.name)
        write(user ")")
        
    else-if self.result-type.type-data = glob.type-string
      # MR_new_string(`length`);
      write(user "MR_new_string(")
      self.result-type.length.write()
      
    else
      # calloc(1, sizeof(`type`));
      write(user "calloc(1, sizeof(")
      write-cname(user self.result-type.type-data.name)
      write(user ")")
    
    write(user ");\n")
    
    # if (`symbol` == NULL) raise(`line-num`)
    self.code-node.write-spaces()
    write(user "if (")
    self.symbol.write()
    write(user " == NULL) ")
    self.write-raise()
  
  func inst write-assign()
    # `name` = `value`;
    user Expression value
    self.arguments.parameters.first.item.get-output():(user value)
    self.code-node.write-spaces()
    value.write-preactions()
    self.symbol.write()
    write(user " = ")
    value.write()
    write(user ";\n")
    
    if not self.result-type.type-data.is-primitive
      # `name`_Refman = `value`_Refman;
      self.code-node.write-spaces()
      self.symbol.write()
      write(user "_Refman = ")
      value.write-refman()
      write(user ";\n")
    
    if self.result-type.type-data.is-dynamic
      # `name`_Dynamic = `Type`_Dynamic;
      self.code-node.write-spaces()
      self.symbol.write()
      write(user "_Dynamic = ")
      value.write-dynamic()
      write(user ";\n")
  
  func dynamic write-preactions()
    self.write-allocation()
    self.code-node.write-spaces()
  
  func dynamic write()
    if self.is-statement
      if not self.result-type.type-data.is-primitive and
          (self.symbol.variable.access = ACCESS-VAR or
          self.symbol.variable.access = ACCESS-NEW)
        self.code-node.write-spaces()
        self.write-allocation()
      else-if ? self.arguments.parameters.first
        self.write-assign()
    else
      self.symbol.write()
