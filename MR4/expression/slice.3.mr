## MR4 compiler - Slice expression

## A slice expression
class SliceExpression(Expression)
  owner Expression sequence
  owner Expression index
  owner Expression second-index
  
  func inst parse-new(user String ends, user SyntaxTreeCode code-node):(
      owner Expression expression, copy Char end)
    new SliceExpression slice-expression
    slice-expression.parse(owner expression, user code-node):(copy end)
    expression := slice-expression
  
  ## parsing `sequence[index]` or `sequence[index:second-index]`
  func inst parse(owner Expression sequence, user SyntaxTreeCode code-node):(
      copy Char end)
    self.sequence := sequence
    parse-new-expression(user ":]", user code-node):(owner self.index, copy end)
    if end = ':'
      parse-new-expression(user "]", user code-node):(
          owner self.second-index, copy end)
    read-c():(copy end)
  
  func dynamic analyze()
    self.sequence.analyze()
    self.assignable := self.sequence.assignable
    if not (? self.sequence.result-type.type-data)
      f-syntax-error-msg(user "cannot slice a void expression")
    if self.sequence.result-type.type-data = glob.type-string
      self.set-simple-type(user glob.type-char)
    else-if self.sequence.result-type.type-data = glob.type-array
      self.sequence.result-type.sub-type.m-copy-new():(
          owner self.result-type)
    else
      f-syntax-error(
          user "cannot slice type",
          user self.sequence.result-type.type-data.name)
    
    self.index.analyze()
    self.m-check-index(user self.index)
    
    if ? self.second-index
      self.second-index.analyze()
      self.m-check-index(user self.second-index)
  
  func inst m-check-index(user Expression index)
    if ? index.result-type.type-data
      if index.result-type.type-data != glob.type-int
        f-syntax-error(
            user "expected integer index for slice, got",
            user index.result-type.type-data.name)
    else
      f-syntax-error-msg(
          user "expected integer index for slice, got void expression")
    
  
  func dynamic write()
    self.sequence.write()
    write(user "[")
    self.index.write()
    if ? self.second-index
      write(user ":")
      self.second-index.write()
    write(user "]")
