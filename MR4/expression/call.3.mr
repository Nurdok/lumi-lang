## MR4 compiler - Call expression

## Function call expression
class CallExpression(Expression)
  owner Expression function
  owner FunctionArguments arguments
  user Expression output
  var Bool is-function-object
  
  func inst parse-new(user String ends, user SyntaxTreeCode code-node):(
      owner Expression expression, copy Char end)
    new CallExpression call-expression
    call-expression.parse(owner expression, user code-node):(copy end)
    expression := call-expression
  
  func inst parse(owner Expression function, user SyntaxTreeCode code-node):(
      copy Char end)
    self.function := function
    self.code-node := code-node
    self.set-location()
    new FunctionArguments in self.arguments
    var CallArgumentFactory argument-factory
    self.arguments.parse(user argument-factory, user code-node):(copy end)
  
  func dynamic analyze()
    self.function.analyze()
    self.arguments.analyze()
    if not (? self.function.result-type)
      self.m-syntax-error-msg(user "void expression is not callable")
    if self.function.result-type.type-data != glob.type-func
      self.m-syntax-error(
          user "non callable type",
          user self.function.result-type.type-data.name)
    user FunctionArguments declaration(self.function.result-type.arguments)
    if not self.is-statement
      declaration.get-result-type().copy-new():(owner self.result-type)
    self.function.analyze-call(user self.arguments):(
        copy self.is-function-object)
    if self.arguments.check-same-as(user declaration)
      # add omitted output
      new CallArgument output
      output.is-output := true
      output.access := declaration.outputs.last.item.access
      self.add-aux-variable(
          copy declaration.outputs.last.item.access,
          user declaration.get-result-type()):(
          owner output.value)
      self.output := output.value
      self.arguments.outputs.add(owner output)
    else-if ? self.result-type
      self.arguments.get-output():(user self.output)
    self.assignable := ? self.result-type
  
  func dynamic write-preactions()
    self.function.write-preactions()
    if self.is-function-object
      write(user "if (")
      self.function.top := true
      self.function.write()
      self.function.top := false
      write(user " == NULL) ")
      self.write-raise()
      self.code-node.write-spaces()
    self.arguments.write-preactions()
    if not self.is-statement
      self.write-func-call()
      self.code-node.write-spaces()
  
  func dynamic write()
    if self.is-statement
      self.write-func-call()
    else-if ? self.output
      self.output.write()
    else
      raise
  
  func inst write-func-call()
    self.write-call()
    self.function.write()
    self.arguments.write-call()
    write(user " )\n")
  


## Function argument call
class CallArgument(Argument)
  owner Expression value
  user SyntaxTreeCode code-node
  var Bool is-down-cast
  var Bool is-dynamic
  
  func dynamic parse-value(user SyntaxTreeCode code-node):(copy Char end)
    self.code-node := code-node
    parse-new-expression(
        user ",)", user code-node):(owner self.value, copy end)
    if end != ',' and end != ')'
      self.m-syntax-error-c(user "expected \",\" or \")\", got", copy end)
  
  func dynamic analyze()
    self.value.analyze()
    if self.is-output and not self.value.assignable
      self.m-syntax-error-msg(user "non assignable call output")
  
  func dynamic check-same-type-as(user TypeInstance type-instance)
    if self.is-output
      self.is-down-cast := type-instance.check-assign-to(
          user self.value.result-type, user self) > 0
    else
      type-instance.check-assign-from(user self):(owner self.value)
    self.is-dynamic := type-instance.type-data.is-dynamic
  
  func dynamic get-output():(user Expression output)
    output := self.value
  
  func dynamic write-preactions()
    self.value.write-preactions()
    if self.is-down-cast
      # if (`value` != NULL) RAISE(`line-num`)
      write(user "if (")
      self.value.write()
      write(user " != NULL) ")
      self.write-raise()
      self.code-node.write-spaces()
  
  func dynamic write()
    # [&(]`value`[)][, [&(]`value`_Dynamic[)]]
    if self.is-output
      if self.is-down-cast
        write(user "(void*)")
      write(user "&(")
    self.value.write()
    if self.is-output
      write(user ")")
    if self.is-dynamic
      write(user ", ")
      if self.is-output
        if self.is-down-cast
          write(user "(void*)")
        write(user "&(")
      self.value.write-dynamic()
      if self.is-output
        write(user ")")
      


class CallArgumentFactory(ArgumentFactory)
  func dynamic m-new-argument():(owner Argument new-argument)
    new CallArgument in new-argument
