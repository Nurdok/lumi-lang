## MR4 compiler - Call expression

## Function call expression
class CallExpression(Expression)
  owner Expression function
  owner FunctionArguments arguments
  user Expression output
  
  func inst parse-new(user String ends):(
      owner Expression expression, copy Char end)
    new CallExpression call-expression
    call-expression.parse(owner expression):(copy end)
    expression := call-expression
  
  func inst parse(owner Expression function):(copy Char end)
    self.function := function
    new FunctionArguments in self.arguments
    var CallArgumentFactory argument-factory
    self.arguments.parse(
        user argument-factory, user self.code-node, user _):(copy end)
  
  func dynamic analyze()
    self.function.analyze()
    self.arguments.analyze()
    # TODO add self...
    user FunctionArguments declaration(self.function.result-type.arguments)
    if not (? self.function.result-type.type-data)
      f-syntax-error-msg(user "void expression is not callable")
    if self.function.result-type.type-data != glob.type-func or
        not (? declaration)
      f-syntax-error(
          user "non callable type",
          user self.function.result-type.type-data.name)
    declaration.get-result-type().m-copy-new():(owner self.result-type)
    if self.arguments.m-check-calling(user declaration)
      # add omitted output
      new SymbolExpression symbol
      symbol.code-node := self.code-node
      self.result-type.m-copy-new():(owner symbol.result-type)
      symbol.assignable := true
      self.code-node.parent.add-aux-variable(
          copy declaration.outputs.last.item.access,
          user self.result-type):(
          user symbol.variable)
      string-new-copy(user symbol.variable.name):(owner symbol.text)
      self.output := symbol
      new CallArgument output
      output.access := declaration.outputs.last.item.access
      output.value := symbol
      self.arguments.outputs.add(owner output)
    else-if ? self.result-type.type-data
      declaration.get-output():(user self.output)
    self.assignable := ? self.result-type.type-data
  
  func dynamic write()
    self.function.write()
    self.arguments.write(copy false)


## Function argument call
class CallArgument(Argument)
  owner Expression value
  
  func dynamic parse-value(user SyntaxTreeCode code-node):(copy Char end)
    parse-new-expression(
        user ",)", user code-node):(owner self.value, copy end)
    if end != ',' and end != ')'
      f-syntax-error-c(user "expected \",\" or \")\", got", copy end)
  
  func dynamic analyze(copy Bool is-output)
    self.value.analyze()
    if is-output and not self.value.assignable
      f-syntax-error-msg(user "non assignable call output")
  
  func dynamic get-type-instance():(user TypeInstance type-instance)
    type-instance := self.value.result-type
  
  func dynamic get-output():(user Expression output)
    output := self.value
  
  func dynamic write(copy Bool is-output)
    # &(`value`)
    if is-output
      write(user "&(")
    self.value.write()
    if is-output
      write(user ")")


class CallArgumentFactory(ArgumentFactory)
  func dynamic m-new-argument():(owner Argument new-argument)
    new CallArgument in new-argument
