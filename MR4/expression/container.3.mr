## MR4 compiler - Container expressions

## An expression surrounded by brackets
class BlockExpression(Expression)
  owner Expression expression
  
  func inst parse-new(user SyntaxTreeCode code-node):(
      owner Expression expression, copy Char end)
    new BlockExpression block-expression
    block-expression.parse(user code-node):(copy end)
    expression := block-expression
  
  ## parsing `(expression)`
  func inst parse(user SyntaxTreeCode code-node):(copy Char end)
    self.set-location()
    parse-new-expression(user ")", user code-node):(owner self.expression)
    read-c():(copy end)
  
  func dynamic analyze()
    self.expression.analyze()
    self.expression.result-type.m-copy-new():(owner self.result-type)
  
  func dynamic write-preactions()
    self.expression.write-preactions()
  
  func dynamic write()
    write(user "(")
    self.expression.write()
    write(user ")")


static Operator
  owner String name
  owner String c-name
  var Int order
  var Int group-index
  
  func inst init(
      user String name,
      user String c-name,
      copy Int order,
      copy Int group-index)
    string-new-copy(user name):(owner self.name)
    string-new-copy(user c-name):(owner self.c-name)
    self.order := order
    self.group-index := group-index


## An expression with an unary operator
class UnaryExpression(Expression)
  user Operator operator
  owner Expression right-expression
  
  func inst parse-new(
      user String ends, user Operator operator, user SyntaxTreeCode code-node):(
      owner Expression expression, copy Char end, user Operator next-operator)
    new UnaryExpression unary-expression
    unary-expression.parse(user operator, user ends, user code-node):(
        copy end, user next-operator)
    expression := unary-expression
  
  func inst parse(
      user Operator operator,
      user String ends,
      user SyntaxTreeCode code-node):(
      copy Char end, user Operator next-operator)
    self.operator := operator
    self.set-location()
    if end = '\n'
      self.read-line-break-spaces()
    else-if end != ' '
      self.m-syntax-error-c(user "unexpected", copy end)
    Expression.parse-new(var _, user ends, user code-node, user operator):(
        owner self.right-expression, copy end, user next-operator)
  
  func dynamic analyze()
    self.analyze-operand(user self.right-expression)
    if self.operator.order = 2
      # `not` operator
      self.test-operand-type(user self.right-expression, user glob.type-bool)
      self.set-simple-type(user glob.type-bool)
    else-if self.operator.name.equal(user "-")
      self.test-operand-type(user self.right-expression, user glob.type-int)
      self.set-simple-type(user glob.type-int)
    else
      self.m-syntax-error(user "not unary operator", user self.operator.name)
  
  func inst analyze-operand(user Expression operand)
    operand.analyze()
    if not (? operand.result-type)
      self.m-syntax-error(
          user "void expression given as operand to operator",
          user self.operator.name)
  
  func inst test-operand-type(
      user Expression operand,
      user TypeData expected-type)
    if operand.result-type.type-data != expected-type
      self.m-syntax-error3(
          user "operator",
          user self.operator.name,
          user "expected",
          user expected-type.name,
          user "operand, got",
          user operand.result-type.type-data.name)
  
  func dynamic write-preactions()
    self.right-expression.write-preactions()
  
  func dynamic write()
    self.write-start()
    self.write-end()
  
  func inst write-start()
    if not self.top
      write(user "(")
  
  func inst write-end()
    write(user self.operator.c-name)
    write(user " ")
    self.right-expression.write()
    if not self.top
      write(user ")")
    if self.is-statement
      write(user ";")


## An expression with a binary operator
class BinaryExpression(UnaryExpression)
  owner Expression left-expression
  
  func inst parse-new(
      user String ends, user Operator operator, user SyntaxTreeCode code-node):(
      owner Expression expression, copy Char end, user Operator next-operator)
    new BinaryExpression binary-expression
    binary-expression.left-expression := expression
    binary-expression.parse(user operator, user ends, user code-node):(
        copy end, user next-operator)
    expression := binary-expression
  
  func dynamic analyze()
    self.analyze-operand(user self.right-expression)
    self.analyze-operand(user self.left-expression)
    if self.operator.order = 2
      # `not` operator
      self.m-syntax-error-msg(user "cannot use \"not\" as binary operand")
    if self.operator.order = 3
      # `or`\`and` operator
      self.test-operands-type(user glob.type-bool)
      self.set-simple-type(user glob.type-bool)
    else-if self.operator.name.equal(user ":=")
      self.right-expression.result-type.m-check-assign-to(
          user self.left-expression.result-type, user self)
      if not self.left-expression.assignable
        self.m-syntax-error-msg(user "assigning into non assignable expression")
      self.left-expression.top := true
      self.right-expression.top := true
    else
      # any other Int operator
      self.test-operands-type(user glob.type-int)
      if self.operator.order = 0
        # aritmetic operator
        self.set-simple-type(user glob.type-int)
      else-if self.operator.order = 1
        # compare operator
        self.set-simple-type(user glob.type-bool)
  
  func inst test-operands-type(user TypeData expected-type)
    self.test-operand-type(user self.right-expression, user expected-type)
    self.test-operand-type(user self.left-expression, user expected-type)
  
  func dynamic write-preactions()
    base.write-preactions()
    self.left-expression.write-preactions()
  
  func dynamic write()
    self.write-start()
    self.left-expression.write()
    write(user " ")
    self.write-end()


## An expression with the "?" operator
class QuestionExpression(Expression)
  owner Expression tested
  
  func inst parse-new():(owner Expression expression, copy Char end)
    new QuestionExpression question-expression
    question-expression.parse(owner expression):(copy end)
    expression := question-expression
  
  ## parsing `tested?`
  func inst parse(owner Expression tested):(copy Char end)
    self.tested := tested
    self.set-location()
    read-c():(copy end)
  
  func dynamic analyze()
    self.tested.analyze()
    if not (? self.tested.result-type)
      self.m-syntax-error-msg(user "cannot use \"?\" on void expression")
    if self.tested.result-type.type-data.is-primitive
      self.m-syntax-error(
          user "cannot use \"?\" on type",
          user self.tested.result-type.type-data.name)
    self.set-simple-type(user glob.type-bool)
  
  func dynamic write-preactions()
    self.tested.write-preactions()
  
  func dynamic write()
    if not self.top
      write(user "(")
    self.tested.write()
    write(user " != NULL")
    if not self.top
      write(user ")")
