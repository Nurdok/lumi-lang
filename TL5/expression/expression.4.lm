~~~ TL5 compiler - Expression

Expression is a basic class for all expression types.
For each part of an expression (variable, constant, function call, etc..) there
is a class that expends the basic expression type and handles its unique logic.
From a complex expression an expression tree is generated, with types such
operators and slices that contain sub-expression inside.

For example, `array[4] + 3` expression is parsed as:
BinaryExpression:
  operator: +
  left: SliceExpression:
    sequence: VariableExpression(array)
    index: IntExpression(4)
  right: IntExpression(3)
~~~
module tl5-compiler


class ExpressionValue(SyntaxTreeNode)
  owner Expression expression
  user TypeInstance result-type
  var Int access
  var Bool is-statement
  var Bool constant
  
  new(user String ends, user SyntaxTreeCode code-node)
    parse-new-expression(user ends, user code-node)->(owner self.expression)
  
  func inst parsed()->(var Bool is-parsed)
    is-parsed := self.expression?
  
  func dynamic analyze()
    self.expression.restructure()->(owner self.expression)
    self.expression.is-statement := self.is-statement
    self.expression.analyze()
    self.result-type := self.expression.result-type
    self.access := self.expression.access
    self.constant := self.expression.constant
  
  func dynamic order-constants(user NameMap{SyntaxTreeConstant} ordered-list)
    self.expression.order-constants(user ordered-list)
  
  func dynamic check-memory(user ReferenceMemoryList refs)
    if self.expression?
      self.expression.check-memory(user refs)
      refs.clear-conditional-invalids()
  
  func inst write-preactions()
    self.expression.write-preactions()
  
  func dynamic write()
    self.expression.write()


~~~ Return in `expression` a new allocated expression parsed from the input
file until one of the characters in `ends` is reached.
Return the end character in `end` ~~~
func parse-new-expression(user String ends, user SyntaxTreeCode code-node)->(
    owner Expression expression)
  Expression.parse-new(user _, user ends, user code-node, user _)->(
      owner expression)

func analyze-expression()->(owner Expression expression)
  expression.restructure()->(owner expression)
  expression.analyze()


user String expression-ends(user " .([{?!")

~~~ Meta type for an expression in the language.
Currently only the parsing is fully implemented, `write` is implemented only
for testing. ~~~
class Expression(SyntaxTreeNode)
  user SyntaxTreeCode code-node
  owner TypeInstance result-type
  var Int access
  var Bool assignable
  var Bool constant
  var Bool is-statement
  var Bool is-generic-cast
  var Bool is-complex-field
  var Bool is-var

  new(user SyntaxTreeCode code-node)
    self.set-location()
    self.code-node := code-node
  
  ~~~ Parse any expression ~~~
  func inst parse-new(
      user String ends,
      user SyntaxTreeCode code-node,
      user Operator curr-operator)->(
      owner Expression expression,
      user Operator operator)
    expression := _
    owner String text
    self.read-new-value(user ends)->(owner text)
    glob.operator-map.find(user text)->(user operator)
    if operator?
      UnaryExpression.parse-new(
          user _, user ends, user operator, user code-node)->(
          owner expression, user operator)
    else
      self.parse-new-operand(owner text, user ends, user code-node)->(
          owner expression)
      if glob.last-char = ' '
        self.read-new-value(user ends)->(owner text)
        glob.operator-map.find(user text)->(user operator)
        if not operator?
          code-node.syntax-error(user "unknown operator", user text)
    user BinaryExpression binary-left-expression
    do
      while operator?
      if curr-operator?
        while operator.order < curr-operator.order
      owner BinaryExpression new-binary-expression
      BinaryExpression.parse-new(
          user _,
          user ends,
          user operator,
          user code-node,
          owner expression,
          user binary-left-expression)->(
          owner new-binary-expression,
          user operator)
      binary-left-expression := new-binary-expression
      expression := new-binary-expression
  
  ~~~ Read a single expression value as new string ~~~
  func inst read-new-value(user String ends)->(owner String text)
    owner String all-ends
    string-new-concat(user expression-ends, user ends)->(owner all-ends)
    read-new(user all-ends)->(owner text)
  
  ~~~ Parse an expression that is an operand ~~~
  func inst parse-new-operand(
      owner String text, user String ends, user SyntaxTreeCode code-node)->(
      owner Expression expression)
    if text.length = 0
      if glob.last-char = '('
        BlockExpression.parse-new(user _, user code-node)->(owner expression)
      else
        code-node.syntax-error-c(user "expected expression, got")
    else
      self.parse-new-init-operand(owner text, user ends, user code-node)->(
          owner expression)
    
    do
      if glob.last-char = '?'
        QuestionExpression.parse-new(user _, user code-node)->(owner expression)
      else-if glob.last-char = '!'
        ExclamationExpression.parse-new(user _, user code-node)->(
            owner expression)
      while self.parse-new-follow-operand(user ends, user code-node)->(
          owner expression)
  
  ~~~ Parse the initialize part of an operand expression ~~~
  func inst parse-new-init-operand(
      owner String text, user String ends, user SyntaxTreeCode code-node)->(
      owner Expression expression)
    var Char first(copy text[0])
    var Char second(copy '\0')
    if text.length > 1
      second := text[1]
    if first = '\''
      CharExpression.parse-new(user _, owner text, user code-node)->(
          owner expression)
    else-if first = '"'
      StringExpression.parse-new(user _, owner text, user code-node)->(
          owner expression)
    else-if (first >= '0' and first <= '9') or
        (first = '-' and second >= '0' and second <= '9')
      IntExpression.parse-new(user _, owner text, user code-node)->(
          owner expression)
    else-if first >= 'A' and first <= 'Z' and second >= 'a' and second <= 'z'
      self.parse-type-prefix(owner text, user ends, user code-node)->(
          owner expression)
    else-if text.length = 1 and first = '_'
      expression := EmptyExpression(user code-node)
    else-if text.equal(user "base")
      expression := BaseMethExpression(user code-node)
    else
      VariableExpression.parse-new(user _, owner text, user code-node)->(
          owner expression)
  
  ~~~ Parse one following part of an operand ~~~
  func inst parse-new-follow-operand(
      user String ends, user SyntaxTreeCode code-node)->(
      owner Expression expression, var Bool has-more)
    has-more := true
    if glob.last-char = '.'
      owner String text
      self.read-new-value(user ends)->(owner text)
      if text.length = 0
        code-node.syntax-error-c(user "expected name after \".\", got")
      var Char first(copy text[0])
      var Char second(copy '\0')
      if text.length > 1
        second := text[1]
      if first >= 'A' and first <= 'Z' and second >= 'a' and second <= 'z'
        self.parse-type-prefix(owner text, user ends, user code-node)->(
            owner expression)
      else
        FieldExpression.parse-new(user _, owner text, user code-node)->(
            owner expression)
    else-if glob.last-char = '['
      SliceExpression.parse-new(user _, user ends, user code-node)->(
          owner expression)
    else-if glob.last-char = '('
      FunctionObjectCallExpression.parse-new(
          user _, user ends, user code-node)->(owner expression)
    else
      has-more := false

  ~~~ Parse expression with type prefix ~~~
  func inst parse-type-prefix(
      owner String text, user String ends, user SyntaxTreeCode code-node)->(
      owner Expression expression)
    owner String value
    var Bool has-member(copy glob.last-char = '.')
    if has-member
      self.read-new-value(user ends)->(owner value)
      if value.length > 0
        if value.equal(user "length") or (value[0] >= 'A' and value[0] <= 'Z')
          EnumExpression.parse-new(
              user _, owner text, owner value, user code-node)->(
              owner expression)
          return
    
    new TypeInstance type-instance
    type-instance.parse-name(
        user text,
        user code-node,
        user code-node,
        copy code-node.parent.indentation-spaces)
    if not has-member and glob.last-char = '('
      InitExpression.parse-new(user _, owner type-instance, user code-node)->(
          owner expression)
      return
    
    TypeExpression.parse-new(user _, owner type-instance, user code-node)->(
        owner expression)
    if has-member
      FieldExpression.parse-new(user _, owner value, user code-node)->(
          owner expression)
  
  func inst is-dubious()->(var Bool is-dubious)
    is-dubious := self.result-type.conditional or self.access = Access.WEAK
  
  ~~~ Set type instance to be a type that has no sub-type ~~~
  func inst set-simple-type(user TypeData type-data)
    type-data.new-type-instance()->(owner self.result-type)
  
  func inst add-aux-variable(
      copy Int access, copy Bool is-create, user TypeInstance type-instance)->(
      owner VariableExpression expression)
    expression := VariableExpression(user self.code-node)
    type-instance.copy-new()->(owner expression.result-type)
    expression.access := access
    expression.assignable := true
    self.code-node.parent.add-aux-variable(
        copy access, copy is-create, user type-instance)->(
        user expression.variable)
    string-new-copy(user expression.variable.name)->(owner expression.name)
    expression.result-type.reference-path :=
        ReferencePath(user expression.variable)
  
  func dynamic get-parent-type()->(user TypeData parent-type)
    parent-type := _
    if self.code-node?
      self.code-node.get-parent-type()->(user parent-type)

  func dynamic restructure()->(
      owner Expression expression, owner FunctionArguments arguments)
    ; do nothing

  func dynamic check-memory(user ReferenceMemoryList refs)
    ; do nothing
  
  func inst write-macro-name(user String macro-name)
    ; `macro-name`(`line`, `cleanup`, `expression`
    write(user macro-name)
    write(user "(")
    self.write-line-num()
    write(user ", ")
    self.code-node.parent.write-cleanup-label()
    write(user ", ")
  
  func inst write-macro-init(user String macro-name, user Expression expression)
    self.write-macro-name(user macro-name)
    expression.write()
  
  func inst write-init-var-ref(user VariableExpression variable)
    ; `symbol` = &`symbol`_Var; \
    ; INIT_VAR_REFMAN(`line`, `cleanup`, `symbol`)
    variable.write()
    write(user " = &")
    variable.write()
    write(user "_Var;\n")
    if variable.access = Access.S-VAR
      self.code-node.write-spaces()
      self.write-macro-init(user "INIT_VAR_REFMAN", user variable)
      write(user ")\n")
  
  func inst write-assign-null()
    self.write()
    write(user " = NULL;\n")
    if access-has-refman(copy self.access)
      self.code-node.write-spaces()
      self.write-refman()
      write(user " = NULL;\n")
    if self.result-type.type-data.is-dynamic
      self.code-node.write-spaces()
      self.write-dynamic()
      write(user " = NULL;\n")
    if self.result-type.type-data is glob.type-string
      self.code-node.write-spaces()
      self.write()
      write(user "_Length = &Lumi_empty_int;\n")
    
  func inst write-check-ref()
    ; CHECK_REF(`line`, `cleanup`, `instance`, `instance-refman`)
    if access-has-refman(copy self.access)
      self.write-macro-init(user "CHECK_REF_AND_REFMAN", user self)
      write(user ", ")
      self.write-refman()
    else
      self.write-macro-init(user "CHECK_REF", user self)
    write(user ")\n")
  
  func inst write-length(
      user String prefix, user String empty, copy Bool is-static)
    var Bool is-const-length
    if is-static and self.result-type.length?
      is-const-length := self.result-type.length.constant
    if self.result-type.type-data is glob.type-empty
      write(user empty)
    else-if is-const-length
      self.result-type.length.write()
    else
      self.write()
      write(user prefix)
    
  func inst write-check-refman()
    self.write-macro-name(user "CHECK_REFMAN")
    self.write-refman()
    write(user ")\n")
    self.code-node.write-spaces()
  
  func dynamic write-cast()
    self.write()
  
  func dynamic write-safe()
    self.write-cast()
  
  func dynamic write-dynamic()
    self.write()
    write(user "_Dynamic")
  
  func dynamic write-dynamic-cast()
    self.write-dynamic()
  
  func dynamic write-dynamic-safe()
    self.write-dynamic-cast()
  
  func dynamic write-refman()
    self.write()
    write(user "_Refman")
  
  func dynamic write-refman-safe()
    self.write-refman()
  
  func dynamic is-mocked-function()->(var Bool is-mock)
    is-mock := false
  
  func dynamic write-with-brackets()
    write(user "(")
    self.write()
    write(user ")")
  
  func dynamic write-preactions()
    ; do noting
