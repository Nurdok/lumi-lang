~~~ TL5 compiler - Slice expression ~~~
module tl5-compiler

~~~ A slice expression ~~~
class SliceExpression(Expression)
  owner Expression sequence
  owner Expression index
  owner Expression second-index
  owner VariableExpression slice-variable
  
  func inst parse-new(user String ends, user SyntaxTreeCode code-node)->(
      owner Expression expression)
    new SliceExpression slice-expression(user code-node)
    slice-expression.parse(owner expression)
    expression := slice-expression
  
  ~~~ parsing `sequence[index]` or `sequence[index:second-index]` ~~~
  func inst parse(owner Expression sequence)
    self.sequence := sequence
    parse-new-expression(user ":]", user self.code-node)->(owner self.index)
    if glob.last-char = ':'
      parse-new-expression(user "]", user self.code-node)->(
          owner self.second-index)
    if glob.last-char != ']'
      self.syntax-error-c(user "expected \"]\", got")
    read-c()
  
  func dynamic analyze()
    analyze-expression()->(owner self.sequence)
    if not self.sequence.result-type?
      self.syntax-error-msg(user "cannot slice a void expression")
    if self.sequence.result-type.type-data is glob.type-string
      if not self.second-index?
        self.set-simple-type(user glob.type-char)
    else-if self.sequence.result-type.type-data is glob.type-array
      if not self.second-index?
        self.sequence.result-type.parameters.first.item.copy-new()->(
            owner self.result-type)
    else
      self.syntax-error(
          user "cannot slice type",
          user self.sequence.result-type.type-data.name)
    if not self.second-index?
      self.assignable := self.result-type.type-data.is-primitive
    
    analyze-expression()->(owner self.index)
    self.check-index(user self.index)
    
    if self.second-index?
      analyze-expression()->(owner self.second-index)
      self.check-index(user self.second-index)
      self.sequence.result-type.copy-new()->(owner self.result-type)
      self.result-type.length := _
      self.result-type.conditional := false
      if access-is-weak(copy self.sequence.access)
        self.access := Access.WEAK
      else
        self.access := Access.USER
      self.add-aux-variable(
          copy self.access, copy false, user self.result-type)->(
          owner self.slice-variable)
    else
      if not self.assignable and
          access-is-weak(copy self.sequence.access) and
          not self.result-type.type-data is glob.type-string
        self.access := Access.S-VAR
      else
        self.access := Access.VAR
      if self.result-type.type-data is glob.type-array or
          self.result-type.type-data is glob.type-string
        self.add-aux-variable(
            copy self.access, copy false, user self.result-type)->(
            owner self.slice-variable)
    
    if not self.result-type.type-data.is-primitive
      self.sequence.result-type.reference-path.copy-new()->(
          owner self.result-type.reference-path)
  
  func inst check-index(user Expression index)
    if index.result-type?
      if index.result-type.type-data is-not glob.type-int
        self.syntax-error(
            user "expected integer index for slice, got",
            user index.result-type.type-data.name)
    else
      self.syntax-error-msg(
          user "expected integer index for slice, got void expression")

  func dynamic check-memory(user ReferenceMemoryList refs)
    self.sequence.check-memory(user refs)
    self.index.check-memory(user refs)
    if self.second-index?
      self.second-index.check-memory(user refs)
    refs.check-user(user self.sequence)
  
  func dynamic write-preactions()
    self.write-preactions-base()
    self.code-node.write-spaces()
  
  func inst write-preactions-base()
    self.sequence.write-preactions()
    self.index.write-preactions()
    
    if self.sequence.is-dubious()
      self.sequence.write-check-ref()
      self.code-node.write-spaces()
    
    ; if (index < 0 || index >= `seq`_length)
    ; if (index < 0 || second < 0 || index + second > `seq`_length)
    ;     RAISE(`slice_index`)
    write(user "if (")
    self.index.write-safe()
    write(user " < 0 || ")
    if self.second-index?
      self.second-index.write-safe()
      write(user " < 0 || ")
    self.index.write-safe()
    if self.second-index?
      write(user " + ")
      self.second-index.write-safe()
      write(user " > ")
    else
      write(user " >= ")
    if self.sequence.result-type.type-data is glob.type-array and
        self.sequence.result-type.length?
      self.sequence.result-type.length.write()
    else
      self.sequence.write-safe()
      write(user "_Length")
    write(user ") ")
    self.code-node.write-raise(user "slice_index")
    
    if self.second-index?
      self.code-node.write-spaces()
      self.second-index.write-preactions()
      ; symbol = (seq) + (index);
      self.slice-variable.write()
      write(user " = ")
      self.sequence.write-safe()
      write(user " + ")
      self.index.write-safe()
      write(user ";\n")
      self.code-node.write-spaces()
      ; symbol_Length = second;
      self.slice-variable.write()
      write(user "_Length = ")
      self.second-index.write()
      write(user ";\n")
      self.code-node.write-spaces()
      if self.sequence.result-type.type-data is glob.type-string
        ; symbol_Max_length = symbol_Length + 1;
        self.slice-variable.write()
        write(user "_Max_length = ")
        self.slice-variable.write()
        write(user "_Length;\n")
        self.code-node.write-spaces()
      ; symbol_Refman = seq_Refman;
      self.slice-variable.write-refman()
      write(user " = ")
      self.sequence.write-refman()
      write(user ";\n")
    
    else-if self.result-type.type-data is glob.type-array
      ; todo...
    
    else-if self.result-type.type-data is glob.type-string
      ; symbol_Max_length = seq_Value_length;
      self.code-node.write-spaces()
      self.slice-variable.write()
      write(user "_Max_length = ")
      if self.result-type.length?
        self.result-type.length.write()
      else
        self.sequence.write()
        write(user "_Value_length")
      write(user ";\n")
      self.code-node.write-spaces()
      ; symbol_Length = seq_String_length[index];
      self.slice-variable.write()
      write(user "_Length = ")
      self.sequence.write()
      write(user "_String_length[")
      self.index.write()
      write(user "];\n")
      self.code-node.write-spaces()
      ; symbol = (seq) + (index) * symbol_Max_length;
      self.slice-variable.write()
      write(user " = ")
      self.sequence.write-safe()
      write(user " + ")
      self.index.write-safe()
      write(user " * ")
      self.slice-variable.write()
      write(user "_Max_length;\n")
      self.code-node.write-spaces()
      ; symbol_Refman = seq_Refman;
      self.slice-variable.write-refman()
      write(user " = ")
      self.sequence.write-refman()
      write(user ";\n")
  
  func dynamic write()
    if self.slice-variable?
      self.slice-variable.write()
      return
    
    ; seq[index]
    ; (seq + index)
    self.sequence.write-safe()
    if self.result-type.type-data.is-primitive
      write(user "[")
    else
      write(user " + ")
    self.index.write()
    if self.result-type.type-data.is-primitive
      write(user "]")
    
  func dynamic write-safe()
    self.write-with-brackets()
  
  func dynamic write-dynamic()
    write(user "&")
    self.result-type.type-data.write-cname()
    write(user "_dynamic")
  
  func dynamic write-refman()
    if self.slice-variable?
      self.slice-variable.write-refman()
    else
      self.sequence.write-refman()


func write-array-value-length(copy Int depth)
  write(user "_Value")
  for _ in depth
    write(user "_value")
  write(user "_length")
