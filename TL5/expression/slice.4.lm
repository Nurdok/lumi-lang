~~~ TL5 compiler - Slice expression ~~~
module tl5-compiler

~~~ A slice expression ~~~
class SliceExpression(Expression)
  owner Expression sequence
  owner Expression index
  owner Expression second-index
  owner VariableExpression slice-variable
  
  func inst parse-new(user String ends, user SyntaxTreeCode code-node)->(
      owner Expression expression)
    new SliceExpression slice-expression(user code-node)
    slice-expression.parse(owner expression)
    expression := slice-expression
  
  ~~~ parsing `sequence[index]` or `sequence[index:second-index]` ~~~
  func inst parse(owner Expression sequence)
    self.sequence := sequence
    self.access := Access.VAR
    parse-new-expression(user ":]", user self.code-node)->(owner self.index)
    if glob.last-char = ':'
      parse-new-expression(user "]", user self.code-node)->(
          owner self.second-index)
    if glob.last-char != ']'
      self.syntax-error-c(user "expected \"]\", got")
    read-c()
  
  func dynamic analyze()
    analyze-expression()->(owner self.sequence)
    if not self.sequence.result-type?
      self.syntax-error-msg(user "cannot slice a void expression")
    if self.sequence.result-type.type-data is glob.type-string
      if not self.second-index?
        self.set-simple-type(user glob.type-char)
    else-if self.sequence.result-type.type-data is glob.type-array
      if not self.second-index?
        self.sequence.result-type.parameters.first.item.copy-new()->(
            owner self.result-type)
      if self.sequence.result-type.parameters.first.item.type-data is
          glob.type-generic
        self.syntax-error-msg(user "cannot slice generic array")
    else
      self.syntax-error(
          user "cannot slice type",
          user self.sequence.result-type.type-data.name)
    if not self.second-index?
      self.assignable := self.sequence.assignable and
          self.result-type.type-data.is-primitive
    
    analyze-expression()->(owner self.index)
    self.check-index(user self.index)
    
    if self.second-index?
      analyze-expression()->(owner self.second-index)
      self.check-index(user self.second-index)
      self.sequence.result-type.copy-new()->(owner self.result-type)
      self.add-aux-variable(
          copy Access.VAR, copy false, user self.result-type)->(
          owner self.slice-variable)
  
  func inst check-index(user Expression index)
    if index.result-type?
      if index.result-type.type-data is-not glob.type-int
        self.syntax-error(
            user "expected integer index for slice, got",
            user index.result-type.type-data.name)
    else
      self.syntax-error-msg(
          user "expected integer index for slice, got void expression")

  func dynamic check-memory(user List{ReferenceMemory} refs)
    self.sequence.check-memory(user refs)
    self.index.check-memory(user refs)
    if self.second-index?
      self.second-index.check-memory(user refs)
  
  func dynamic write-preactions()
    self.sequence.write-preactions()
    self.index.write-preactions()
    
    if self.second-index?
      self.second-index.write-preactions()
      self.write-init-var-ref(user self.slice-variable)
      ; symbol_Var.length = second;
      ; symbol_Var.max_length = symbol.length + 1;
      ; symbol_Var.values = (seq)->values + (index);
      ; symbol_Var.values = (Byte*)((seq)->values) + (index);
      self.code-node.write-spaces()
      self.slice-variable.write()
      write(user "_Var.length = ")
      self.second-index.write()
      write(user ";\n")
      self.code-node.write-spaces()
      if self.sequence.result-type.type-data is glob.type-string
        self.slice-variable.write()
        write(user "_Var.max_length = ")
        self.slice-variable.write()
        write(user "_Var.length + 1;\n")
        self.code-node.write-spaces()
      self.slice-variable.write()
      write(user "_Var.values = (")
      if self.sequence.result-type.type-data is-not glob.type-string
        write(user "Byte*)((")
      self.sequence.write()
      write(user ")->values")
      if self.sequence.result-type.type-data is-not glob.type-string
        write(user ")")
      write(user " + (")
      self.index.write()
      write(user ");\n")
      self.code-node.write-spaces()
    
    self.sequence.write-check-ref()
    self.code-node.write-spaces()
    
    ; if (index < 0 || index >= seq->length)
    ; if (index < 0 || second < 0 || index + second > seq->length)
    ;     RAISE(`slice_index`)
    write(user "if (")
    self.index.write-safe()
    write(user " < 0 || ")
    if self.second-index?
      self.second-index.write-safe()
      write(user " < 0 || ")
    self.index.write-safe()
    write(user " ")
    if self.second-index?
      write(user "+ ")
      self.second-index.write-safe()
      write(user " >")
    else
      write(user ">=")
    write(user " ")
    self.sequence.write-safe()
    write(user "->length) ")
    self.code-node.write-raise(user "slice_index")
    self.code-node.write-spaces()
  
  func dynamic write()
    if self.second-index?
      self.slice-variable.write()
      return
    
    ; (seq->values)[index]
    ; ((Prmitive*)(seq->values))[index]
    ; ((Complex*)(seq->values)) + index
    write(user "(")
    if self.sequence.result-type.type-data is-not glob.type-string
      write(user "(")
      if self.result-type.type-data is glob.type-func and
          self.result-type.arguments?
        self.result-type.arguments.write-pointer(user "*")
      else
        self.result-type.type-data.write-cname()
        write(user "*")
      write(user ")(")
    self.sequence.write-safe()
    write(user "->values)")
    if self.sequence.result-type.type-data is-not glob.type-string
      write(user ")")
    if self.result-type.type-data.is-primitive
      write(user "[")
    else
      write(user " + ")
    self.index.write()
    if self.result-type.type-data.is-primitive
      write(user "]")
    
  func dynamic write-safe()
    self.write-with-brackets()
  
  func dynamic write-dynamic()
    write(user "&")
    self.result-type.type-data.write-cname()
    write(user "_dynamic")
  
  func dynamic write-refman()
    self.sequence.write-refman()
