~~~ TL5 compiler - Symbol expression ~~~
module tl5-compiler

~~~ A single variable expression ~~~
class VariableExpression(Expression)
  owner String name
  owner String module-name
  user SyntaxTreeVariable variable
  
  func inst copy-new()->(owner VariableExpression expression)
    expression := VariableExpression(user self.code-node)
    string-new-copy(user self.name)->(owner expression.name)
    expression.module-name := self.module-name
    expression.variable := self.variable
    self.result-type.copy-new()->(owner expression.result-type)
  
  func inst parse-new(owner String text, user SyntaxTreeCode code-node)->(
      owner Expression expression)
    new VariableExpression variable-expression(user code-node)
    variable-expression.parse(owner text)
    expression := variable-expression
  
  ~~~ parsing `symbol` ~~~
  func inst parse(owner String text)
    self.name := text
  
  func dynamic restructure()->(
      owner Expression expression, owner FunctionArguments arguments)
    if glob.module-map.find(user self.name)?
      expression := ModuleExpression(owner self.name)
      return
    
    if self.code-node.find-variable(
        user self.name, user self.module-name)->(user self.variable)?
      self.variable.type-instance.copy-new()->(owner self.result-type)
      self.access := self.variable.access
      self.constant := self.variable.constant
      self.assignable := not self.constant
      return
    
    user SyntaxTreeFunction function
    if self.code-node.find-function(
        user self.name, user self.module-name)->(user function)?
      expression := FunctionExpression(
          user self.code-node,
          user function,
          owner _,
          copy 0,
          copy false,
          copy false)
      expression.restructure()->(owner expression, owner arguments)
      return
    
    if self.module-name?
      self.syntax-error2(
          user "unknown symbol",
          user self.name,
          user "in module",
          user self.module-name)
    else
      self.syntax-error(user "unknown symbol", user self.name)

  func dynamic order-constants(user NameMap{SyntaxTreeConstant} ordered-list)
    self.variable.order-constants(user ordered-list)

  func dynamic write()
    if self.variable.is-output
      write(user "*")
    self.variable.write-cname()

  func dynamic write-safe()
    if self.variable.is-output
      self.write-with-brackets()
    else
      self.write()

  func dynamic write-dynamic-safe()
    if self.variable.is-output
      write(user "(*")
      self.variable.write-cname()
      write(user "_Dynamic)")
    else
      self.write-dynamic()
  
  func dynamic write-refman-safe()
    if self.variable.is-output
      write(user "(*")
      self.variable.write-cname()
      write(user "_Refman)")
    else
      self.write-refman()


~~~ An instance field expression ~~~
class FieldExpression(Expression)
  owner String name
  user SyntaxTreeVariable variable
  owner Expression instance
  var Int bases
  
  func inst parse-new(owner String text, user SyntaxTreeCode code-node)->(
      owner Expression expression)
    new FieldExpression field-expression(user code-node)
    field-expression.parse(owner expression, owner text)
    expression := field-expression
  
  ~~~ parsing `instance.symbol` ~~~
  func inst parse(owner Expression instance, owner String text)
    self.instance := instance
    self.name := text
  
  func dynamic restructure()->(
      owner Expression expression, owner FunctionArguments arguments)
    analyze-expression()->(owner self.instance)
    self.assignable := self.instance.assignable
    user TypeInstance instance-type(user self.instance.result-type)
    var Bool typed-expression
    if instance-type?
      typed-expression := instance-type.type-data?
    if not typed-expression
      self.syntax-error(user "void expression has no member", user self.name)
    var Bool after-type(copy instance-type.type-data is glob.type-type)
    var Bool after-base(copy instance-type.type-data is glob.type-base)
    if after-type
      instance-type := instance-type.parameters.first.item
    else-if after-base
      instance-type := instance-type.parameters.first.item.type-data.base-type
    
    if instance-type.type-data is glob.type-module
      new VariableExpression variable-expression(user self.code-node)
      variable-expression.name := self.name
      variable-expression.module-name := instance-type.name
      expression := variable-expression
      expression.restructure()->(owner expression, owner arguments)
      return
    
    instance-type.type-data.find-field(user self.name)->(
        user self.variable, var self.bases)
    if self.variable?
      if after-base
        self.syntax-error(
            user "calling \"base\" with non-method", user self.name)
      self.is-complex-field := self.variable.access = Access.VAR and
          not self.variable.type-instance.type-data.is-primitive
      self.variable.type-instance.new-replace-params(
          user instance-type, copy self.bases)->(owner self.result-type)
      self.access := self.variable.access
      self.assignable := not self.is-complex-field
      if self.variable.type-instance.type-data is glob.type-generic
        expression := CastExpression(user self.code-node, owner expression)
      return
    
    user SyntaxTreeFunction function
    instance-type.type-data.find-meth(user self.name)->(
        user function, var self.bases)
    
    if not function?
      if self.instance.is-mocked-function()
        if self.name.equal(user "mocked")
          self.instance.restructure()->(owner expression, owner arguments)
          return
        if self.name.equal(user "active")
          expression := MockFieldExpression(
              owner self.instance, owner self.name)
          return
      
      self.syntax-error2(
          user "type",
          user instance-type.type-data.name,
          user "has no member",
          user self.name)
    
    expression := FunctionExpression(
        user self.code-node,
        user function,
        owner self.instance,
        copy self.bases,
        copy after-type,
        copy after-base)
    expression.restructure()->(owner expression, owner arguments)

  func dynamic write-preactions()
    self.instance.write-preactions()
    if not self.instance.is-complex-field
      self.instance.write-check-ref()
      self.code-node.write-spaces()

  func dynamic write()
    if self.is-complex-field
      write(user "&(")
    self.write-safe()
    if self.is-complex-field
      write(user ")")

  func dynamic write-safe()
    self.instance.write-safe()
    self.write-bases()
    self.variable.write-cname()
  
  func inst write-bases()
    if self.instance.is-complex-field
      write(user ".")
    else
      write(user "->")
    for n in self.bases
      write(user "_base.")
  
  func dynamic write-refman()
    if self.is-complex-field
      self.instance.write-refman()
    else
      base()
  
  func dynamic write-dynamic()
    if self.is-complex-field
      write(user "&")
    self.write-dynamic-safe()
  
  func dynamic write-dynamic-safe()
    if self.is-complex-field
      self.result-type.type-data.write-cname()
      write(user "_dynamic")
    else
      base.write-dynamic()


class ModuleExpression(Expression)
  new(owner String name)
    self.result-type := TypeInstance()
    self.result-type.name := name
    self.result-type.type-data := glob.type-module


class FunctionExpression(Expression)
  user SyntaxTreeFunction function
  owner Expression instance
  var Int bases
  var Bool after-type
  var Bool after-base
  var Bool mock-field-used
  var Bool ignore-mock

  new(user SyntaxTreeCode code-node,
      user SyntaxTreeFunction function,
      owner Expression instance,
      copy Int bases,
      copy Bool after-type,
      copy Bool after-base)
    base(user code-node)
    self.function := function
    self.instance := instance
    self.bases := bases
    self.after-type := after-type
    self.after-base := after-base
    self.set-simple-type(user glob.type-func)
    self.access := Access.VAR
    self.function.arguments.copy-new()->(owner self.result-type.arguments)
  
  func inst move-new()->(owner FunctionExpression expression)
    expression := FunctionExpression(
        user self.code-node,
        user self.function,
        owner self.instance,
        copy self.bases,
        copy self.after-type,
        copy self.after-base)
    expression.mock-field-used := self.mock-field-used
    expression.ignore-mock := self.ignore-mock

  func dynamic is-mocked-function()->(var Bool is-mock)
    is-mock := self.function.mocker-function?
    self.mock-field-used := true
  
  func dynamic restructure()->(
      owner Expression expression, owner FunctionArguments arguments)
    self.ignore-mock := self.mock-field-used
    if not arguments?
      return
    
    user Expression self-instance(user self.instance)
    user TypeInstance actual-params
    if self.instance? and (self.after-type or self.after-base)
      actual-params := self.instance.result-type.parameters.first.item
      
    if self.instance? and not self.after-type
      new CallArgument self-param
      self-param.set-location()
      self-param.access := self.function.arguments.parameters.first.item.access
      if self.after-base
        new VariableExpression self-var(user self.instance.code-node)
        self.code-node.find-variable(user "self", user _)->(
            user self-var.variable)
        self-var.variable.type-instance.new-replace-params(
            user actual-params, copy 0)->(owner self-var.result-type)
        self-param.value := self-var
        self.bases += 1
      else
        actual-params := self.instance.result-type
        self-param.value := self.instance
      arguments.parameters.prepend(owner self-param)
      
      if self.function.is-dynamic and not self.after-base and
          not self-instance.is-complex-field
        if self.ignore-mock
          self.syntax-error(
              user "accessing mock function field in dynamic call to",
              user self.function.name)
        expression := DynamicCallExpression(
            user self.code-node,
            user self,
            owner arguments,
            user actual-params,
            user self-instance)
        return
        
    expression := FunctionCallExpression(
        user self.code-node,
        user self,
        owner arguments,
        user actual-params)
  
  func dynamic write()
    if self.function.mocker-function? and not self.ignore-mock
      self.function.mocker-function.write-cname()
    else
      self.function.write-cname()


class MockFieldExpression(Expression)
  owner Expression instance
  owner String name
  
  new(owner Expression instance, owner String name)
    self.set-location()
    self.instance := instance
    self.name := name
    self.set-simple-type(user glob.type-bool)
    self.assignable := true
  
  func dynamic analyze()
    self.instance.analyze()
  
  func dynamic write()
    self.instance.write()
    write(user "_")
    write-cname(user self.name)


class CastExpression(Expression)
  owner Expression expression

  new(user SyntaxTreeCode code-node, owner Expression expression)
    base(user code-node)
    self.expression := expression
    self.is-generic-cast := true
    self.access := self.expression.access
    self.assignable := self.expression.assignable
    self.expression.result-type.copy-new()->(owner self.result-type)

  func dynamic analyze()
    self.expression.analyze()

  func dynamic write-preactions()
    self.expression.write-preactions()

  func dynamic write()
    self.expression.write()

  func dynamic write-safe()
    write(user "((")
    self.result-type.type-data.write-cname()
    write(user "*)(")
    self.expression.write()
    write(user "))")

  func dynamic write-dynamic()
    self.expression.write-dynamic()

  func dynamic write-dynamic-safe()
    write(user "((")
    self.result-type.type-data.write-cname()
    write(user "_Dynamic*)(")
    self.expression.write-dynamic()
    write(user "))")
