struct Test
    var Int num
    weak Test? t
    var Func{()} fun
    new(copy Int num)
    func meth()
class Ta(Test)
    var Int numa
    func inst metha()
    func dynamic dyn()
class Tb(Ta)
    var Int numb
    func inst methb()
    func dynamic dyn()
class Tc(Tb)
    var Int numc
    func inst methc()
    func dynamic dyn()
struct Data{Generic}
    weak Generic? item
    weak Array?{Generic} arr
    func set(owner Generic? item, user Array?{Generic} arr)
    func get()->(weak Generic item)

func fun0()
func fun1(copy Int x, user String? s, owner String? o)
func fun2()->(strong String s, var Int x)
func fun3(copy Int x)->(strong String s)
func fun4(copy Int x)
func fun5(copy Int x)->(var Int y)
func fun6(copy Int x, copy Int y)->(var Int n, var Int m)
func fun7(weak Tb? tb)->(weak Tb? tbo)

var Int i
var Char c
var Bool b
weak String? str
weak Array?{Int} arr
owner File? fobj
weak Test? t
weak Ta? ta
strong Tb? tb
weak Tc? tc
weak Data?{String} d
weak Array?{String} sarr

func mock()->(strong String? so, var Int io, weak Test? to, weak Tc? tco)
; @@ test-int-expression
; @ c t0
i := 0
; @ c t1
i := 9630
; @ c t2
i := -9630
; @ c t3
i := 07520
; @ c t4
i := -07520
; @ c t5
i := 0xfda940
; @ c t6
i := -0xfda940
; @ c t7
i := 0xFDA940
; @ c t8
i := -0xFDA940
; @ ec te0
2a
; @ ec te1
0a
; @ ec te2
038
; @ ec te3
0b021
; @ ec te4
0xadg
; @ ec te5
0b1001
; @@ test-char-expression
; @ c t0
c := 'a'
; @ c t1
c := '\''
; @ c t2
c := '\n'
; @ c t3
c := '\x0f'
; @ c t4
c := '\xA9'
; @ c t5
c := '\270'
; @ fec te0
c := '''
; @ fec te1
c := '\'
; @ fec te2
c := 'aa
; @ ec te3
c := '\c'
; @ ec te4
c := 'aaaa'
; @ ec te5
c := '\x6g'
; @ ec te6
c := '\058'
; @ ec te7
c := ''
; @ ec te8
c := 'aa'
; @ ec te9
c := 'aaa'
; @ ec te10
c := 'aaaaa'
; @@ test-string-expression
; @ c t0
str := "some string"
; @ c t1
str := "\nstring\t\"with\\formatting\n"
; @ c t2
str := "line\
        split\
        string\
        "
; @ c t3
str := "multi
        line
        string
        "
; @ c t4
str := "line\
         split"
; @ fec te0
str := "aaa
; @ fec te1
str := "
; @ ec te2
"error"+"string"
; @ ec te3
str := "indention
    too short"
; @ ec te4
str := "indention\
    too short"
; @@ test-empty-expression
; @ c t0
str := _
; @ c t1
t := _
; @ c t2
so := _
; @ c t3
b := t is _ or ta is-not _
; @ ec te0
i := _
; @@ test-member-expression
; @ c t0
i := t.num
; @ c t1
i := tc.numb
; @ c t2
i := tc.num
; @ c t3
to := t
i := to.num
; @ c t4
tco := tc
i := tco.num
; @ c t5
i := t.t.num
; @ c t6
i := t.t.t.num
; @ ec te0
error
; @ ec te1
(i := 1).error
; @ ec te2
t.error
; @ ec te3
5.error
; @@ test-slice-expression
; @ c t0
c := str[13]
; @ c t1
user String? x
x := str[2:6]
; @ c t2
i := arr[13]
; @ c t3
user Array?{Int} x
x := arr[2:6]
; @ c t4
str[4] := c
; @ c t5
arr[4] := i
; @ ec t6
arr[2
; @ ec t7
arr[2:3
; @ ec t8
(i := 3)[2]
; @ ec t9
i[2]
; @ ec t10
arr[str]
; @ ec t11
arr[3:str]
; @ ec t12
arr[i += 3]
; @ ec t13
str[2:5] := so
; @ ec t14
arr[7:2] := Array{5:Int}()
; @ ec t15
user Array?{Test} at
at[0] := t
; @@ test-call-expression
; @ c t0
fun0()
; @ c t1
fun1(copy 3, user str, owner _)
; @ c t2
fun2()->(strong so, var io)
; @ c t3
var Int x
strong String? s
fun2()->(strong s, var x)
; @ c t4
fun3(copy 0)->(strong so)
; @ c t5
var Int x
fun4(copy fun5(copy 3)->(var x))
; @ c t6
fun6(
        copy 2,
        copy 3)->(
        var io,
        var io)
; @ c t7
fun5(copy 4)
; @ c t8
io := fun5(copy 4)
; @ c t9
so := fun3(copy 7)
; @ c t10
t.meth()
; @ c t11
to := t
to.meth()
; @ c t12
tc.methc()
; @ c t13
tc.methb()
; @ c t14
tc.meth()
; @ c t15
tco := tc
tco.meth()
; @ c t16
t.t.meth()
; @ c t17
fun1(copy 3, user str, owner so)
; @ c t18
fun3(copy 1)
fun5(copy 2)
; @ g t19
class Base
    var Int x
    func dynamic meth(owner Base b)
class Test(Base)
    func dynamic meth(owner Test t)
        base(owner t)
; @ g t20
class Test
    var Int x
    func dynamic meth()
func mock()->(weak Test t)
    t := Test()
    mock()->(weak t).meth()
; @ g t21
class Test
    var Int x
    func dynamic meth()->(weak Test t)
        self.meth().meth()
; @ ec te0
function( copy 1)
; @ ec te1
function(user)
; @ ec te2
function(copy 4,copy 3)
; @ ec te3
function(copy 2
; @ ec te4
function(error 4)
; @ ec te5
(i := 0)()
; @ ec te6
i()
; @ ec te7
fun5(copy 0)->(var 4)
; @ ec te8
fun7(weak _)->(weak tc)
; @ ec te9
fun5(copy i := 1)
; @ ec te10
fun5(user 8)
; @ ec te11
fun1(copy 3, user str, owner str)
; @ ec te12
fun3(copy 3)->(strong str)
; @ ec te13
fun7(weak _)->(weak tb)
; @ ec te14
fun0(copy i)
; @ ec te15
fun1()
; @ ec te16
fun0()->(copy i)
; @ ec te17
fun2()
; @ eg te18
struct Base
    var Int x
    func meth(owner Base b)
struct Test(Base)
    func meth(owner Test t)
        base(owner t)
; @ ec te19
var String{16} text
fun1(copy 3, user str, owner text)
; @ ec te20
owner Tb? tbo
fun7(weak tbo)
; @@ test-type-expression
; @ c t0
Test.meth(user t)
; @ c t1
Tb.methb(user tc)
; @ c t2
Tc.meth(user tc)
; @ ec t3
Error
; @@ test-base-expression
; @ g t0
struct Base
    var Int x
    func methb()
struct Mid(Base)
    func methm()
struct Top(Mid)
    func methb()
    func methm()
        base.methm()
; @ g t1
struct Base
    var Int x
    func methb()
struct Mid(Base)
    func methm()
struct Top(Mid)
    func methb()
    func methm()
        base.methb()
; @ ec te0
base
; @ eg te1
struct Test
    var Int x
    func mock()
        base
; @ eg te2
struct Base
    var Int x
struct Test(Base)
    var Int x
    func mock()
        base()
; @ eg te3
struct Base
    var Int x
struct Test(Base)
    func mock()
        base := self
; @ eg te4
struct Base
    var Int x
struct Test(Base)
    func mock()->(var Int x)
        x := base.x
; @@ test-block-expression
; @ c t0
i := 2 + (123)
; @ c t1
i := (123)
; @ c t2
i := (123 * (i - 4)) + 2
; @ ec t3
(error
; @@ test-unary-expression
; @ c t0
i := - i
; @ c t1
i := -
        i
; @ c t2
i := - - i
; @ c t3
b := not b
; @ c t4
b := not i > 3
; @ ec t5
{45}
; @ ec t6
-[
; @ ec t7
+ 2
; @ ec t8
- (i := 2)
; @ ec t9
- (i > 4)
; @ ec t10
not i
; @@ test-binary-expression
; @ c t0
i := 23 + 54
; @ c t1
i += (100 * 2) - (37 div 5 mod 2)
i *= 3
; @ c t2
i -= 12 *
        13
; @ c t3
b := 3 < 5 or 23 > 37
; @ c t4
b := 3 <= 5 and 23 >= 37
; @ c t5
b := i = 5 or i <> 37
; @ c t6
b := 2 < i < 12 = 2 * i
; @ c t7
t := tc
; @ c t8
owner String? s
s := so
; @ c t9
str := so
; @ c t10
b := t is ta or tc is-not tb
; @ c t11
c := '0' + 4
; @ c t12
b := fun0 is-not fun1
; @ c t13
b := b = b
; @ c t14
owner Tc? otc
tb := otc
; @ c t15
owner Array?{Test} tarr
tarr := _
; @ g t16
struct Test
    owner Test t
func fun()
    new Test t
    t := t.t
; @ ec te0
345 @ 2
; @ ec te1
80 +(
; @ ec te2
1 + 2 * 3
; @ ec te3
1 < i or 2 < i and 3 < i
; @ ec te4
1 not 2
; @ ec te5
1 := 2
; @ ec te6
1 += 2
; @ ec te7
1 -= 2
; @ ec te8
so := str
; @ ec te9
b := 1 or 2
; @ ec te10
b := t > 3
; @ ec te11
b := 1 > 4 > t
; @ ec te12
i := 3 + t
; @ ec te13
t += 3
; @ ec te14
i -= b
; @ ec te15
b := 3 is t
; @ ec te16
user Array?{Char} ca
ca := arr
; @ ec te17
owner Test? ot
ot := tb
; @ ec te18
b := b is b
; @ ec te19
b := t is t < 2
; @ ec te20
user Test? tu
t := tu
; @ ec te21
var Test tv(copy 0)
user Test tu(user tv)
tu := t
; @@ test-question-expression
; @ c t0
b := str?
; @ c t1
b := not str?
; @ c t2
b := t.fun?
; @ c t3
b := to?
; @ c t4
b := fun7(weak _)->(weak t)?
; @ g t5
struct Test
    weak String s
    func meth()->(var Bool res)
        res := self.s?
; @ ec te0
(i := 2)?
; @ ec te1
i?
; @@ test-exclamation-expression
; @ c t0
user String s(user str!)
; @ c t1
user Test tt(user t.t!)
; @ c t2
user Test? tu
tu := fun7(weak _)->(weak t)!
; @ c t3
i := tb!.num
; @ ec te0
(i := 2)!
; @ ec te1
i!
; @ ec te2
var String{8} s
s!
; @@ test-dynamic
; @ c t0
var Ta a(copy 1)
; @ c t1
user Ta? a
; @ c t2
ta := Ta(copy 7)
; @ c t3
new Ta a(copy 1)
; @ c t4
user Ta? a(user ta)
; @ c t5
user Ta? x
x := ta
; @ c t6
ta := tb
; @ c t7
ta := tc
; @ c t8
ta := _
; @ c t9
user Array?{Ta} aa
ta := aa[4]
; @ c t10
user Array?{Tc} ca
ta := ca[4]
; @ c t11
ta.dyn()
; @ c t12
tb.dyn()
; @ c t13
tc.dyn()
; @ c t14
tco := tc
tco.dyn()
; @ c t15
fun7(weak tc)->(weak ta)
; @ g t16
class Test
    var Int x
    func dynamic meth()
func mock()->(weak Test t)
    t := Test()
    t.meth()
; @ g t17
class Base
    var Int x
    func dynamic meth()
class Test(Base)
    func inst fun()
        self.meth()
; @ c t18
fun7(weak _)
; @@ test-function-object
; @ c t0
var Func{()} fun
fun := fun0
fun()
; @ c t1
var Func{(copy Int x)->(var Int y)} fun(copy fun5)
var Int x
fun(copy 9)->(var x)
; @ c t2
var Func{(user Test? self)} fun(copy Test.meth)
fun(user t)
; @ c t3
var Func?{()} fun
fun := _
b := fun?
; @ c t4
t.fun := fun0
t.fun()
; @ c t5
var Array{38:Func{()}} farr
farr[3] := fun0
farr[3]()
; @ c t6
var Func{(copy Int x,
        copy Int y)} fun
; @ g t7
func mock()->(var Func{()} f)
    f()
; @ g t8
func fun(copy Func?{(copy Int x,
        copy Int y)} fi)->(var Func{(copy Int x,
        copy Int y)} fo)
    fun(copy _)
struct Test
    var Func{(copy Int x,
            copy Int y)} fun
    func meth(copy Func{(copy Int x,
            copy Int y)} fi)->(var Func{(copy Int x,
            copy Int y)} fo)
; @ ec te0
var Func error
; @ ec te1
var Array{3:Func} error
; @ ec te2
var Func{} error
; @ ec te3
var Func{() } error
; @ ec te4
var Func{()} fun(copy fun1)
; @ ec te5
var Func{()->(var Int x)} fun
fun := fun0
; @@ test-builtin
; @ c t0
i.str(user str)
; @ c t1
b := true
; @ c t2
b := false
; @ ec t3
c := EOF
; @ c t4
i := arr.length
; @ c t5
i := str.length
; @ c t6
str.clear()
; @ c t7
str.equal(user str)->(var b)
; @ c t8
str.get(copy i)->(var c)
; @ c t9
str.append(copy c)
; @ c t10
str.new(user str)
; @ c t11
str.concat(user str)
; @ c t12
str.concat-int(copy i)
; @ c t13
str.find(user str)->(var i)
; @ c t14
str.has(copy c)->(var b)
; @ c t15
file-open-read(user str)->(owner fobj)
; @ c t16
file-open-write(user str)->(owner fobj)
; @ c t17
file-close(owner fobj)
; @ c t18
fobj.getc()->(var c, var b)
; @ c t19
fobj.putc(copy c)
; @ c t20
fobj.write(user str)
; @ c t21
user Array{String} argv(user sys.argv)
; @ c t22
sys.print(user str)
; @ c t23
sys.println(user str)
; @ c t24
sys.getchar()->(var c, var b)
; @ c t25
sys.getline(user str)
; @ c t26
sys.exit(copy i)
; @ c t27
sys.system(user str)->(var i)
; @ c t28
sys.getenv(user str, user str)->(var b)
; @ c t29
sys.stdout.putc(copy c)
; @ c t30
sys.stdin.getc()->(var c, var b)
; @ c t31
sys.stderr.putc(copy c)
; @ c t32
String.clear(user str)
; @ c t33
i := str.max-length
; @ ec te0
var File error
; @ ec te1
new File error
; @ ec te2
File()
; @ ec te3
var Sys error
; @ ec te4
new Sys error
; @ ec te5
Sys()
; @@ test-general
; @ g t0
user String str
; @ g t1


    

var Int x
; @ g t2
; comment

var Int x
; @ g t3
~~~ documentation ~~~

var Int x
; @ g t4
[; multi 
 line 
 comment ;]

var Int x
; @ g t5
~~~ multi 
 line    
 documentation
 confused by ~ or ~~ or ; or ~~ ~ ?
~~~

var Int x
; @ g t6
var String{12} s
user String us(user s)
user String gs(user "global text")
main
    var Int x(copy 6)
    x := 7
; @ tg t7
var String{12} s
func fun()
    s.clear()
; @-
module second
test dummy()
; @ eg te0
error 
; @ ec te1
1 + 2
; @ ec te2
return
i := 3
; @ ec te3
raise
i := 3
; @ eg te4
[; comment ;]?
; @ eg te5
main(
; @ eg te6
    struct Test
; @ eg te7
func f()
    x :=
        y
; @ feg te8
var Int x
; @ eg te9
var Int name
var Int name
; @ eg te10
func name()
var Int name
; @ eg te11
user Error error
; @ eg te12
var Int x(copy error)
; @ eg te13
[ ; error
; @@ test-struct
; @ g t0
struct Test
    var Int x
; @ g t1
struct Test
    var Int x
; @ g t2
struct Test1
    var Int x
struct Test2
    var Int x


struct Test3
    var Int x
; @ g t3
struct Test2(Test1)
    var Int y
struct Test1
    var Int x
; @ eg te0
struct(
; @ eg te1
struct error
; @ eg te2
struct ERror
; @ eg te3
struct Error-name
; @ eg te4
struct E
; @ eg te5
struct Int
; @ eg te6
struct Test
struct Test
; @ eg te7
struct Test(Base
; @ eg te8
struct Test
    error 
; @ feg te9
struct Test
; @ eg te10
struct Error
; @ eg te11
struct Error
    new 
; @ eg te12
struct Error
    new()
    new()
; @ eg te13
struct Error
    var Int x
    new()->(var Int x)
; @ eg te14
struct Error(Error)
    var Int x
; @ eg te15
struct Aerror(Berror)
    var Int x
struct Berror(Aerror)
    var Int x
; @@ test-class
; @ g t0
class Base
    var Int x
    owner Base b
    func inst stat()
    func dynamic dyn0()
    func dynamic dyn1()
class Mid(Base)
    var Int y
    owner Mid m
    func dynamic dyn0()
    func dynamic dyn2()
class Top(Mid)
    var Int z
    owner Top t
    func dynamic dyn0()
        base()
    func dynamic dyn3()
        base.dyn0()
; @ eg te0
class(
; @ eg te1
class Error
    var Int x
; @ eg te2
class Error
    func error f()
; @ eg te3
struct Base
    var Int x
    func meth()
class Error(Base)
    func dynamic meth()
; @ eg te4
class Base
    var Int x
    func dynamic meth()
class Error(Base)
    func inst meth()
; @@ test-function
; @ g t0
func name()
; @ g t1
func name(user String self, user String text, copy Int num)
; @ g t2
func name()->(owner String text, var Int num)
; @ g t3
func name(copy Char param)->(owner String out)
; @ g t4
func name(user Array{Int} array)
; @ g t5
func name(copy Func{(copy Int x)->(var Int y)} fun)->(var Func{()} joy)
; @ g t6
func name()
    var Int x
; @ g t7
func name(user String self, copy Int px, user String pu, owner String po)->(
        var String oself, var Int ox, weak String ou, owner String oo)
    var Int x
    user String? u
    owner String? o
    var String{12} v
    new String{12} n
    o := String{12}()
    u := "constant string"
    pu := po[2:6]
; @ g t8
struct Struct
    owner Struct s
    owner Array{Struct} as
class Class
    owner Class c
    owner Array{Class} ac
    func dynamic meth()
func name(
        owner Struct ps,
        owner Class pc,
        owner Array{Struct} pas,
        owner Array{Class} pac)
    owner Struct? s
    owner Class? c
    owner Array?{Struct} as
    owner Array?{Class} ac
    owner Array?{Int} ai
    owner Array?{File} af
; @ g t9
class Test
    var Int x
    func dynamic meth()
func name()->(owner Test? t)
    t := _
; @ g tm0
main
    var Int x
; @ eg te0
func(
; @ eg te1
func name
; @ eg te2
func Error()
; @ eg te3
func error_name()
; @ eg te4
func name()
func name()
; @ eg te5
var Int name
func name()
; @ eg te6
func name( )
; @ eg te7
func name(user)
; @ eg te8
func name(user String
; @ eg te9
func name(error Int x)
; @ eg te10
func name(user String str,user Int x)
; @ eg te11
func name()-()
; @ feg te12
func name()
; @ eg te13
func name()
        var Int x
; @ eg te14
func name(user Int x)
; @ eg te15
func name()->(copy Int x)
; @ eg te16
func name(copy String s)
; @ eg te17
func name(user Array error)
; @ eg te18
func name(copy Func error)
; @ eg te19
func name(user Array{Array{Int}} error)
; @ eg te20
func name(
    copy Int x)
; @ eg te21
func Type.Error.name()
; @ eg te22
func module.error.name()
; @ eg te23
func name(copy Int error, copy Int error)
; @ eg te24
func name(copy Int error)->(var Int error)
; @ eg te25
var Int error
func name(copy Int error)
; @ eg te26
func error()
func name(copy Int error)
; @ eg te27
func error(copy Int error)
; @ eg te28
func name(copy Int Error)
; @@ test-members
; @ g t0
struct Test
    var Int x
    weak String str
; @ g t1
struct Test
    var Int x
    func name()
        self.x := 2
; @ g t2
struct Test
    var Int x
    func name()
        var Int x
        x := self.x
; @ g t3
struct Test
    ; comment
    var Int x
; @ g t4
struct Test
    ~~~ documemtation ~~~
    var Int x
; @ g t5
struct Test
    [; multi 
    line 
    comment ;]
    var Int x
; @ g t6
struct Test
    ~~~ multi 
    line 
    documemtation
    ~~~
    var Int x
; @ g t7
var Int name
func fun()
struct Test1
    var Int name
    func fun()
struct Test2
    var Int fun
    func name()
; @ g t8
struct Test
    var Int x
    func fun()
        if self.x > 3
            self.x := 3
        do
            for n in 4
                self.x += n
; @ g t9
struct Test
    var Int x
    func fun() _
func Test.fun()
    self.x := 3
; @ g t10
func Test.fun(user String s)->(var Int x)
    x := s.length
struct Test
    var Int x
    func fun(user String s)->(var Int x) _
; @ g t11
struct Test
    var Int x
    new(copy Int x) _
func Test.new(copy Int x)
    self.x := x
; @ eg te0
struct Test
    var Int name
    var Int name
; @ eg te1
struct Test
    func name()
    var Int name
; @ eg te2
struct Test
    func name()
    func name()
; @ eg te3
struct Test
    var Int name
    func name()
; @ eg te4
struct Test
    var Int x
    func meth()
        owner Test? error
        error := self
; @ eg te5
struct Test
    var Int x
    func name() 
; @ eg te6
struct Test
    var Int x
    func error.name()
; @ eg te7
struct Test
    var Int x
    func fun()
func Test.fun()
; @ eg te8
func Test.fun()
struct Test
    var Int x
    func fun() _
func Test.fun()
; @@ test-return
; @ g t0
func name()
    return
; @ g t1
func name()
    raise
; @ g t2
func name()
    raise "some error"
; @ g t3
func name(user Array{String} arr)
    raise arr[3]
; @ eg te0
func name()
    return()
; @ eg te1
func name()
    raise()
; @ eg te2
func name()
    raise 2
; @@ test-code-variables
; @ c t0
var Int x
; @ c t1
user String? s
; @ c t2
owner Array?{Int} a
; @ c t3
user Test? tt
; @ c t4
var String{12} s
; @ c t5
var Array{12:Int} a
; @ c t6
var Array{12:Test} a
; @ c t7
var Array{12:String{7}} sa
; @ c t8
new String{12} s
so := s
; @ c t9
var Array{12:Tc} a
; @ g t10
func fun()
    var String{4} sv
    if 1 > 2
        user String su(user sv[1:2])
; @ ec te0
var Int
; @ ec te1
var Int Error
; @ ec te2
var Int errorName
; @ ec te3
var Int name
var Int name
; @ ec te4
var Int name
do
    var Int x
    do
        var Int name
; @ eg te5
var Int name
func mock()
    var Int name
; @ eg te6
func name()
func mock()
    var Int name
; @ eg te7
struct Test
    var Int x(1)
; @ ec te8
new
; @ ec te9
var Array{i:Int} error
; @ ec te10
var Int error--name
; @@ test-initialize
; @ c t0
t := Test(copy i)
; @ c t1
str := String{arr[0]}()
; @ c t2
arr := Array{arr[0]:Int}()
; @ c t3
owner Array{Test} a(owner Array{arr[0]:Test}())
; @ c t4
owner Array{String} sa(owner Array{arr[0]:String{arr[1]}}())
; @ c t5
var Int x(copy arr[0])
; @ c t6
user String? s(user str)
; @ c t7
var String{12} s(user "some string")
; @ c t8
new String?{i} s(user str)
; @ c t9
user Test? tt(user tc)
; @ c t10
var Test tt(copy 3)
; @ c t11
new Test tt(copy 3)
; @ c t12
t := Test(copy 3)
; @ c t13
user Tb? tt(user tb)
; @ c t14
owner Ta? ota(owner tb)
; @ ec te0
Int()
; @ ec te1
var String s
; @ ec te2
var Array{4:String} sa
; @ ec te3
new String s
; @ ec te4
String()
; @ ec te5
user Array a
; @ ec te6
new Array a
; @ ec te7
Array()
; @ ec te8
var Array{23} a
; @ ec te9
var Array{1:Array{2:Int}} a
; @ ec te10
var Array{1
; @ ec te11
var String{12
; @ ec te12
var Array{error:Int} a
; @ ec te13
var Array{"12":Int} a
; @ ec te14
user Int x
; @ ec te15
new Int x
; @ ec te16
var Array{4:Int} a(copy 1)
; @ ec te17
var Bool x(var 1)
; @ ec te18
var Int x(var 1, var 2)
; @ eg te19
struct Test
    var Int x
func mock()
    Test(copy 1)
; @ ec te20
var Int x(user 3)
; @ ec te21
owner String? s(user so)
; @ ec te22
owner String s(owner str)
; @ ec te23
var Array{1:Int:Int} a
; @ ec te24
owner Test ot(owner tb)
; @ ec te25
user String s
; @ ec te26
user String s(user _)
; @ ec te27
weak String s(user str)
; @@ test-comment
; @ c t0
; comment

var Int x
; @ c t1
~~~ documemtation ~~~

var Int x
; @ c t2
[; multi 
line 
comment ;]

var Int x
; @ c t3
~~~ multi 
line 
documemtation
~~~

var Int x
; @@ test-if-else
; @ c t0
if t.num > 3
    i -= 2
; @ c t1
if i > 3
    i -= 2
else
    i += 1
; @ c t2
if i > 3
    i -= 3
else-if t.num > 2
    i -= 2
else-if t.num > 1
    i -= 1
else
    i += 1
; @ c t3
if b
    return
i := 3
; @ c t4
if b and
        b
    i += 1
; @ c t5
if b
    var String{4} sa
    if b
        var String{4} sb
    else-if b
        var String{4} sc
    else
        var String{4} sd
else-if b
    var String{4} se
else
    var String{4} sf
; @ ec te0
if 3
; @ ec te1
if b
    error
; @ ec te2
if b
    i := 0
else
    error
; @ ec te3
if b
    i := 0
else-if b
    error
; @ ec te4
if b
    return
    i := 3
; @ ec te5
if()
; @ ec te6
else
; @ ec te7
if false
    ; ...
else 
; @ ec te8
else-if
; @ ec te9
if false
    ; ...
else-if()
; @ feg te10
func error()
    if b
; @@ test-do-loop
; @ c t0
do
    var Int x
; @ c t1
do
    break
; @ c t2
do
    while t.num > 3
; @ c t3
do
    continue
; @ c t4
do
    if true
        while false
; @ c t5
do
    var String{4} sa
    while b
    break
    continue
    if b
        return
    do
        var String{4} sb
        while b
        break
        continue
        if b
            return
        do
            var String{4} sc
            while b
            break
            continue
            if b
                return
; @ ec te0
do(
; @ ec te1
while true
; @ ec te2
continue
; @ ec te3
do
    while 2
; @ ec te4
do
    error
; @ ec te5
do
    var Int error
do
    var Int error
; @ ec te6
do
    while i := 3
; @ ec te7
do
    while
; @ ec te8
do
    continue error
; @ ec te9
break
; @ ec te10
do
    break error
; @@ test-for-loop
; @ c t0
for n in 5
    i += n
; @ c t1
for n in t.num:str.length + 2
    i += n
; @ c t2
for ch in str
    c := ch
; @ c t3
for n in arr
    i += n
; @ c t4
for s in sarr
    s.clear()
; @ c t5
var Int n
for n in 5
    i += n
; @ c t6
for n in 5
    i += n
for n in 7
    i += n
; @ c t7
for n in 1 +
        2
    i += n
; @ c t8
for n in 6
    var String{4} sa
    break
    continue
    if b
        return
    for ch in str
        var String{4} sb
        break
        continue
        if b
            return
; @ c t9
user String s(user "text")
for ch in s
    c := ch
; @ ec te0
for(
; @ ec te1
for n
; @ ec te2
for n error
; @ ec te3
for n in fun0()
; @ ec te4
for n in str:8
; @ ec te5
for n in 5
    error
; @ ec te6
for n in arr
    i += n
for n in sarr
; @@ test-testing
; @ c ta0
assert t.num = 2
; @ c ta1
assert-error t.num
; @ c ta2
assert-error fun0()
; @ c ta3
assert-error t.num, "expected error"
; @ c ta4
assert-error fun0(), "expected error in the function"
; @ c ta5
assert-error t.num,
        "expected error in new line"
; @ c ta6
if b
    var String{4} s
    assert b
    assert-error s[1:2]
    do
        assert-error s[1:2]
; @ g tm0
func fun()
    fun()
mock fun()
    raise
; @ g tm1
mock fun()
func fun()
    fun()
; @ g tm2
mock Test.meth(copy Int x)
struct Test
    var Int x
    func meth(copy Int x)
        self.meth(copy x)
; @ g tm3
mock Test.meth(copy Int x)
class Test
    var Int x
    func dynamic meth(copy Int x)
        self.meth(copy x)
; @ g tm4
func fun(copy Int x)->(var Int y)
mock fun(copy Int x)->(var Int y)
    fun.mocked(copy x)->(var y)
    fun.active := false
    fun(copy x)->(var y)
    fun.active := true
; @ g tm5
struct Test
    var Int x
    func meth(copy Int x)->(var Int y)
        self.meth(copy x)->(var y)
mock Test.meth(copy Int x)->(var Int y)
    self.meth.mocked(copy x)->(var y)
    Test.meth.mocked(user self, copy x)->(var y)
    self.meth.active := false
    Test.meth(user self, copy x)->(var y)
    Test.meth.active := true
; @ g tm6
class Test
    var Int x
    func dynamic meth(copy Int x)->(var Int y)
        self.meth(copy x)->(var y)
mock Test.meth(copy Int x)->(var Int y)
    Test.meth.mocked(user self, copy x)->(var y)
    Test.meth.active := false
    Test.meth(user self, copy x)->(var y)
    Test.meth.active := true
; @ g tm7
func fun()
    sys.print(user "mock print")
    sys.print.mocked(user "really print")
    Sys.print.active := false
    sys.print.active := true
mock Sys.print(user String text)
; @ tg tt0
func fun0()
    var Int x(copy 4)
    x += 1
    var Int y(copy 5)
    y := x
    if y > 3
        y := 3
    else-if y < 0
        y := 0
    else
        y += 1
    try
        x := 0
        sys.print(user _)
        y := 0
    catch
        x := 1
        x := 2
    if x > 3
        return
    else
        raise
    do
        while x > 1
        if x = 5
            continue
    for n in 3
        x += y
; @-
module ut
func fun1()
    fun0()
test fun2()
    fun1()
; @ tg tt1
func fun()
    var Int x
main
; @-
module second
test fun0()
test fun1()
; @ g tmg0
mock Test.delete()
    var Ref? r(copy self)
struct Test
    weak String s
; @ g tmg1
mock delete()
    var Ref? r(copy self)
main
; @ g tmg2
mock new()->(var Bool allocate-success)
    allocate-success := false
main
; @ c tr0
var Ref r
; @ c tr1
var Ref r
r := str
; @ c tr2
var Ref r
r := _
; @ c tr3
var Ref r(copy str)
; @ c tr4
var Ref r
assert r is r
; @ ec te0
assert 3
; @ ec te1
assert error
; @ ec te2
assert-error error
; @ eg te3
test fun(copy Int x)
; @ eg te4
test fun()->(copy Int x)
; @ eg te5
mock error()
; @ eg te6
mock Error.fun()
; @ eg te7
struct Test
    var Int x
mock Test.error()
; @ eg te8
mock fun(owner String s)
func fun(user String s)
; @ eg te9
mock fun(user Int s)
func fun(user String s)
; @ eg te10
mock fun(user Array{Char} a)
func fun(user Array{Int} a)
; @ ec te11
assert
; @ ec te12
assert-error
; @ eg te13
mock()
; @ eg te14
func fun()
mock fun()
mock fun()
; @ eg te15
struct Test
    var Int x
    func fun()
mock Test.fun()
mock Test.fun()
; @ eg te16
mock delete()
mock delete()
; @ eg te17
struct Test
    var Int x
mock Test.delete()
mock Test.delete()
; @ ec te18
assert-error t.num , "error"
; @ ec te19
assert-error t.num,"error"
; @ ec te19-copy
assert-error t.num,"error"
; @ ec te20
assert-error t.num,  "error"
; @ ec te21
assert-error t.num, error
; @ eg te22
mock new()->(var Bool res)
mock new()->(var Bool res)
; @ eg te23
mock new()->(var Int x)
; @ eg te24
mock new()
; @ eg te25
mock new(copy Int x)->(var Bool res)
; @ eg te26
mock new()->(var Bool res, var Int x)
; @ eg te27
mock delete(copy Int x)
; @ eg te28
mock delete()->(copy Int x)
; @ eg te29
func fun()
mock fun()
    fun.error
; @ eg te30
class Test
    var Int x
    func dynamic meth()
mock Test.meth()
    self.meth.mocked()
; @ eg te31
test
; @@ test-native
; @ g tf0
native func external()
func call()
    external()
; @ g tf1
class Test
    var Int x
    func dynamic meth()
native func external(copy Int i, user String? s, user Test? ta)->(var Int io)
func call()
    var Int i
    user String? s
    user Test? ta
    external(copy 5, user s, user ta)->(var i)
; @ g tv0
native var Int x
func use()
    x := 2
; @ g tt0
native type Native
native func external(copy Native n)->(var Native no)
; @ eg te0
native()
; @ eg te1
native error
; @ eg te2
native error 
; @ eg tef1
native func error(owner String s)
; @ eg tef2
native func error()->(user String s)
; @ eg tef3
native func error()->(owner String s)
; @ eg tef4
native func error()
native func error()
; @ eg tev3
native var String s
; @@ test-parameter-type
; @ g t0
struct Test{Generic}
    weak Generic item
    weak Array{Generic} arr
    func set(weak Generic item, weak Array{Generic} arr)
        weak Generic x(weak item)
        self.item := x
        self.arr := arr
        new Test{Generic} t
        t.item := self.item
        self.item := t.item
; @ g t1
struct Test{Generic}
    owner Generic item
    func get()->(user Generic item)
        item := self.item
; @ g t2
struct Test{First:Second:Third}
    weak First first
    weak Second second
    weak Third third
    func set(weak First first, weak Second second, weak Third third)
        self.first := first
        self.second := second
        self.third := third
func use(weak String first, weak Sys second, weak File third)
    var Test{String:Sys:File} t
    t.first := first
    t.second := second
    t.third := third
    t.set(weak first, weak second, weak third)
; @ g t3
struct Base
    var Int x
struct Test{Generic}(Base)
; @ c t4
d.item := str
; @ c t5
str := d.item
; @ c t6
d.arr := sarr
; @ c t7
str := d.arr[4]
; @ c t8
var Array{5:Data{String}} ad
str := ad[2].item
; @ c t9
var Array{5:Data{String}} ad
str := ad[2].arr[3]
; @ c t10
d.set(owner _, user _)
; @ c t11
var Data{Data{Data{String}}} dr
str := dr.item.item.item
; @ c t12
d.set(owner so, user sarr)
; @ c t13
d.get()->(weak str)
d.get().clear()
; @ c t14
var Data dg
; @ c t15
user Data? dg(user d)
; @ c t16
Data{String}.set(user d, owner so, user sarr)
; @ g t17
struct Test{Generic}
    weak Test{Generic} next
    func meth(weak Test{Generic} next)->(user Test?{Generic} out)
        self.next := next
        out := self
; @ c t18
var Data{Tb} dt
dt.item := tc
ta := dt.item
owner Tc? otc
dt.set(owner otc, user _)
dt.get()->(weak ta)
i := dt.get().numa
fun7(weak dt.item)->(weak dt.item)
user Tb? tb2(user dt.item)
tb2 := dt.item
; @ g t19
struct Base{Generic}
    weak Generic item
    func get()->(weak Generic item)
struct Test(Base{String})
    func set(weak String text)
        self.item := text
        self.get()->(weak text)
func fun(user Test test, weak String text)
    test.item := text
    test.set(weak text)
    text := test.item
    test.get()->(weak text)
    test.get().clear()
; @ g t20
class Base{Param}
    weak Param item
    func dynamic set(weak Param item)
    func dynamic get()->(weak Param item)
class Test{Generic}(Base{Generic})
    func dynamic set(weak Generic item)
    func dynamic get()->(weak Generic item)
func mock(weak Test{String} test, weak String text)
    test.set(weak text)
    test.get()->(weak text)
    test.get().clear()
; @ g t21
struct Test{Param}
    weak Param item
    func meth(weak Param in)->(weak Param out) _
func Test.meth(weak Param in)->(weak Param out)
    weak Param p(weak in)
    out := p
    self.item := p
    self.meth(weak p)->(weak p)
; @ eg teg0
struct Test{First:Second:Third
; @ eg teg1
struct Test{Generic}
    var Generic error
; @ eg teg2
struct Test{Generic}
    weak Generic item
    func meth(copy Generic error)
; @ eg teg3
struct Test{Generic}
    weak Generic item
    func meth(weak String s)
        self.item := s
; @ eg teg4
struct Test{Generic}
    weak Generic item
    func meth(user String s)
        s := self.item
; @ eg teg5
struct Test{Generic}
    weak Generic item
    func meth()
        var Generic error
; @ eg teg6
struct Test{First:Second}
    weak First first
    weak Second second
    func meth()
        self.first := self.second
; @ eg teg7
struct Test{error}
    var Int x
; @ eg teg8
struct Test{Generic}
    weak Array?{Generic} arr
    func meth()
        user Generic? x
        x := self.arr[2]
; @ eg teg9
struct Test{Generic}
    weak Array{Generic} arr
    func meth()
        var Array{12:Generic} arr
; @ eg teg10
struct Test{Generic}
    weak Array{Generic} arr
    func meth()
        self.arr := Array{12:Generic}()
; @ eg teg11
struct Test{First:Second:Third}
    weak First first
    weak Second second
    weak Third third
func meth(user Test{String:String} t)
    user Test{String:String:String} error(user t)
; @ eg teg12
struct Base{Param}
    weak Param item
struct Error(Base)
; @ eg teg13
struct Base
    weak Int x
struct Error(Base{String})
; @ eg teg14
struct Base{Param}
    weak Param item
struct Error(Base{String:String})
; @ eg teg15
struct Base{Param0:Param1}
    weak Param0 item0
    weak Param1 item1
struct Error(Base{String})
; @ ec tec0
var Data{Int} error
; @ ec tec1
var Data{String:String} error
; @ ec tec2
var Data{Error} error
; @ ec tec3
var Char{String} error
; @ ec tec4
var Data dg
str := dg.item
; @ ec tec5
var Data dg
d := dg
; @ ec tec6
t := d.item
; @ ec tec7
var Data{Array{Int}} error
; @@ test-parameter-inheritance
; @ g t0
struct Base{Generic}
    weak Generic item
struct Test(Base{String})
    func set(weak String s)
        self.item := s
        Test.set(user Test(), weak s)
func use(weak String s)
    var Test t
    t.item := s
; @ g t1
struct Base{Generic}
    weak Generic item
struct Test{Param}(Base{Param})
    func set(weak Param i, weak String s)
        self.item := i
        Test{String}.set(user Test{String}(), weak s, weak s)
func use(weak String s)
    var Test{String} t
    t.item := s
; @ g t2
struct Base{Pbase}
    weak Pbase item
    func set(weak Pbase i)
struct Mid{Pmid}(Base{Pmid})
    func set(weak Pmid i)
struct Top(Mid{String})
    func set(weak String s)
        base(weak s)
        self.item := s
struct Test(Top)
    func set(weak String s)
        base(weak s)
        self.item := s
        Top.set(user Top(), weak s)
        Test.set(user Test(), weak s)
        Mid{String}.set(user Top(), weak s)
func use(weak String s)
    var Test t
    t.item := s
; @ g t3
struct Base{Generic}
    weak Generic item
struct Test{Generic}(Base{Generic})
    func set(weak Generic i, weak String s)
        self.item := i
        Test{String}.set(user Test{String}(), weak s, weak s)
func use(weak String s)
    var Test{String} t
    t.item := s
; @ g t4
struct Base{First:Second}
    weak First first
    weak Second second
struct Mid{Param:Third}(Base{Param:Sys})
    weak Third third
    func set(weak Param first, weak Sys second, weak Third third)
        self.first := first
        self.second := second
        self.third := third
struct Top{Generic}(Mid{Generic:File})
    func set(weak Generic first, weak Sys second, weak File third)
        self.first := first
        self.second := second
        self.third := third
struct Test(Top{String})
    func set(weak String first, weak Sys second, weak File third)
        self.first := first
        self.second := second
        self.third := third
func use(weak String first, weak Sys second, weak File third)
    var Test t
    t.first := first
    t.second := second
    t.third := third
; @ g t5
struct First{FirstGeneric}
    weak FirstGeneric item
struct Second{SecondGeneric}
    weak SecondGeneric item
struct Test{Generic}(First{Second{Generic}})
    func set(weak Generic g, weak Second{Generic} sg)
        self.item := sg
        self.item.item := g
func use(weak String s, weak Second{String} ss)
    var Test{String} t
    t.item := ss
    t.item.item := s
; @ g t6
struct BaseGen{FirstGeneric}
    weak FirstGeneric item
struct TestGen{SecondGeneric}(BaseGen{SecondGeneric})
struct Base
    var Int x
struct Test(Base)
func test()
    user BaseGen?{Base} bb
    user BaseGen?{Test} bt
    user TestGen?{Base} tb
    user TestGen?{Test} tt
    bb := tb
    bt := tt
    bb := bt
    tb := tt
    bb := tt
; @ eg te0
struct Base{Generic}
    weak Generic item
struct Test{Param}(Base{Param})
    weak Generic error
; @ eg te1
struct Base{Generic}
    weak Generic item
struct Test(Base{String})
    func set(weak File error)
        self.item := error
; @ eg te2
struct Base{Generic}
    weak Generic item
struct Test{Param}(Base{Param})
    func set(weak String error)
        self.item := error
; @ eg te3
struct Base{Pbase}
    weak Pbase item
struct Mid{Pmid}(Base{Pmid})
struct Top(Mid{String})
struct Test(Top)
    func set(weak File error)
        self.item := error
; @@ test-error-handling
; @ c t0
try
    t.num := 1
    fun0()
catch
    i := t.num
    fun4(copy 2)
; @ c t1
try
    t.num := 1
    fun0()
; @ c t2
try
    t.num := 1
    try
        fun0()
    catch
        fun4(copy 2)
catch
    try
        i := arr[3]
    catch
        i := t.num
; @ c t3
try
    var String{4} sa
    try
        var String{4} sb
    catch
        var String{4} sc
catch
    var String{4} sd
    try
        var String{4} se
    catch
        var String{4} sf
; @ ec te0
try()
; @ ec te1
catch
; @ ec te2
try
catch()
; @ ec te3
try
; @ ec te4
try
    i := 1
catch
; @ ec te5
try
    i := 1
i := 2
catch
    i := 3
; @@ test-for-each
; @ g t0
struct TestIterator
    var Int counter
    new(copy Int count)
    func has()->(var Bool has-data)
    func get()->(var Int num)
    func next()
func fun()->(var Int i)
    for n in TestIterator(copy 6)
        var String{4} s
        i := n
; @ g t1
struct TestIterator
    weak String value
    func has()->(var Bool has-data)
    func get()->(user String text)
        text := self.value
    func next()
func fun(user TestIterator iter)
    user String? s
    for t in iter
        s := t
; @ g t2
struct TestIterator{Generic}
    weak Generic item
    func has()->(var Bool has-data)
    func get()->(user Generic item)
        item := self.item
    func next()
class Test
    var Int x
    func dynamic fun()
func fun(user TestIterator{String} siter, user TestIterator{Test} titer)
    user String? os
    user Test? ot
    for s in siter
        os := s
    for t in titer
        ot := t
; @ g t3
class TestIterator{Generic}
    weak Generic item
    func dynamic has()->(var Bool has-data)
    func dynamic get()->(user Generic item)
        item := self.item
    func dynamic next()
func f-mock(user TestIterator{String} iter)
    user String? s
    for t in iter
        s := t
; @ eg te0
struct TestIterator
    var Int num
    func get()->(var Int num)
    func next()
func f-mock()
    for n in TestIterator()
; @ eg te1
struct TestIterator
    var Int num
    func has(copy Int x)->(var Bool has-data)
    func get()->(var Int num)
    func next()
func f-mock()
    for n in TestIterator()
; @ eg te2
struct TestIterator
    var Int num
    func has()
    func get()->(var Int num)
    func next()
func f-mock()
    for n in TestIterator()
; @ eg te3
struct TestIterator
    var Int num
    func has()->(var Bool has-data, var Int x)
    func get()->(var Int num)
    func next()
func f-mock()
    for n in TestIterator()
; @ eg te4
struct TestIterator
    var Int num
    func has()->(var Int x)
    func get()->(var Int num)
    func next()
func f-mock()
    for n in TestIterator()
; @ eg te5
struct TestIterator
    var Int num
    func has()->(var Bool has-data)
    func next()
func f-mock()
    for n in TestIterator()
; @ eg te6
struct TestIterator
    var Int num
    func has()->(var Bool has-data)
    func get(user Int x)->(var Int num)
    func next()
func f-mock()
    for n in TestIterator()
; @ eg te7
struct TestIterator
    var Int num
    func has()->(var Bool has-data)
    func get()
    func next()
func f-mock()
    for n in TestIterator()
; @ eg te8
struct TestIterator
    var Int num
    func has()->(var Bool has-data)
    func get()->(var Int num, var Int x)
    func next()
func f-mock()
    for n in TestIterator()
; @ eg te9
struct TestIterator
    var Int num
    func has()->(var Bool has-data)
    func get()->(owner String s)
    func next()
func f-mock()
    for n in TestIterator()
; @ eg te10
struct TestIterator
    var Int num
    func has()->(var Bool has-data)
    func get()->(weak String s)
    func next()
func f-mock()
    for n in TestIterator()
; @ eg te11
struct TestIterator
    var Int num
    func has()->(var Bool has-data)
    func get()->(var Int num)
func f-mock()
    for n in TestIterator()
; @ eg te12
struct TestIterator
    var Int num
    func has()->(var Bool has-data)
    func get()->(var Int num)
    func next(user Int x)
func f-mock()
    for n in TestIterator()
; @ eg te13
struct TestIterator
    var Int num
    func has()->(var Bool has-data)
    func get()->(var Int num)
    func next()->(var Int x)
func f-mock()
    for n in TestIterator()
; @ eg te14
struct ConditionalIterator
    weak String str
    func has()->(var Bool has-data)
    func get()->(var String? num)
    func next()
struct NonConditionalIterator
    weak String str
    func has()->(var Bool has-data)
    func get()->(var String num)
    func next()
func f-mock()
    for s in NonConditionalIterator()
    for s in ConditionalIterator()
; @@ test-complex-fields
; @ g t0
struct Test
    var Bstruct b
    func test()
        weak Bstruct b(weak self.b)
        b := self.b
        self.b.meth()
        Bstruct.meth(user self.b)
        user Bstruct b2(user self.b.b)
        b2 := self.b.b
        self.b.b.meth()
        self.b.b := b
        Bstruct.meth(user self.b.b)
        var Test t
        self.b.x := 5
        Astruct.meth(user self.b)
        if self.b is b or b2 is-not self.b
class Astruct
    var Int x
    func dynamic meth()
class Bstruct(Astruct)
    weak Bstruct b
    func dynamic meth()
; @ eg te0
struct Test
    var String{12} error
; @ eg te1
struct Test
    var Array{12:Int} error
; @ eg te2
struct Test
    var Test error
; @ eg te3
struct Test
    var Base error
struct Base
    var Test t
; @ eg te4
struct Abase
    var Berror b
struct Aerror(Abase)
struct Bbase
    var Aerror a
struct Berror(Bbase)
; @ eg te5
struct Base
    var Int x
struct Test
    var Base b
    func test(user Base b)
        self.b := b
; @ eg te6
struct Base
    var Int x
struct Test
    var Base b
    func error()
        assert self.b?
; @@ test-enum
; @ g t0
enum MyEnum
    VALUE
    ANOTHER-VALUE
    LAST-VALUE
func dummy()
    var Int x(copy MyEnum.VALUE)
    x += MyEnum.ANOTHER-VALUE
    x -= MyEnum.length
; @ g t1
enum MyEnum
    VALUE
    ANOTHER-VALUE
    LAST-VALUE
var Array{MyEnum.length:Int} arr
; @ eg te0
enum MyEnum
    VALUE
func dummy()
    var Int x(copy MyEnum.ERROR)
; @ ec te1
i := Error.VALUE
; @ eg te2
enum MyEnum
    VALUE
func dummy()
    var Int x(copy MyEnum.error)
; @ eg te3
enum My-Enum
; @ eg te4
enum MyEnum
    Error
; @ eg te5
enum MyEnum
    ERRoR
; @ eg te6
enum
; @ eg te7
enum MyEnum
    VALUE(0)
; @ eg te8
enum MyEnum
; @ eg te9
enum MyEnum
        VALUE
; @ eg te10
enum Error
    VALUE
enum Error
; @ eg te11
struct Error
    var Int x
enum Error
; @ eg te12
enum Error
    VALUE
struct Error
    var Int x
; @@ test-constant
; @ g t0
const Int NUMBER 12
; @ g t1
const Int SIZE 12
var Array{SIZE + 3:Int} arr
; @ g t2
const Int LARGE - (2 * SMALL) + 1
const Int SMALL 7
; @ eg te0
const
; @ eg te1
const Bool
; @ eg te2
const Int
; @ eg te3
const Int Error
; @ eg te4
const Int ERROR
; @ eg te5
const Int NAME false
; @ eg te6
var Int x
const Int NAME x
; @ eg te7
const Int ERROR ERROR + 1
; @ eg te8
const Int A-ERROR B-ERROR
const Int B-ERROR - (2 * A-ERROR) + 1
; @ eg te9
const Int NUMBER 12
func dummy()
    NUMBER := 3
; @ eg te10
const Int NUMBER 12
func dummy()->(var Int x)
    dummy()->(var NUMBER)
; @@ test-module
; @ tg t0
enum Enum
    VALUE
const Int SIZE 12
struct Test
    var Int x
    func meth()
var Test t
func fun()
    t.x := Enum.VALUE + SIZE
    fun()
    Test.meth(user t)
    second.t.x := second.Enum.VALUE + second.SIZE
    second.fun()
    second.Test.meth(user second.t)
    new second.Test nt
; @-
module second
enum Enum
    VALUE
const Int SIZE 12
struct Test(ut.Test)
    func meth()
var Test t
func fun()
    t.x := Enum.VALUE + SIZE
    fun()
    Test.meth(user t)
    ut.t.x := ut.Enum.VALUE + ut.SIZE
    ut.fun()
    ut.Test.meth(user ut.t)
    new ut.Test nt
test dummy()
; @ tg t1
func fun()
struct Test
    var Int x
    func meth()
        fun()
        self.meth()
; @-
module second
mock ut.fun()
mock ut.Test.meth()
test dummy()
; @ tg t2
native type Native
native var Int x
native func external()
func fun()
    x := 0
; @-
module second
test use()
    var Native n
    x := 2
    external()
; @ ec te0
ut.error
; @ eg te1
var Int ut
; @ eg te2
func ut()
; @ eg te3
var error.Test x
; @ eg te4
var ut.Error x
; @ etg te5
; nothing
; @-
module(error)
; @ etg te6
; @-
module Error
; @ etg te7
; @-
module true
; @ etg te8
; @-
module file-open-read
; @ etg te9
; @-
func fun()
; @ ec te10
fun0().Error
; @ ec te11
i.Error
; @ ec te12
ut.Error.VALUE
; @@ test-memory
; @ g to0
struct Test
    owner String s
func use(user String s)
func take(owner String s)
func fun(owner String? s, user Test tu, owner Test to)
    s := _
    s := String{12}()
    s.clear()
    to.s := String{12}()
    user String su(user tu.s)
    use(user tu.s)
    take(owner to.s)
    var Array{12:Int} arr
    arr[4] := arr[8]
; @ g tu0
func deleting()->(owner String? s)
    s := _
func fun(user String s)->(owner String? so)
    s.clear()
    deleting()->(owner so)
; @ g tu1
func deleting()->(strong String? s)
    s := _
func fun()
    strong String? so(strong String{12}())
    user String? s(user so)
    s.clear()
    deleting()->(strong so)
; @ g tu2
func deleting()->(strong String? s)
    s := _
func fun()
    strong String? so(strong String{12}())
    weak String? s(weak so)
    deleting()->(strong so)
    s.clear()
; @ c tu3
user String? s
so := _
s := so
s.clear()
; @ g tu4
struct Test
    weak String s
    func get()->(user String s) _
func Test.get()->(user String s)
    s := self.s
; @ eg teo0
struct Test
    owner String s
func fun(user Test t)
    t.s := String{12}()
; @ eg teo1
struct Aa
    var Int x
struct Bb
    owner Aa a
func fun(user Bb b)
    owner Aa a(owner b.a)
; @ eg teo2
struct Aa
    var Int x
struct Bb
    owner Aa a
func take(owner Aa a)
func fun(user Bb b)
    take(owner b.a)
; @ eg teo3
struct Aa
    owner String? s
struct Bb
    weak Aa a
func fun(owner Array{Bb} b)
    b[3].a.s := _
; @ eg teo4
struct Test
    owner String? s
func get-user()->(weak Test t)
func fun()
    weak Test? t
    get-user()->(weak t).s := _
; @ eg teo5
struct Test
    owner String? s
func get-user()->(weak Test t)
func fun()
    get-user().s := _
; @ ec teu0
user String? s
so := _
c := s[2]
; @ ec teu1
user String? s
user String? s2
so := _
s2 := s
; @ ec teu2
user String? s
so := _
i := s.length
; @ ec teu3
user String? s
so := _
String.clear(user s)
; @ ec teu4
user String? s
so := _
b := not (false or s.length > 3)
; @ eg teu5
func deleting(owner String? s)
func fun(user String s)
    deleting(owner _)
    s.clear()
; @ eg teu6
func deleting()->(owner String? s)
    s := _
func proxy()
    deleting()
func fun(user String s)
    proxy()
    s.clear()
; @ eg teu7
func deleting()->(owner String? s)
    proxy()
    s := _
func proxy()
    deleting()
func fun(user String s)
    proxy()
    s.clear()
; @ eg teu8
struct Test
    var Int x
    func deleting()->(owner String? s)
        s := _
    func fun(user String s)
        self.deleting()
        s.clear()
; @ eg teu9
func deleting()->(owner String? s)
    s := _
func fun(user String s)
    deleting()
    s.clear()
; @ eg teu10
func deleting()
    owner String? s
func fun(user String s)
    deleting()
    s.clear()
; @ eg teu11
func deleting()
    var String{12} s
func fun(user String s)
    deleting()
    s.clear()
; @ eg teu12
func deleting()
    strong String? s
func fun(user String s)
    deleting()
    s.clear()
; @ eg teu13
func deleting()
    user String s(user "I am a string")
func fun(user String s)
    deleting()
    s.clear()
; @ eg teu14
func deleting()
    var Int x(copy String{12}().length)
func fun(user String s)
    deleting()
    s.clear()
; @ eg teu15
struct Test
    owner String s
func deleting(owner Test? ta, owner Test? tb)
    ta.s := tb.s
func fun(user String s)
    deleting(owner _, owner _)
    s.clear()
; @ ec teu16
user String? s
d.set(owner _, user _)
s.clear()
; @ eg teu17
struct Base{Atype}
    var Int x
    func fun(owner Atype? a)
struct Test{Btype}(Base{Btype})
    func fun()
        base(owner _)
func fun(user String s)
    var Test{String} t
    t.fun()
    s.clear()
; @ eg teu18
struct Base
    var Int x
struct Test(Base)
func deleting(owner Base? b)
func fun(user Test t)
    deleting(owner _)
    t.x := 0
; @ eg teu19
struct Base
    var Int x
struct Test(Base)
struct Other(Base)
func deleting(owner Test? t)
func fun(user Base b, user Other o)
    deleting(owner _)
    o.x := 0
    b.x := 0
; @ eg teu20
class Base
    var Int x
    func dynamic fun()
class Test(Base)
    func dynamic fun()
        owner String? s
func fun(user String s, user Base b)
    b.fun()
    s.clear()
; @ eg teu21
class Base
    var Int x
    func dynamic fun()
class Test{Generic}(Base)
    func dynamic fun()
func fun(user String s, user Base b)
    b.fun()
    s.clear()
; @ eg teu22
class Base
    var Int x
    func dynamic fun(owner Base? b)
        recursive()
class Test{Generic}(Base)
    func dynamic fun()
func recursive()
    Base.fun(user _, owner _)
func fun(user String s)
    recursive()
    s.clear()
; @ ec teu23
user String? s
t.fun()
s.clear()
; @ eg teu24
func deleting(copy Func?{()} f)
    f()
func fun(user String s)
    deleting(copy _)
    s.clear()
; @ eg teu25
func fun()->(user String s)
; @ eg teu26
func deleting()
    owner String? s
func fun()->(user String? s)
    s := _
    deleting()
; @ eg teu27
func fun(owner String so)->(user String? s)
    s := _
; @ eg teu28
func fun()->(user String? s)
    owner String? so
    s := _
; @ ec tec0
str := str
; @ eg tec1
struct Error
    user String s
; @