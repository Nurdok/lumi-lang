~~~ TL4 compiler integration main test file

This file should be stand-alone.

Testing multiline documentation
confused by ~ or ~~ or ; or ~~ ~ ?
~~~
module integration

[; Test
multiline
comment
;]

~~~ Test Single line documentation ~~~
; Test Single line comment

; Test global variables
var Int global-int(copy 23)
user String global-string(user "a constant string")

var Array{TestEnum.length + LENGTH:Int} int-arr
const Int LENGTH SIZE * 5
const Int SIZE 12


; Test Enum
enum TestEnum
    FIRST-VALUE
    ANOTHER-VALUE
    VALUE2


; Test functions
func test-simple-function()
    sys.println(user "I am a simple function")
    sys.print(user "I am a multi\
            line
            string
            ")


func test-const-expression()->(
        var Int i,
        var Char c,
        weak String s,
        weak TestStruct? t,
        weak TestClass? d,
        var Func?{()} f)
    i := 0 + 9630 + -9630 + 07520 + -07520 + 0xfda940 + -0xfda940 + 0xFDA940 +
            -0xFDA940
    c := 'a' + '\'' + '\n' + '\x0f' + '\xA9' + '\270'
    s := "some string"
    s := "some
            str\
            ing"
    t := _
    d := _
    f := _
    f()


func test-member-expression(strong TestStruct t)->(
        weak TestStruct to, var Int i)
    to := t
    t.num := to.num + t.ts.num + t.ts.ts.num
    to.num := t.num
    t.ts.ts.num := 4
    t.fun := test-void
    t.fun()
    t.new(copy 0, weak "")


func test-slice-expression(
        user String s,
        weak Array{Int} arri,
        weak Array{String} arrs,
        weak Array{TestStruct} arrt,
        weak Array{TestClass} arrd,
        weak Array{Func{()}} arrf)->(
        var Char c,
        var Int i,
        weak TestStruct t,
        weak TestClass d,
        var Func{()} f,
        weak Array{Int} arrio,
        weak Array{String} arrso,
        weak Array{TestStruct} arrto,
        weak Array{TestClass} arrdo,
        weak Array{Func{()}} arrfo)
    c := s[2] + s[4:7][2] + arrs[3][2] + arrs[4:2][4][1:3][0]
    i := arri[i + 3 - arri[2]] + arrt[4].num + arrt[2:4][1].num +
            arri[3:3][1:2][1]
    arrio := arri[2 - i + arri[2:4][1]:5 * (i - 1)]
    s := arrs[4]
    arrso := arrs[2:7]
    t := arrt[4]
    arrto := arrt[2:7]
    d := arrd[4]
    arrdo := arrd[2:7]
    f := arrf[4]
    arrfo := arrf[2:7]
    arrf[4]()
    arrfo[4]()


func test-container-expression(copy Int x, copy Int y, user String s)->(
        var Int i, var Bool b)
    i := - x + - - - y
    b := not ((not (x * 3) - 5 > 6 * y = 234 and not 5 - x < y) or not
            (x = -2 - (-4 * y) and -6 > y >= 12 = x)) and (- (2 + x) > y or s? or
            not s?)


func test-variable(copy Int i, weak String text, user Array{Int} arr)
    var Int x
    user String? s
    owner Array?{Int} a
    user TestStruct? t
    user TestClass? d
    var TestStruct tv(copy 0, weak _)
    var TestClass dv
    var String{12} sv
    var Func{(copy Int xi, user String si)->(var Int xo, user String so)} f
    var Array{12:Int} ia
    var Array{12:TestStruct} ta
    var Array{12:TestClass} da
    var Array{12:String{7}} sa
    var Array{12:Func{()}} fa
    new TestStruct tn(copy 0, weak _)
    new TestClass dn
    new String{arr[0]} sn
    new Array{arr[0]:Int} ian
    new Array{arr[0]:TestStruct} tan
    new Array{arr[0]:TestClass} dan
    new Array{arr[0]:String{arr[1]}} san
    new Array{arr[0]:Func{()}} sfn
    var Int ix(copy arr[0])
    user String si(user text)
    var String{12} isv(user "some string")
    new String{i} isn(user text)
    var Func{(copy Int n)->(owner String st)} fi(copy test-int2str)
    var TestStruct itv(copy i, weak text)
    new TestStruct itn(copy i, weak text)
    var TestClass idv()
    new TestClass idn()
    TestStruct(copy i, weak text).print()
    TestClass().print()
    assert String{arr[0]}()?
    assert Array{arr[0]:Int}()?
    assert Array{arr[0]:TestStruct}()?
    assert Array{arr[0]:TestClass}()?
    assert Array{arr[0]:String{arr[1]}}()?
    assert Array{arr[0]:Func{()}}()?
    assert x = 0
    assert s?
    assert a?
    t.print()
    d.print()
    assert f?
    tv.print()
    dv.print()
    assert sv?
    assert ia?
    assert ta?
    assert da?
    assert sa?
    assert fa?
    tn.print()
    dn.print()
    assert sn?
    assert ian?
    assert tan?
    assert dan?
    assert san?
    assert sfn?
    assert ix = 0
    assert si?
    fi(copy 7)
    assert isv?
    assert isn?


func test-complex-function(
        copy Int num, user String text)->(var Int out-num, user String out-text)
    [; Test
    multiline
    comment ;]

    ; Test Single line comment

    ~~~ Test Single line documentation ~~~
    ; Test Single line comment
    out-num := num
    out-text := text


; Test types
struct TestStruct
    ~~~ documentation test ~~~
    var Int num
    
    ~~~ Test
    multiline
    documentation ~~~
    weak String text
    
    ; comment test
    
    owner TestStruct? ts
    var Func{()} fun
    
    new(copy Int x, weak String? s) _
    
    [; Test
    multiline
    comment ;]
    
    func get()->(var Int x, user String s) _
    
    func print()
        sys.println(user self.text)
        
func TestStruct.new(copy Int x, weak String s)
    self.num := x
    self.text := s
    if x < 0
        self.ts := TestStruct(copy x + 1, weak s)
  
func TestStruct.get()->(var Int x, user String s)
    x := self.num
    s := self.text


class TestClass
    var Int num
    weak String text
    owner TestClass tc
    
    new()
        self.num := 1
    
    func inst static-meth() _
        
    func dynamic dynamic-meth() _
    
    func inst print()
        sys.println(user self.text)
    
func TestClass.static-meth()
    self.num := 3
    
func TestClass.dynamic-meth()
    self.num := 6


func test-void()
    return
func test-params(copy Int x, user String? s, owner String? o)
    raise
func test-outs()->(owner String s, var Int x)
func test-int2str(copy Int x)->(owner String s)
func test-int(copy Int x)
func test-int2int(copy Int x)->(var Int r)
func test-many(
        copy Int x,
        copy Int y)->(
        var Int n,
        var Int m)


func test-call-expression()
    owner String? s
    var Int x
    test-void()
    test-params(copy 3, user "text", owner _)
    test-outs()->(owner s, var x)
    test-int2str(copy 4)->(owner s)
    test-int(copy 5)
    test-int2int(copy 6)->(var x)
    test-many(
            copy 7,
            copy 8)->(
            var x,
            var x)
    var Int tmp
    test-int(copy test-int2int(copy 9)->(var tmp))
    x := test-int2int(copy 10) + test-many(copy 11, copy 12)->(var x)
    s := test-int2str(copy 13)


func test-code-flow(user Array{Int} arr)->(var Int res)
    if arr[4] > 6
        res := 6
    else-if arr?
        res := 6
    else-if arr[4] <> arr[5]
        res := 6
    else-if 0 = arr[0]
        res := 6
    else
        res := 0
    do
        arr[6] := 6
        var Int x(copy arr[2])
        while x > 3 and arr is _
        var Int y(copy x - 1)
        do
            arr[4] := arr[8]
            if y > arr[4]
                continue
            var Int z(copy 7)
            if z <= arr[4]
                while z > 0
    for n in arr[2]:2 - (3 * arr[2])
        arr[0] := arr[2]
        var Int w(copy arr[0])
        if w > 4 and arr is-not arr[3:2]
            arr[1] := w


func test-builtins(
        copy Int i, copy Char c, copy Bool b, weak String s, user Array{Int} a)
    var Int iv
    var Char cv
    var Bool bv
    new String{12} so
    i.str(reset so)
    bv := true or false
    a.length()->(var iv)
    s.length()->(var iv)
    so.clear()
    s.equal(user s)->(var bv)
    s.get(copy i)->(var cv)
    s.set(copy i, copy cv)
    so.append(copy c)
    so.copy(user s)
    so.concat(user s)
    so.concat-int(copy i)
    s.find(user s)->(var iv)
    s.has(copy c)->(var bv)
    owner File? f
    file-open-read(user s)->(owner f)
    file-open-write(user s)->(owner f)
    f.getc()->(var cv, var bv)
    f.putc(copy c)
    f.write(user s)
    file-close(owner f)
    user String arg(user sys.argv[1])
    sys.print(user s)
    sys.println(user s)
    sys.getchar()->(var cv, var bv)
    sys.getline(reset so)
    sys.getenv(user s, reset so)->(var bv)
    sys.system(user s)->(var iv)
    sys.exit(copy i)
    sys.stdout.putc(copy c)
    sys.stdin.getc()->(var cv, var bv)
    sys.stderr.putc(copy c)


func test-ref-count()
    new String{32} s(user "test string")
    user String s-user(user s)
    sys.println(user s)
    sys.println(user s-user)
    remove(owner s)
    if not s?
        sys.println(user "ownership passed")
    if not s-user?
        sys.println(user "string deleted")
    new TestStruct ts(copy 0, weak "first struct")
    sys.println(user ts.text)
    ts.ts := TestStruct(copy 1, weak "second struct")
    ts := ts.ts!
    sys.println(user ts.text)

func remove(owner String s)
    ; remove s

struct Item
    owner String s
    
    new(user String s)
        self.s := String{s.length() + 1}(user s)

struct Data{Generic}
    weak Generic item
    
    new()
    
    func set(weak Generic item) _
    
    func get()->(weak Generic item)
        item := self.item
        
func Data.set(weak Generic item)
    weak Generic x(weak item)
    self.item := x
    new Data{Generic} d
    d.item := self.item
    self.item := d.item

struct Dataset{First:Second:Third}(Data{First})
    weak Second second
    weak Third third
    
    new()
        base()

struct MidData{Generic}(Dataset{Item:Data{Generic}:Generic})

struct TopData(MidData{TestStruct})

func test-type-parameters(weak Item s)
    var Data{Item} d
    user Item? su
    d.item := s
    s := d.item
    var Array{5:Data{Item}} ad
    s := ad[2].item
    var Data{Data{Data{Item}}} dr
    s := dr.item.item.item
    d.set(weak s)
    d.get()->(weak s)
    user Data dg(user d)
    assert dg?
    
    var TopData t
    s-var Data{TestStruct} dt
    s-var TestStruct ts(copy 0, weak _)
    t.item := s
    t.second := dt
    t.third := ts


func try-catch-raise(user TestStruct t)
    try
        t.num := 1
    catch
        raise "ignored message"

func test-error-handling(user TestStruct? t)
    try
        sys.print(user "error handling { 1 ")
        t.num := 1
        sys.print(user " X ")
        try
            test-void()
        catch
            test-int(copy 2)
    catch
        sys.print(user "2 ")
        try
            sys.print(user "3 ")
            t.num := 2
            sys.print(user " X ")
        sys.print(user "4 ")
    sys.print(user "5 ")
    try
        sys.print(user "6 ")
        try
            sys.print(user "7 ")
            try-catch-raise(user t!)
            sys.print(user " X ")
        sys.print(user "8 ")
        raise "another ignored message"
    sys.println(user "}")


struct Container{Generic}
    weak Generic? value
    weak Container?{Generic} next
    
    new(weak Generic? value, weak Container?{Generic} next)
        self.value := value
        self.next := next
    
    func iter()->(owner ContainerIterator{Generic} iter)
        iter := ContainerIterator{Generic}(weak self.next)

struct ContainerIterator{Generic}
    weak Container?{Generic} curr
    
    new(weak Container?{Generic} first)
        self.curr := first
    
    func has()->(var Bool has-data)
        has-data := self.curr?
    
    func get()->(user Generic? item)
        item := self.curr.value
    
    func next()
        self.curr := self.curr.next

func test-for-each()
    var String{16} text
    sys.print(user "chars[ ")
    for c in "abcdef"
        text.clear()
        text.append(copy c)
        sys.print(user text)
        sys.print(user " ")
    sys.println(user "]")
    
    var Array{3:Int} arr
    arr[0] := 14
    arr[1] := 15
    arr[2] := 16
    sys.print(user "numbers[ ")
    for n in arr
        text.clear()
        n.str(reset text)
        sys.print(user text)
        sys.print(user " ")
    sys.println(user "]")
    
    var Array{3:TestStruct} tsarr
    tsarr[0].text := "aaa"
    tsarr[1].text := "bbb"
    tsarr[2].text := "ccc"
    sys.print(user "structs[ ")
    for ts in tsarr
        sys.print(user ts.text)
        sys.print(user " ")
    sys.println(user "]")
    
    var Array{3:String{16}} sarr
    
    sarr[0].copy(user "ddd")
    sarr[1].copy(user "eee")
    sarr[2].copy(user "fff")
    sys.print(user "strings[ ")
    for s in sarr
        sys.print(user s)
        sys.print(user " ")
    sys.println(user "]")
    
    s-var Container{Item} container-last(weak Item(user "iii"), weak _)
    s-var Container{Item} container-mid(weak Item(user "hhh"), weak container-last)
    s-var Container{Item} container-first(weak Item(user "ggg"), weak container-mid)
    s-var Container{Item} container(weak _, weak container-first)
    owner ContainerIterator{Item} iter(owner container.iter())
    sys.print(user "values[ ")
    for sc in iter
        sys.print(user sc.s)
        sys.print(user " ")
    sys.println(user "]")
    
    var Array{3:Array{3:Array{3:String{16}}}} saarr
    for n in 3
        for m in 3
            for i in 3
                saarr[n][m][i].copy(user "val")
                saarr[n][m][i].append(copy '0' + n)
                saarr[n][m][i].append(copy '0' + m)
                saarr[n][m][i].append(copy '0' + i)
    sys.print(user "items[ ")
    for a in saarr
        sys.print(user "\n  ")
        for b in a
            for s in b
                sys.print(user s)
                sys.print(user " ")
    sys.println(user "]")


class ComplexField
    weak ComplexField x
    new()
    func dynamic meth()
        sys.print(user "$")

struct HasComplexField
    s-var ComplexField x
    var Array{3:String{6}} as
    func run() _

func HasComplexField.run()
    user ComplexField x(user self.x)
    x := self.x
    x.meth()
    self.x.meth()
    ComplexField.meth(user self.x)
    user ComplexField x2(user self.x.x)
    x2 := self.x.x
    x2.meth()
    self.x.x.meth()
    ComplexField.meth(user self.x.x)
    self.as[0].copy(user "a1")
    self.as[1].copy(user "a2")
    self.as[2].copy(user "a3")
    for s in self.as
        sys.print(user " ")
        sys.print(user s)

func test-complex-field()
    s-var HasComplexField y
    y.x.x := y.x
    sys.print(user "complex fields: ")
    y.run()
    sys.println(user "")


func set-borrow(var TestStruct t)
    t.ts := TestStruct(copy 2, weak _)

func test-borrow()
    var TestStruct t(copy 1, weak _)
    set-borrow(var t)
    assert t.ts.num = 2


main
    test-simple-function()
    test-ref-count()
    test-error-handling(user _)
    test-for-each()
    test-complex-field()
    test-borrow()
