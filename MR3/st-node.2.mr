# MR3 compiler - complex nodes

class St-empty(St)
  func dynamic parse()
    # do nothing
  func dynamic analyze-first()
    # do nothing
  func dynamic analyze()
    # do nothing
  func dynamic write()
    # do nothing


class St-comment(St)
  owner String line
  owner String kw
  var Char end
  
  func dynamic parse()
    var Bool has-data(true)
    if ? glob.key-word
      f-new-copy(user glob.key-word.text):(owner self.kw)
      self.end := glob.key-word.end
      has-data := self.end != '\n' and self.end != EOF
    else
      self.kw := _
    if has-data
      read-new(user ""):(owner self.line)
  
  func dynamic analyze-first()
    # do nothing
  
  func dynamic analyze()
    # do nothing
  
  func dynamic write()
    if ? self.line
      write(user "// ")
      if ? self.kw
        write(user self.kw)
        write-c(copy self.end)
      write(user self.line)


func f-parse-new-node(copy Type{St} node-type, user St father)
  new As{node-type} node
  node.init(user father)
  node.parse()


class St-node(St)
  func inst parse-line(copy Int spaces):(copy Bool more-lines)
    read-key-word()
    more-lines := false
    if glob.key-word.end = EOF or glob.key-word.spaces < spaces
      return
    
    more-lines := true
    var Bool erase-kw(true)
    var Type{St} node-type
    if glob.key-word.text.length <= 0
      node-type := St-empty
    else-if (glob.key-word.end != ' ' and glob.key-word.end != '\n') or not get-node-type(user glob.key-word.text):(copy node-type)
      node-type := St-exp
    else
      glob.key-word := _
      erase-kw := false
    f-parse-new-node(copy node-type, user self)
    if erase-kw
      glob.key-word := _
  
  func inst parse-block()
    var Int spaces(glob.spaces)
    do
      while self.parse-line(copy spaces)
  
  # parse sons
  func dynamic parse()
    var Int my-spaces(glob.spaces)
    glob.spaces := my-spaces + 2
    self.parse-block()
    glob.spaces := my-spaces
  
  func dynamic analyze-first()
    base.analyze-first()
  
  func dynamic analyze()
    base.analyze()
  
  func inst write-block()
    user St son(self.first-son)
    do
      while ? son
      glob.line-num := son.line-num
      if not (? glob.mclass)
        write-spaces()
      son.write()
      if not (? glob.mclass)
        write(user "\n")
      son := son.next-brother
  
  # write sons
  func inst write-indent-block()
    var Int my-spaces(glob.spaces)
    glob.spaces := my-spaces + 2
    self.write-block()
    glob.spaces := my-spaces
    write-spaces()
    write(user "}")
  
  # write sons
  func dynamic write()
    write(user " {\n")
    self.write-indent-block()


class St-file(St-node)
  user String infile-name
  user Array{String} argv
  var Int index
  
  func inst init(user St root, user Array{String} argv, copy Int index)
    base.init(user root)
    self.infile-name := argv[index]
    self.argv := argv
    self.index := index
  
  func dynamic parse()
    sys.print(user self.infile-name)
    if self.infile-name.has(copy '"')
      f-msg-raise(user "Illegal \" character in argument", user self.infile-name)
    if self.infile-name.length < 6
      f-msg-raise(user "too short argument", user self.infile-name)
    file-open-read(user self.infile-name):(owner glob.infile)
    glob.infile-name := self.infile-name
    glob.key-word := _
    glob.line-num := 1
    glob.spaces := 0
    glob.mclass := _
    
    self.parse-block()
    
    glob.infile.close()
  
  func dynamic analyze-first()
    glob.infile-name := self.infile-name
    glob.node := self
    base.analyze-first()
  
  func dynamic analyze()
    sys.print(user self.infile-name)
    glob.infile-name := self.infile-name
    glob.node := self
    base.analyze()
  
  func inst write-cfile-name(copy Int index)
    user String infile-name(self.argv[index])
    user String prefix(infile-name[0:infile-name.length - 4])
    write(user " \"")
    write(user prefix)
    write(user "c\"\n")
    
  
  func dynamic write()
    new String{self.infile-name.length} outfile-name
    outfile-name.copy(user self.infile-name[0:self.infile-name.length - 4])
    outfile-name.append(copy 'c')
    sys.print(user outfile-name)
    file-open-write(user outfile-name):(owner glob.outfile)
    
    write(user "#ifndef MR_MAINFILE\n")
    write(user "#define MR_MAINFILE")
    self.write-cfile-name(copy self.index)
    write(user "#define DEPTH ")
    write-int(copy glob.max-type-depth + 1)
    write(user "\n#include \"mr.3.h\"\n")
    write(user "#else\n\n")
    
    write(user "#if MR_STAGE == MR_TYPEDEFS\n")
    write(user "static char* _mr_file")
    write-int(copy self.index)
    write(user "_name = \"")
    write(user self.infile-name)
    write(user "\";\n")
    write(user "#endif\n")
    write(user "#define MR_FILE_NAME _mr_file")
    write-int(copy self.index)
    write(user "_name\n\n")
    glob.infile-name := self.infile-name
    
    self.write-block()
    
    write(user "\n#undef MR_FILE_NAME\n\n")
    
    if self.argv.length > 2
      write(user "#ifndef MR_INCLUDES\n")
      write(user "#define MR_INCLUDES\n")
      for n in 1:self.argv.length
        if n != self.index
          write(user "#include")
          self.write-cfile-name(copy n)
      
    for depth in glob.max-type-depth
      if depth = 0
        write(user "#if ")
      else
        write(user "#elif ")
      write(user "MR_STAGE == MR_TYPES(")
      write-int(copy depth + 1)
      write(user ")\n")
      write(user "#undef MR_STAGE\n")
      write(user "#define MR_STAGE MR_TYPES(")
      write-int(copy depth + 2)
      write(user ")\n")
      if depth = glob.max-type-depth - 1
        write(user "#endif\n")
      
    if self.argv.length > 2
      write(user "#undef MR_INCLUDES\n")
      write(user "#endif\n\n")
    
    write(user "#endif\n")
    
    glob.outfile.close()
    delete outfile-name


class St-root(St)
  user Array{String} argv
  
  func inst init(user Array{String} argv)
    base.init(user _)
    self.argv := argv
  
  func dynamic parse()
    for index in 1:self.argv.length
      new St-file st-file
      st-file.init(user self, user self.argv, copy index)
      st-file.parse()
  
  func dynamic analyze-first()
    base.analyze-first()
  
  func dynamic analyze()
    self.analyze-first()
    base.analyze()
  
  func dynamic write()
    user St son(self.first-son)
    do
      while ? son
      son.write()
      son := son.next-brother


class St-native(St-comment)
  func dynamic parse()
    base.parse()
  func dynamic analyze-first()
    base.analyze-first()
  func dynamic analyze()
    base.analyze()
  func dynamic write()
    base.write()
