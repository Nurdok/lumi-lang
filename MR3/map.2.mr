# MR3 compiler - attribute mappings

# Name Map
static Name-map-node(Object)
  owner Name-map-node next
  user String name
  owner Object value
  
  func inst init(owner Name-map-node next, user String name, owner Object value)
    self.next := next
    self.name := name
    self.value := value

static Name-map(Object)
  owner Name-map-node first
  
  func inst init()
    self.first := _
  
  func inst add(user String name, owner Object value)
    new Name-map-node node
    node.init(owner self.first, user name, owner value)
    self.first := node
  
  func inst find(user String name):(user Object value)
    user Name-map-node node(self.first)
    do
      while ? node
      if node.name.equal(user name)
        value := node.value
        return
      node := node.next
    value := _
  
  func inst print()
    user Name-map-node node(self.first)
    do
      while ? node
      sys.print(user node.name)
      node := node.next


native class Mvar

static Var-map(Name-map)
  func inst m-copy-from(user Var-map other)
    self.first := other.first
  
  func inst add(user String name, owner Mvar mvar)
    owner Object value(mvar)
    base.add(user name, owner value)
  
  func inst find(user String name):(user Mvar mvar)
    mvar := base.find(user name)

func f-copy-new-var-map(user Var-map other):(owner Var-map new-var-map)
  new Var-map var-map
  if ? other
    var-map.m-copy-from(user other)
  else
    var-map.init()
  new-var-map := var-map


static Mtype(Object)
  owner String name
  owner Var-map members
  owner String base-typename
  user Mtype base-mtype
  var Bool is-dynamic
  
  func inst init(owner String name)
    self.name := name
    f-copy-new-var-map(user _):(owner self.members)
    self.base-typename := _
    self.base-mtype := _
    self.is-dynamic := false


var Int ACCESS-COPY(0)
var Int ACCESS-USER(1)
var Int ACCESS-OWNER(2)
var Int ACCESS-VAR(3)

native class Mfunc

native func m-find-type(user String typename):(user Mtype mtype)

static Mvar(Object)
  owner String name
  owner String typename
  user Mtype mtype
  user String sub-typename
  user Mtype sub-mtype
  user Mfunc func-dec
  var Int access
  var Bool is-ref
  
  func inst init(user Mtype mtype)
    self.name := _
    self.typename := _
    self.mtype := mtype
    self.sub-typename := _
    self.sub-mtype := _
    self.func-dec := _
    self.access := ACCESS-VAR
    self.is-ref := false
  
  func inst analyze()
    if not (? self.mtype)
      m-find-type(user self.typename):(user self.mtype)
    if ? self.sub-typename and not (? self.sub-mtype)
      m-find-type(user self.sub-typename):(user self.sub-mtype)

func init-new-var(user Mtype mtype):(owner Mvar new-mvar)
  new Mvar mvar
  mvar.init(user mtype)
  new-mvar := mvar

func add-var(user Var-map map, owner Mvar mvar)
  map.add(user mvar.name, owner mvar)


static Op-map(Name-map)
  func inst add(user String name, user String ctext)
    owner String new-name
    f-new-copy(user name):(owner new-name)
    owner String new-text
    f-new-copy(user ctext):(owner new-text)
    owner Object value(new-text)
    base.add(owner new-name, owner value)
  
  func inst add-copy(user String name)
    self.add(user name, user name)
  
  func inst find(user String name):(user String ctext)
    ctext := base.find(user name)

static Type-map(Name-map)
  func inst add(user String name):(user Mtype out-mtype)
    new Mtype mtype
    owner String new-name
    f-new-copy(user name):(owner new-name)
    mtype.init(owner new-name)
    owner Object value(mtype)
    base.add(user new-name, owner value)
    out-mtype := mtype
  
  func inst find(user String name):(user Mtype mtype)
    mtype := base.find(user name)


# Node Map
native class St

static Node-map-item(Object)
  owner String key
  var Type{St} node-type
