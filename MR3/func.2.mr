# MR3 compiler - function

func f-get-access(user String access-text):(copy Int access)
  if access-text.equal(user "copy")
    access := ACCESS-COPY
  else-if access-text.equal(user "user")
    access := ACCESS-USER
  else-if access-text.equal(user "owner")
    access := ACCESS-OWNER
  else-if access-text.equal(user "var")
    access := ACCESS-VAR
  else
    f-syntax-error(user "unknown access", user access-text)


native class Dec-arg

class Arg-node(Object)
  owner Arg-node next
  
  func dynamic parse(copy Bool is-out, copy Int access):(copy Char end)
    # nothing
  func dynamic analyze(user Arg-node arg, user Mtype prev-mtype, user Mtype prev-sub-mtype)
    # nothing
  func dynamic write-intro()
    # nothing
  func dynamic write-final(copy Bool is-out)
    # nothing
  func dynamic get-dec():(user Dec-arg arg)
    # nothing
  func dynamic get-call-value():(user Mexp exp)
    # nothing

class Dec-arg(Arg-node)
  user Mvar mvar
  
  func inst init(copy Int access, user Mtype mtype, user String name)
    init-new-var(user mtype):(owner self.mvar)
    self.mvar.access := access
    f-new-copy(user name):(owner self.mvar.name)
  
  func dynamic parse(copy Bool is-out, copy Int access):(copy Char end)
    init-new-var(user _):(owner self.mvar)
    self.mvar.is-ref := is-out
    self.mvar.access := access
    if read-new(user " {"):(owner self.mvar.typename, copy end) = '{'
      read-new(user "}"):(owner self.mvar.sub-typename, copy end)
      read-c():(copy end)
    read-new(user ",)"):(owner self.mvar.name, copy end)
  
  func dynamic analyze(user Arg-node arg, user Mtype prev-mtype, user Mtype prev-sub-mtype)
    self.mvar.analyze()
  
  func dynamic write-intro()
    # nothing
  
  func dynamic write-final(copy Bool is-out)
    write-cstyle(user self.mvar.mtype.name)
    if is-out
      write(user "*")
    if self.mvar.access = ACCESS-USER or self.mvar.access = ACCESS-OWNER
      write(user "*")
    else-if self.mvar.access = ACCESS-VAR and not self.mvar.mtype.is-primitive
      write(user "*")
    write(user " ")
    write-cstyle(user self.mvar.name)
  
  func dynamic get-dec():(user Dec-arg arg)
    arg := self
  
  func dynamic get-call-value():(user Mexp exp)
    raise

class Call-arg(Arg-node)
  var Int access
  user Mtype generic-mtype
  owner Mexp value
  
  func dynamic parse(copy Bool is-out, copy Int access):(copy Char end)
    self.access := access
    self.generic-mtype := _
    parse-new-exp(user ",)"):(owner self.value, copy end)
  
  func dynamic analyze(user Arg-node arg, user Mtype prev-mtype, user Mtype prev-sub-mtype)
    user Dec-arg dec-arg
    arg.get-dec():(user dec-arg)
    if self.access != dec-arg.mvar.access
      f-syntax-error(user "invalid access for param", user dec-arg.mvar.name)
    user Mtype mtype(dec-arg.mvar.mtype)
    user Mtype sub-mtype(dec-arg.mvar.sub-mtype)
    if mtype = prev-mtype.generic-mtype
      mtype := prev-sub-mtype
      sub-mtype := _
      self.generic-mtype := prev-mtype.generic-mtype
    else-if sub-mtype = prev-mtype.generic-mtype
      sub-mtype := prev-sub-mtype
    self.value.analyze():(user mtype, user sub-mtype)
    if not self.value.is-used
      self.generic-mtype := mtype
      self.value.is-used := true
  
  func dynamic write-intro()
    self.value.write-intro()
  
  func dynamic write-final(copy Bool is-out)
    if is-out
      if ? self.generic-mtype
        write(user "(")
        write-cstyle(user self.generic-mtype.name)
        write(user "**)")
      write(user "&(")
    self.value.write-final()
    if is-out
      write(user ")")
  
  func dynamic get-dec():(user Dec-arg arg)
    raise
  
  func dynamic get-call-value():(user Mexp exp)
    exp := self.value

static Arg-list(Object)
  owner Arg-node first-param
  owner Arg-node first-out
  var Bool is-dec
  
  func inst init(copy Bool is-dec)
    self.first-param := _
    self.first-out := _
    self.is-dec := is-dec
  
  func inst parse-args(copy Bool is-out)
    user Arg-node prev(_)
    var Char end
    do
      var String{128} access-text
      read(user " )", user access-text):(copy end)
      while end = ' '
      var Int access
      f-get-access(user access-text):(copy access)
      var Type{Arg-node} arg-type
      if self.is-dec
        arg-type := Dec-arg
      else
        arg-type := Call-arg
      new As{arg-type} arg
      arg.parse(copy is-out, copy access):(copy end)
      arg.next := _
      if ? prev
        prev.next := arg
      else-if is-out
        self.first-out := arg
      else
        self.first-param := arg
      prev := arg
      while end = ','
      read-c():(copy end)
  
  func inst parse(copy Bool is-dec):(copy Char end)
    self.is-dec := is-dec
    self.parse-args(copy false)
    if read-c():(copy end) = ':'
      if read-c() != '('
        f-syntax-error-c(user "expeted '(', got", copy end)
      self.parse-args(copy true)
      read-c():(copy end)
    else
      self.first-out := _
  
  func inst analyze-args(user Arg-node first)
    user Arg-node node(first)
    do
      while ? node
      node.analyze(user _, user _, user _)
      node := node.next
  
  func inst analyze()
    self.analyze-args(user self.first-param)
    self.analyze-args(user self.first-out)
  
  func inst write-args-intro(user Arg-node first)
    user Arg-node node(first)
    do
      while ? node
      node.write-intro()
      node := node.next
  
  func inst write-args-final(copy Bool is-out, user Arg-node first)
    user Arg-node node(first)
    var Bool has-more(not is-out and ? self.first-out)
    do
      while ? node
      node.write-final(copy is-out)
      node := node.next
      if has-more or ? node
        write(user ", ")
  
  func inst write-intro()
    self.write-args-intro(user self.first-param)
    self.write-args-intro(user self.first-out)
  
  func inst write-final()
    write(user "(")
    self.write-args-final(copy false, user self.first-param)
    self.write-args-final(copy true, user self.first-out)
    write(user ")")
  
  func inst add-arg(copy Int access, user Mtype mtype, user String name):(owner Arg-node first)
    new Dec-arg arg
    arg.init(copy access, user mtype, user name)
    arg.next := first
    first := arg
  
  func inst add-param(copy Int access, user Mtype mtype, user String name)
    self.add-arg(copy access, user mtype, user name):(owner self.first-param)
  
  func inst add-out(copy Int access, user Mtype mtype, user String name)
    self.add-arg(copy access, user mtype, user name):(owner self.first-out)
  
  func inst add-self-call(owner Mexp value)
    new Call-arg arg
    arg.access := ACCESS-VAR
    arg.value := value
    arg.next := self.first-param
    self.first-param := arg

func parse-new-args():(owner Arg-list new-args)
  new Arg-list args
  args.init(copy true)
  args.parse(copy true)
  new-args := args


static Mfunc(Object)
  owner String name
  owner Arg-list args
  user Mtype mclass
  var Bool is-dynamic
  var Int dynamic-index
  
  func inst init(user String name)
    f-new-copy(user name):(owner self.name)
    new Arg-list args
    self.args := args
    self.args.init(copy true)
    self.mclass := _
    self.is-dynamic := false
    self.dynamic-index := 0
  
  func inst parse()
    self.mclass := glob.mclass
    if ? self.mclass
      var String{64} meth-type
      read(user " ", user meth-type)
      self.is-dynamic := meth-type.equal(user "dynamic")
    else
      self.is-dynamic := false
    self.dynamic-index := 0
    read-new(user "("):(owner self.name)
    parse-new-args():(owner self.args)
    if ? self.mclass
      self.args.add-param(copy ACCESS-VAR, user self.mclass, user "self")
  
  func inst analyze()
    self.args.analyze()
  
  func inst write-name()
    if self.mclass
      write-cstyle(user self.mclass.name)
      write(user "_")
    write-cstyle(user self.name)
  
  func inst write()
    write(user "Returncode ")
    self.write-name()
    self.args.write-final()
  
  func inst m-new-var():(owner Mvar mvar)
    init-new-var(user glob.type-func):(owner mvar)
    f-new-copy(user self.name):(owner mvar.name)
    mvar.func-dec := self

func parse-new-mfunc():(owner Mfunc new-mfunc)
  new Mfunc mfunc
  mfunc.parse()
  new-mfunc := mfunc

func f-is-func-dynamic(user Mfunc mfunc):(copy Bool is-dynamic)
  is-dynamic := mfunc.is-dynamic


class Call-operand(Operand)
  owner Arg-list args
  owner Operand func-opr
  user Operand dynamic-opr
  var Int dynamic-index
  var Int dynamic-base-count
  var Bool is-used
  user Mtype res-mtype
  user Mexp res-exp
  owner String res-name
  
  func dynamic parse(owner String text, user String ends):(copy Char end)
    new Arg-list args
    self.args := args
    self.args.init(copy false)
    args.parse(copy false):(copy end)
    self.func-opr := _
    self.dynamic-opr := _
    self.dynamic-index := 0
    self.dynamic-base-count := 0
    self.res-mtype := _
    self.res-name := _
    self.res-exp := _
  
  func inst analyze-args(user Mfunc mfunc, copy Bool is-method):(user Mtype mtype, user Mtype sub-mtype)
    user Arg-node dec-param(mfunc.args.first-param)
    user Arg-node call-param(self.args.first-param)
    var Bool not-self(not is-method)
    do
      while ? dec-param
      if not (? call-param)
        f-syntax-error(user "too few parameters for", user mfunc.name)
      if not-self
        call-param.analyze(user dec-param, user mtype, user sub-mtype)
      else
        not-self := true
      dec-param := dec-param.next
      call-param := call-param.next
    if ? call-param
      f-syntax-error(user "too many parameters for", user mfunc.name)
    
    user Arg-node dec-out(mfunc.args.first-out)
    user Arg-node call-out(self.args.first-out)
    if not (? dec-out)
      if self.is-used
        f-syntax-error(user "no return value for", user mfunc.name)
      if call-out
        f-syntax-error(user "too many outputs for", user mfunc.name)
      mtype := _
      sub-mtype := _
      return
    
    if ? call-out
      call-out.analyze(user dec-out, user mtype, user sub-mtype)
      do
        while ? call-out.next
        call-out := call-out.next
        dec-out := dec-out.next
        if not (? dec-out)
          f-syntax-error(user "too many outputs for", user mfunc.name)
        call-out.analyze(user dec-out, user mtype, user sub-mtype)
    
    var Bool fill-out(? dec-out.next or not (? call-out))
    if ? dec-out.next
      dec-out := dec-out.next
      if ? dec-out.next or not (? call-out)
        f-syntax-error(user "too few outputs for", user mfunc.name)
    user Dec-arg dec-res
    dec-out.get-dec():(user dec-res)
    user Mtype generic-mtype(_)
    if dec-res.mvar.mtype = mtype.generic-mtype
      generic-mtype := mtype.generic-mtype
      mtype := sub-mtype
      sub-mtype := _
    else-if dec-res.mvar.sub-mtype = mtype.generic-mtype
      mtype := dec-res.mvar.mtype
      # sub-mtype is the same
    else
      mtype := dec-res.mvar.mtype
      sub-mtype := dec-res.mvar.sub-mtype
    self.res-mtype := mtype
    if fill-out
      var String{64} res-count
      glob.res-count.str():(var res-count)
      glob.res-count := glob.res-count + 1
      new String{self.res-mtype.name.length + res-count.length + 2} res-name
      self.res-name := res-name
      self.res-name.append(copy '-')
      self.res-name.concat(user self.res-mtype.name)
      self.res-name.concat(user res-count)
      new Var-operand var-opr
      f-new-copy(user self.res-name):(owner var-opr.name)
      init-new-var(user mtype):(owner var-opr.mvar)
      f-new-copy(user self.res-name):(owner var-opr.mvar.name)
      if ? sub-mtype
        f-new-copy(user sub-mtype.name):(owner var-opr.mvar.sub-typename)
      var-opr.mvar.sub-mtype := sub-mtype
      var-opr.mvar.func-dec := dec-res.mvar.func-dec
      var-opr.mvar.access := dec-res.mvar.access
      var-opr.next := _
      new Mexp exp
      exp.init()
      exp.operand := var-opr
      new Call-arg arg
      arg.access := dec-res.mvar.access
      arg.generic-mtype := generic-mtype
      arg.value := exp
      arg.next := _
      if ? call-out
        call-out.next := arg
      else
        self.args.first-out := arg
    else
      call-out.get-call-value():(user self.res-exp)
  
  func inst analyze-func-pointer():(user Mtype mtype, user Mtype sub-mtype)
    user Arg-node arg(self.args.first-param)
    var Bool first(true)
    do
      while ? arg
      user Mexp exp
      arg.get-call-value():(user exp)
      user Mtype param-mtype(_)
      user Mtype param-sub-mtype(_)
      exp.analyze():(user param-mtype, user param-sub-mtype)
    arg := self.args.first-out
    mtype := _
    sub-mtype := _
    do
      while ? arg
      user Mexp exp
      arg.get-call-value():(user exp)
      mtype := _
      sub-mtype := _
      exp.analyze():(user mtype, user sub-mtype)
  
  func dynamic analyze(user Mexp exp, user Operand member, user Var-operand method):(user Mtype mtype, user Mtype sub-mtype)
    self.is-used := exp.is-used or ? self.next or ? exp.next or ? exp.operator
    if not self.is-used
      exp.is-used := true
    
    member.next := _
    user Operand method-opr
    method-opr := method
    var Bool is-method(? method and method-opr != member)
    if is-method
      method.next := _
      self.func-opr := method
      if method.mvar.func-dec.is-dynamic and method.allow-dynamic
        self.dynamic-opr := exp.operand
        self.dynamic-index := method.mvar.func-dec.dynamic-index
        self.dynamic-base-count := method.base-count
        method.base-count := 0
      new Mexp new-exp
      new-exp.init()
      new-exp.operand := exp.operand
      new-exp.base-count := method.base-count
      self.args.add-self-call(owner new-exp)
    else
      self.func-opr := exp.operand
    exp.operand := self
    
    if ? method and ? method.mvar.func-dec
      self.analyze-args(user method.mvar.func-dec, copy is-method):(user mtype, user sub-mtype)
    else
      self.analyze-func-pointer():(user mtype, user sub-mtype)
    
    if ? self.next
      self.next.analyze(user exp, user self, user _):(user mtype, user sub-mtype)
  
  func inst write-call()
    write-tb-check()
    if ? self.dynamic-opr
      # (opr)->[_base.]_dtl[index]
      write(user "(")
      self.dynamic-opr.write-all-final()
      write(user ")->")
      for n in self.dynamic-base-count
        write(user "_base.")
      write(user "_dtl[")
      write-int(copy self.dynamic-index)
      write(user "]")
    else
      self.func-opr.write-all-final()
    self.args.write-final()
    write(user " )")
  
  func dynamic write-intro()
    self.func-opr.write-all-intro()
    self.args.write-intro()
    if ? self.res-exp
      self.res-exp.write-intro()
    else-if ? self.res-name
      write-cstyle(user self.res-mtype.name)
      if not self.res-mtype.is-primitive
        write(user "*")
      write(user " ")
      write-cstyle(user self.res-name)
      write(user ";\n")
      write-spaces()
    if self.is-used
      self.write-call()
      write-new-indent-line()
  
  func dynamic write-final()
    if self.is-used
      if ? self.res-exp
        self.res-exp.write-final()
      else-if self.res-name
        write-cstyle(user self.res-name)
    else
      self.write-call()


func parse-new-operand(copy Type{Operand} opr-type, owner String text, user String ends):(owner Operand new-opr, copy Char end)
  new As{opr-type} opr
  new-opr := opr
  opr.parse(owner text, user ends):(copy end)
  var Type{Operand} next-type
  if end = '.'
    next-type := Member-operand
  else-if end = '['
    next-type := Slice-operand
  else-if end = '('
    next-type := Call-operand
  else
    opr.next := _
    return
  parse-new-operand(copy next-type, owner _, user ends):(owner opr.next, copy end)

func parse-new-operands(owner String text, user String ends):(owner Operand new-opr, copy Char end)
  var Type{Operand} opr-type
  if text.length = 0
    if end = '('
      opr-type := Block-operand
    else
      f-syntax-error-c(user "unexpected", copy end)
  else
    var Char first(text[0])
    if first = '\''
      opr-type := Char-operand
    else-if first = '"'
      opr-type := String-operand
    else-if first >= '0' and first <= '9'
      opr-type := Int-operand
    else-if first >= 'A' and first <= 'Z'
      opr-type := Type-operand
    else-if text.length = 1 and first = '_'
      opr-type := Empty-operand
    else-if text.equal(user "base")
      opr-type := Base-meth-operand
    else
      opr-type := Var-operand
  parse-new-operand(copy opr-type, owner text, user ends):(owner new-opr, copy end)


class St-func(St-node)
  owner Mfunc mfunc
  
  func inst add-args-vars(user Arg-node fisrt-arg)
    user Arg-node arg(fisrt-arg)
    do
      while ? arg
      user Dec-arg dec-arg
      arg.get-dec():(user dec-arg)
      while ? dec-arg
      add-var(user self.sons-var-map, user dec-arg.mvar)
      arg := arg.next
  
  func dynamic parse()
    parse-new-mfunc():(owner self.mfunc)
    self.add-var(owner self.mfunc.m-new-var())
    f-copy-new-var-map(user _):(owner self.sons-var-map)
    self.add-args-vars(user self.mfunc.args.first-param)
    self.add-args-vars(user self.mfunc.args.first-out)
    base.parse()
  
  func dynamic analyze-first()
    self.mfunc.analyze()
    base.analyze-first()
  
  func dynamic analyze()
    new St-return st-return
    st-return.init(user self)
    base.analyze()
  
  func dynamic write()
    if ? glob.mclass
      if not glob.methods
        return
      write-new-indent-line()
    write(user "#if MR_STAGE == MR_DECLARATIONS\n")
    write-spaces()
    self.mfunc.write()
    write(user ";\n")
    write-spaces()
    write(user "#elif MR_STAGE == MR_FUNCTIONS\n")
    write-spaces()
    write(user "static char* _func_name_")
    self.mfunc.write-name()
    write(user " = \"")
    if ? glob.mclass
      write(user glob.mclass.name)
      write(user ".")
    write(user self.mfunc.name)
    write(user "\";\n")
    write-spaces()
    write(user "#define MR_FUNC_NAME _func_name_")
    self.mfunc.write-name()
    write-new-indent-line()
    self.mfunc.write()
    user Mtype mclass(glob.mclass)
    glob.mclass := _
    base.write()
    glob.mclass := mclass
    write-new-indent-line()
    write(user "#undef MR_FUNC_NAME\n")
    write-spaces()
    write(user "#endif")


class St-main(St-func)
  func dynamic parse()
    base.parse()
  
  func dynamic analyze-first()
    base.analyze-first()
  
  func dynamic analyze()
    base.analyze()
  
  func dynamic write()
    base.write()
    write(user "\n\n#if MR_STAGE == MR_FUNCTIONS\n")
    write(user "MAIN_FUNC\n")
    write(user "#endif")


class St-format(St-node)
  owner String item-name
  user Mvar item-mvar
  owner String func-name
  owner String format
  
  func dynamic parse()
    self.item-name := _
    self.item-mvar := _
    if read-new(user ".("):(owner self.func-name) = '.'
      self.item-name := self.func-name
      read-new(user "("):(owner self.func-name)
    var String{256} format
    read(user ")", user format)
    if format.length < 2 or format[0] != '"' or format[format.length - 1] != '"'
      f-syntax-error(user "illegal format string", user format)
    f-new-copy(user format[1:format.length - 2]):(owner self.format)
    read-c()
    base.parse()
  
  func dynamic analyze-first()
    base.analyze-first()
  
  func dynamic analyze()
    user Mvar mvar
    if ? self.item-name
      if not (? f-find-var(user self.item-name):(user self.item-mvar))
        f-syntax-error(user "unknow variable", user self.item-name)
      if not (? self.item-mvar.mtype.members.find(user self.func-name):(user mvar))
        f-syntax-error2(user "type", user self.item-mvar.typename, user "has no method", user self.func-name)
    else
      if not (? f-find-var(user self.func-name):(user mvar))
        f-syntax-error(user "unknow function", user self.func-name)
    if not (? mvar.func-dec)
      f-syntax-error(user "non function variable", user self.func-name)
    if not (? mvar.func-dec.args.first-param)
      f-syntax-error(user "no parameter for function", user self.func-name)
    if ? mvar.func-dec.args.first-out
      f-syntax-error(user "outputs exists in function", user self.func-name)
    user Dec-arg param-dec
    if ? self.item-name
      if not (? mvar.func-dec.args.first-param.next)
        f-syntax-error(user "no parameter for method", user self.func-name)
      mvar.func-dec.args.first-param.next.get-dec():(user param-dec)
    else
      mvar.func-dec.args.first-param.get-dec():(user param-dec)
    if ? param-dec.next
      f-syntax-error(user "too many parameter for function", user self.func-name)
    if param-dec.mvar.mtype != glob.type-string
      f-syntax-error2(user "expected a string parameter in function", user self.func-name, user " instead of", user param-dec.mvar.typename)
    if param-dec.mvar.access != ACCESS-USER
      f-syntax-error(user "expected parameter with user access in function", user self.func-name)
    base.analyze()
  
  func dynamic write()
    var Int index(0)
    var Int len(self.format.length)
    user St node(self.first-son)
    do
      while len > 0
      if index > 0
        write-new-indent-line()
      
      user String format(self.format[index:len])
      var Int next(format.find(user "{}"))
      if next > 0
        write-tb-check()
        if ? self.item-mvar
          write-cstyle(user self.item-mvar.mtype.name)
          write(user "_")
        write-cstyle(user self.func-name)
        write(user "(")
        if ? self.item-mvar
          if self.item-mvar.is-ref
            write(user "*")
          write-cstyle(user self.item-mvar.name)
          write(user ", ")
        write(user "&(String){")
        write-int(copy next + 1)
        write(user ", ")
        write-int(copy next)
        write(user ", \"")
        write(user format[0:next])
        write(user "\"}) )")
      else
        if not (? node)
          f-syntax-error(user "too few lines to format", user self.func-name)
        glob.line-num := node.line-num
        node.write()
        glob.line-num := self.line-num
        node := node.next-brother
        next := 2
      index := index + next
      len := len - next
