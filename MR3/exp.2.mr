# MR3 compiler - expression

native class Mexp
native class Var-operand

class Operand(Object)
  owner Operand next
  
  func dynamic parse(owner String text, user String ends):(copy Char end)
    # nothing
  func dynamic analyze(user Mexp exp, user Operand member, user Var-operand method):(user Mtype mtype, user Mtype sub-mtype)
    # nothing
  func dynamic write-intro()
    # nothing
  func dynamic write-final()
    # nothing
  
  func inst write-all-intro()
    self.write-intro()
    if ? self.next
      self.next.write-all-intro()
  
  func inst write-all-final()
    self.write-final()
    if ? self.next
      self.next.write-all-final()


func read-new-value(user String ends):(owner String out-text, copy Char end)
  new String{ends.length + 5} all-ends
  all-ends.copy(user " .[(")
  all-ends.concat(user ends)
  read-new(user all-ends):(owner out-text, copy end)
  delete all-ends

native func parse-new-operands(owner String text, user String ends):(owner Operand new-opr, copy Char end)

static Mexp(Object)
  owner Operand operand
  owner String operator
  owner Mexp next
  var Int base-count
  var Bool is-used
  
  func inst init()
    self.operand := _
    self.operator := _
    self.next := _
    self.is-used := true
    self.base-count := 0
  
  native func parse(owner String text, user String ends):(copy Char end)
  
  func inst parse-new-with-text(owner String text, user String ends):(owner Mexp new-exp, copy Char end)
    new Mexp exp
    exp.init()
    exp.parse(owner text, user ends):(copy end)
    new-exp := exp
  
  func inst parse-new(user String ends):(owner Mexp new-exp, copy Char end)
    owner String text
    read-new-value(user ends):(owner text, copy end)
    self.parse-new-with-text(user text, user ends):(owner new-exp, copy end)
  
  func inst parse-new-with-kw(user String ends):(owner Mexp new-exp, copy Char end)
    if ? glob.key-word
      owner String text
      f-new-copy(user glob.key-word.text):(owner text)
      end := glob.key-word.end
      self.parse-new-with-text(user text, user ends):(owner new-exp, copy end)
    else
      self.parse-new(user ends):(owner new-exp, copy end)
  
  func inst parse(owner String text, user String ends):(copy Char end)
    if end = ' ' and ? glob.op-map.find(user text)
      self.operator := text
      read-new-value(user ends):(owner text, copy end)
      
      if end = ' ' and ? glob.op-map.find(user text)
        self.operand := _
        self.parse-new-with-text(user text, user ends):(owner self.next, copy end)
        return
    
    parse-new-operands(owner text, user ends):(owner self.operand, copy end)
    if end = ' ' and not ends.has(copy ' ')
      self.parse-new(user ends):(owner self.next, copy end)
  
  func inst f-count-bases(user Mtype target-mtype):(user Mtype mtype, copy Int base-count)
    if not (? target-mtype)
      return
    if not (? mtype)
      f-syntax-error(user "got no value, expected", user target-mtype.name)
    base-count := 0
    if target-mtype = glob.type-bool and mtype.is-primitive
      mtype := glob.type-bool
      return
    if target-mtype = glob.type-char and mtype = glob.type-int
      mtype := glob.type-char
      return
    if target-mtype = glob.type-int and mtype = glob.type-char
      mtype := glob.type-int
      return
    user Mtype orig-mtype(mtype)
    do
      while mtype != target-mtype
      mtype := mtype.base-mtype
      if not (? mtype)
        f-syntax-error2(user "got", user orig-mtype.name, user "expected", user target-mtype.name)
      base-count := base-count + 1
  
  func inst analyze():(user Mtype mtype, user Mtype sub-mtype)
    # self.is-used := ? mtype or ? self.operator or ? self.next
    if ? self.operand
      user Mtype target-mtype(mtype)
      user Mtype target-sub-mtype(sub-mtype)
      self.operand.analyze(user self, user _, user _):(user mtype, user sub-mtype)
      if ? self.operator and ? mtype
        if self.operator.equal(user "?")
          if mtype.is-primitive
            f-syntax-error(user "? on primitive type", user mtype.name)
          mtype := glob.type-bool
          sub-mtype := _
      self.f-count-bases(user target-mtype):(user mtype, copy self.base-count)
      self.f-count-bases(user target-sub-mtype):(user sub-mtype)
    
    if ? self.next
      self.next.analyze():(user mtype, user sub-mtype)
  
  func inst analyze-get-subtype(user Mtype target-mtype):(user Mtype sub-mtype)
    user Mtype mtype(target-mtype)
    self.analyze():(user mtype, user sub-mtype)
    if not (? mtype)
      f-syntax-error(user "got no value, expected", user target-mtype.name)
    if mtype != target-mtype
      f-syntax-error2(user "got", user mtype.name, user "expected", user target-mtype.name)
  
  func inst analyze-types(user Mtype target-mtype, user Mtype target-sub-mtype)
    user Mtype sub-mtype(target-sub-mtype)
    self.analyze-get-subtype(user target-mtype):(user sub-mtype)
    if ? target-sub-mtype
      if not (? sub-mtype)
        f-syntax-error(user "got no sub-type, expected", user target-sub-mtype.name)
      if sub-mtype != target-sub-mtype
        f-syntax-error2(user "got sub-type", user sub-mtype.name, user "expected", user target-sub-mtype.name)
  
  func inst analyze-type(user Mtype target-mtype)
    self.analyze-types(user target-mtype, user _)
  
  func inst write-all-final(copy Bool is-binary)
    if ? self.operator
      user String op
      if not (? glob.op-map.find(user self.operator):(user op))
        f-syntax-error(user "unknow operator", user self.operator)
      if is-binary
        write(user " ")
      write(user op)
      if is-binary
        write(user " ")
    if ? self.operand
      if self.base-count > 0
        write(user "&(")
      self.operand.write-all-final()
      if self.base-count > 0
        write(user "->_base")
        for n in 1:self.base-count
          write(user "._base")
        write(user ")")
    if ? self.next
      self.next.write-all-final(copy true)
  
  func inst write-intro()
    if ? self.operand
      self.operand.write-all-intro()
    if ? self.next
      self.next.write-intro()
  
  func inst write-final()
    self.write-all-final(copy false)

func parse-new-exp(user String ends):(owner Mexp exp, copy Char end)
  Mexp.parse-new(user _, user ends):(owner exp, copy end)

func parse-new-exp-with-kw(user String ends):(owner Mexp exp, copy Char end)
  Mexp.parse-new-with-kw(user _, user ends):(owner exp, copy end)


native func m-find-var(user String name):(user Mvar mvar)

class Var-operand(Operand)
  owner String name
  user Mvar mvar
  var Int base-count
  var Bool allow-dynamic
  
  func dynamic parse(owner String text, user String ends):(copy Char end)
    self.name := text
    self.mvar := _
    self.base-count := 0
    self.allow-dynamic := true
  
  func dynamic analyze(user Mexp exp, user Operand member, user Var-operand method):(user Mtype mtype, user Mtype sub-mtype)
    if not (? m-find-var(user self.name):(user self.mvar))
      f-syntax-error(user "unknow variable", user self.name)
    mtype := self.mvar.mtype
    sub-mtype := self.mvar.sub-mtype
    if ? self.next
      self.next.analyze(user exp, user self, user self):(user mtype, user sub-mtype)
  
  func dynamic write-intro()
    # nothing
  
  func dynamic write-final()
    if self.mvar.is-ref
      write(user "(*")
    write-cstyle(user self.name)
    if self.mvar.is-ref
      write(user ")")


class Char-operand(Operand)
  owner String text
  
  func dynamic parse(owner String text, user String ends):(copy Char end)
    var Char ch
    if text.length = 3
      ch := text[1]
      if ch = '\'' or ch = '\\'
        f-syntax-error(user "illegal character constant", user text)
    else-if text.length = 4
      if text[1] != '\\'
        f-syntax-error(user "illegal character constant", user text)
      ch := text[2]
    else
      f-syntax-error(user "illegal character constant", user text)
    if text[text.length - 1] != '\''
      f-syntax-error(user "illegal character constant", user text)
    self.text := text
  
  func dynamic analyze(user Mexp exp, user Operand member, user Var-operand method):(user Mtype mtype, user Mtype sub-mtype)
    mtype := glob.type-char
    sub-mtype := _
    if ? self.next
      self.next.analyze(user exp, user self, user _):(user mtype, user sub-mtype)
  
  func dynamic write-intro()
    # nothing
  
  func dynamic write-final()
    write(user self.text)


class String-operand(Operand)
  owner String text
  
  func dynamic parse(owner String text, user String ends):(copy Char end)
    if text[text.length - 1] != '\"'
      f-syntax-error(user "illegal string constant", user text)
    self.text := text
  
  func dynamic analyze(user Mexp exp, user Operand member, user Var-operand method):(user Mtype mtype, user Mtype sub-mtype)
    mtype := glob.type-string
    sub-mtype := _
    if ? self.next
      self.next.analyze(user exp, user self, user _):(user mtype, user sub-mtype)
  
  func dynamic write-intro()
    # nothing
  
  func dynamic write-final()
    var Int real-length(1)
    for index in 1:self.text.length - 1
      if self.text[index] = '\\'
        index := index + 1
      real-length := real-length + 1
    var String{80} length-str
    write(user "&(String){")
    write-int(copy real-length)
    write(user ", ")
    write-int(copy real-length - 1)
    write(user ", ")
    write(user self.text)
    write(user "}")


class Int-operand(Operand)
  owner String text
  var Int value
  
  func dynamic parse(owner String text, user String ends):(copy Char end)
    self.value := 0
    for n in text.length
      var Char ch(text[n])
      if ch < '0' or ch > '9'
        f-syntax-error(user "illegal number", user text)
      self.value := self.value * 10 + ch - '0'
    self.text := text
  
  func dynamic analyze(user Mexp exp, user Operand member, user Var-operand method):(user Mtype mtype, user Mtype sub-mtype)
    mtype := glob.type-int
    sub-mtype := _
    if ? self.next
      self.next.analyze(user exp, user self, user _):(user mtype, user sub-mtype)
  
  func dynamic write-intro()
    # nothing
  
  func dynamic write-final()
    write(user self.text)


class Empty-operand(Operand)
  func dynamic parse(owner String text, user String ends):(copy Char end)
    delete text
  
  func dynamic analyze(user Mexp exp, user Operand member, user Var-operand method):(user Mtype mtype, user Mtype sub-mtype)
    if not (? mtype) or ? self.next or mtype.is-primitive
      f-syntax-error-c(user "illegal use of value", user '_')
  
  func dynamic write-intro()
    # nothing
  
  func dynamic write-final()
    write(user "NULL")


class Block-operand(Operand)
  owner Mexp exp
  
  func dynamic parse(owner String text, user String ends):(copy Char end)
    delete text
    parse-new-exp(user ")"):(owner self.exp, copy end)
    if end != ')'
      f-syntax-error(user "missing", user ")")
    read-c():(copy end)
  
  func dynamic analyze(user Mexp exp, user Operand member, user Var-operand method):(user Mtype mtype, user Mtype sub-mtype)
    self.exp.analyze():(user mtype, user sub-mtype)
    if ? self.next
      self.next.analyze(user exp, user self, user _):(user mtype, user sub-mtype)
  
  func dynamic write-intro()
    self.exp.write-intro()
  
  func dynamic write-final()
    write(user "(")
    self.exp.write-final()
    write(user ")")


native func f-is-func-dynamic(user Mfunc mfunc):(copy Bool is-dynamic)

class Member-operand(Var-operand)
  user Mtype prev-mtype
  
  func dynamic parse(owner String text, user String ends):(copy Char end)
    self.base-count := 0
    self.allow-dynamic := true
    read-new-value(user ends):(owner self.name, copy end)
  
  func dynamic analyze(user Mexp exp, user Operand member, user Var-operand method):(user Mtype mtype, user Mtype sub-mtype)
    if not (? mtype)
      f-syntax-error(user "member with no type", user self.name)
    self.prev-mtype := mtype
    do
      while not (? mtype.members.find(user self.name):(user self.mvar))
      mtype := mtype.base-mtype
      if not (? mtype)
        f-syntax-error2(user "type", user self.prev-mtype.name, user "has no member", user self.name)
      self.base-count := self.base-count + 1
    self.prev-mtype := mtype
    user Mtype basetype(mtype.base-mtype)
    mtype := self.mvar.mtype
    sub-mtype := self.mvar.sub-mtype
    if ? self.next
      if ? self.mvar.func-dec and ? member
        if f-is-func-dynamic(user self.mvar.func-dec) and self.allow-dynamic
          do
            while ? basetype
            self.base-count := self.base-count + 1
            basetype := basetype.base-mtype
        self.next.analyze(user exp, user member, user self):(user mtype, user sub-mtype)
      else
        self.next.analyze(user exp, user self, user self):(user mtype, user sub-mtype)
  
  func dynamic write-intro()
    # nothing
  
  func dynamic write-final()
    if ? self.mvar.func-dec
      write-cstyle(user self.prev-mtype.name)
      write(user "_")
    else
      write(user "->")
      for n in self.base-count
        write(user "_base.")
    base.write-final()


class Base-meth-operand(Operand)
  owner Member-operand member
  var Bool first
  
  func dynamic parse(owner String text, user String ends):(copy Char end)
    delete text
    new Member-operand member
    self.member := member
    self.member.parse(owner _, user ends):(copy end)
    self.member.next := _
    self.member.allow-dynamic := false
    if end != '('
      f-syntax-error(user "not a method", user self.member.mvar.name)
  
  func dynamic analyze(user Mexp exp, user Operand member, user Var-operand method):(user Mtype mtype, user Mtype sub-mtype)
    sub-mtype := _
    self.first := not (? member)
    if self.first
      user Mvar mvar
      if not (? m-find-var(user "self"):(user mvar))
        f-syntax-error(user "not a method, cannot use", user "base")
      mtype := mvar.mtype
    if not (? mtype.base-mtype)
      f-syntax-error(user "no subtype for type", user mtype.name)
    mtype := mtype.base-mtype
    self.member.analyze(user exp, user self, user _):(user mtype, user sub-mtype)
    self.member.base-count := self.member.base-count + 1
    self.next.analyze(user exp, user self, user self.member):(user mtype, user sub-mtype)
    self.member := _
  
  func dynamic write-intro()
    # nothing
  
  func dynamic write-final()
    if self.first
      write(user "self")


class Type-operand(Operand)
  owner String name
  user Mtype mtype
  
  func dynamic parse(owner String text, user String ends):(copy Char end)
    self.name := text
    self.mtype := _
  
  func dynamic analyze(user Mexp exp, user Operand member, user Var-operand method):(user Mtype mtype, user Mtype sub-mtype)
    f-find-type(user self.name):(user mtype)
    if ? self.next
      sub-mtype := _
      exp.operand := self.next
      self.next.analyze(user exp, user member, user method):(user mtype, user sub-mtype)
      delete self
    else
      self.mtype := mtype
      mtype := glob.type-type
      sub-mtype := self.mtype
  
  func dynamic write-intro()
    # nothing
  
  func dynamic write-final()
    # (Type){sizeof(name), name__dtl}
    write(user "(Type){sizeof(")
    write-cstyle(user self.name)
    write(user "), ")
    if ? self.mtype.dynamic-members
      write-cstyle(user self.name)
      write(user "__dtl")
    else
      write(user "NULL")
    write(user "}")


class Slice-operand(Operand)
  owner Mexp index
  owner Mexp second-index
  user Operand seq
  user Mtype seq-type
  user Mtype item-type
  
  func dynamic parse(owner String text, user String ends):(copy Char end)
    parse-new-exp(user ":]"):(owner self.index, copy end)
    if end = ':'
      parse-new-exp(user ":]"):(owner self.second-index, copy end)
    else
      self.second-index := _
    if end != ']'
      f-syntax-error(user "missing", user "]")
    read-c():(copy end)
  
  func dynamic analyze(user Mexp exp, user Operand member, user Var-operand method):(user Mtype mtype, user Mtype sub-mtype)
    self.seq-type := mtype
    self.item-type := sub-mtype
    if self.seq-type != glob.type-array and self.seq-type != glob.type-string
      f-syntax-error(user "non-sliceable type", user self.seq-type.name)
    if not (? self.second-index)
      sub-mtype := _
      if self.seq-type = glob.type-string
        mtype := glob.type-char
      else-if ? self.item-type
        mtype := self.item-type
      else
        f-syntax-error(user "missing sub-type for array", user "")
    
    self.seq := exp.operand
    exp.operand := self
    member.next := _
    
    self.index.analyze-type(user glob.type-int)
    if ? self.second-index
      self.second-index.analyze-type(user glob.type-int)
    
    if ? self.next
      self.next.analyze(user exp, user self, user _):(user mtype, user sub-mtype)
  
  func dynamic write-intro()
    self.index.write-intro()
    if ? self.second-index
      self.second-index.write-intro()
    self.seq.write-all-intro()
    # if ((index) < 0 || (index) >= seq->length) RAISE(line-num)
    # if ((index) < 0 || (second) < 0 || (index) + (second) > seq->length) RAISE(line-num)
    write(user "if ((")
    self.index.write-final()
    write(user ") < 0 || (")
    if ? self.second-index
      self.second-index.write-final()
      write(user ") < 0 || (")
    self.index.write-final()
    write(user ") ")
    if ? self.second-index
      write(user "+ (")
      self.second-index.write-final()
      write(user ") > ")
    else
      write(user ">= ")
    self.seq.write-all-final()
    write(user "->length) ")
    write-tb-raise()
    write-new-indent-line()
  
  func dynamic write-final()
    # ((Prmitive*)(seq->values))[index]
    # ((Complex*)(seq->values)) + index
    # &(Array){second, ((Type*)(seq->values)) + (index)}
    # &(String){second, second, seq->values + (index)}
    if ? self.second-index
      write(user "&(")
      write-cstyle(user self.seq-type.name)
      write(user "){")
      self.second-index.write-final()
      write(user ", ")
      if self.seq-type = glob.type-string
        self.second-index.write-final()
        write(user ", ")
    if ? self.item-type
      write(user "((")
      write-cstyle(user self.item-type.name)
      write(user "*)(")
    self.seq.write-all-final()
    write(user "->values")
    if ? self.item-type
      write(user "))")
    if ? self.second-index
      write(user " + (")
      self.index.write-final()
      write(user ")}")
    else-if ? self.item-type and not self.item-type.is-primitive
      write(user " + ")
      self.index.write-final()
    else
      write(user "[")
      self.index.write-final()
      write(user "]")


class St-exp(St)
  owner Mexp exp
  
  func dynamic parse()
    parse-new-exp-with-kw(user ""):(owner self.exp)
    self.exp.is-used := false
  
  func dynamic analyze-first()
    # do nothing
  
  func dynamic analyze()
    user Mtype mtype(_)
    user Mtype sub-mtype(_)
    self.exp.analyze():(user mtype, user sub-mtype)
  
  func dynamic write()
    self.exp.write-intro()
    self.exp.write-final()
    if not self.exp.is-used
      write(user ";")
